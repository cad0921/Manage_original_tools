<!DOCTYPE html>
<html lang="zh-Hant">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Game Asset CMS – Items / Animals / Hitboxes</title>
    <style>
        :root {
            --bg: #141c38;
            --panel: #1d2754;
            --panel2: #18224a;
            --text: #e6ecff;
            --muted: #b7c4ea;
            --primary: #7aa2ff;
            --accent: #7cffc4;
            --danger: #ff7a7a;
            --br: 16px;
            --pad: 14px;
            --gap: 12px;
            --shadow: 0 8px 28px rgba(0, 0, 0, .45);
        }

        * {
            box-sizing: border-box
        }

        body {
            margin: 0;
            background: radial-gradient(1200px 600px at 20% -10%, #26366c, transparent 65%), radial-gradient(1000px 500px at 120% 10%, #222d5c, transparent 55%), var(--bg);
            color: var(--text);
            font-family: system-ui, -apple-system, Segoe UI, Roboto, Noto Sans TC, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji"
        }

        header {
            position: sticky;
            top: 0;
            z-index: 5;
            background: linear-gradient(0deg, rgba(20, 28, 60, 0), rgba(20, 28, 60, .85)), var(--panel);
            backdrop-filter: saturate(1.2) blur(8px);
            border-bottom: 1px solid #1d2550
        }

        header .bar {
            max-width: 1200px;
            margin: auto;
            padding: 10px 16px;
            display: flex;
            gap: 10px;
            align-items: center
        }

        h1 {
            font-size: 18px;
            margin: 0 12px 0 0;
            letter-spacing: .5px
        }

        .tag {
            font-size: 12px;
            color: var(--muted)
        }

        .wrap {
            max-width: 1200px;
            margin: 20px auto;
            padding: 0 16px 48px
        }

        .tabs {
            display: flex;
            gap: 8px;
            flex-wrap: wrap
        }

        .tab-btn {
            border: 1px solid #2c3c78;
            background: linear-gradient(180deg, #243468, #1b2450);
            color: var(--text);
            padding: 8px 12px;
            border-radius: 999px;
            cursor: pointer
        }

        .tab-btn.active {
            border-color: #3b55c8;
            box-shadow: inset 0 0 0 1px #3b55c855
        }

        .grid {
            display: grid;
            grid-template-columns: 1.1fr 1fr;
            gap: 16px
        }

        .item-form {
            display: grid;
            grid-template-columns: minmax(0, 1fr) minmax(0, 0.95fr);
            gap: 16px;
            align-items: flex-start;
        }

        .item-main,
        .item-options {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .item-options {
            padding: 14px;
            border: 1px solid #29367a;
            border-radius: 14px;
            background: rgba(28, 38, 88, 0.65);
        }

        .item-options .row {
            align-items: flex-start;
        }

        @media (max-width:1000px) {
            .grid {
                grid-template-columns: 1fr
            }
            .item-form {
                grid-template-columns: 1fr;
            }
        }

        .panel {
            background: linear-gradient(180deg, var(--panel), var(--panel2));
            border: 1px solid #1d2550;
            border-radius: var(--br);
            box-shadow: var(--shadow)
        }

        .panel h2 {
            font-size: 16px;
            margin: 0 0 12px;
            color: #c9d5ff
        }

        .panel .head {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 14px;
            border-bottom: 1px solid #1d2550
        }

        .panel .body {
            padding: 16px;
            display: flex;
            flex-direction: column;
            gap: 12px
        }

        .row {
            display: flex;
            gap: 10px;
            align-items: center;
            flex-wrap: wrap
        }

        .row>label {
            min-width: 90px;
            color: var(--muted)
        }

        .row.ai-row,
        .row.creature-row {
            align-items: flex-start;
        }

        .ai-editor-host,
        .creature-editor-host {
            flex: 1;
        }

        .ai-editor,
        .creature-editor {
            display: flex;
            flex-direction: column;
            gap: 12px;
            width: 100%;
        }

        .ai-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
            background: #1a2856;
            border: 1px solid #2b3a7c;
            border-radius: 12px;
            padding: 12px;
        }

        .ai-group-title {
            font-weight: 600;
            color: #d7e0ff;
        }

        .ai-note {
            font-size: 12px;
            color: var(--muted);
        }

        .ai-toggle {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .ai-dialogue-list {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .ai-dialogue-row {
            display: flex;
            flex-direction: column;
            gap: 8px;
            padding: 12px;
            border-radius: 10px;
            border: 1px solid #1f2955;
            background: #0c1434;
        }

        .ai-dialogue-fields {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }

        .ai-inline {
            display: flex;
            flex-direction: column;
            gap: 4px;
            flex: 1 1 160px;
            min-width: 140px;
        }

        .ai-inline.small {
            flex: 0 0 160px;
        }

        .ai-inline.grow {
            flex: 2 1 260px;
            min-width: 220px;
        }

        .ai-inline-label {
            font-size: 12px;
            color: var(--muted);
        }

        .ai-inline textarea {
            min-height: 60px;
        }

        .ai-empty {
            font-size: 13px;
            color: var(--muted);
            border: 1px dashed #27306b;
            border-radius: 10px;
            padding: 12px;
            text-align: center;
        }

        .ai-dialogue-actions,
        .creature-actions {
            display: flex;
            justify-content: flex-end;
        }

        .ai-editor .btn.secondary {
            align-self: flex-start;
        }

        .creature-section {
            display: flex;
            flex-direction: column;
            gap: 10px;
            background: #1a2856;
            border: 1px solid #2b3a7c;
            border-radius: 12px;
            padding: 12px;
        }

        .creature-section-head {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 12px;
        }

        .creature-section-title {
            font-weight: 600;
            color: #d7e0ff;
        }

        .creature-note {
            font-size: 12px;
            color: var(--muted);
        }

        .creature-animation-list,
        .creature-skill-list {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .creature-animation-row,
        .creature-skill-row {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            align-items: flex-start;
            border: 1px solid #1f2955;
            background: #0c1434;
            border-radius: 10px;
            padding: 12px;
        }

        .creature-inline {
            display: flex;
            flex-direction: column;
            gap: 4px;
            flex: 1 1 180px;
            min-width: 160px;
        }

        .creature-inline.small {
            flex: 0 0 120px;
            min-width: 110px;
        }

        .creature-inline.tiny {
            flex: 0 0 100px;
            min-width: 90px;
        }

        .creature-inline.grow {
            flex: 2 1 260px;
            min-width: 220px;
        }

        .creature-inline .inline-label {
            font-size: 12px;
            color: var(--muted);
        }

        .creature-inline textarea {
            min-height: 70px;
        }

        .creature-toggle {
            display: flex;
            align-items: center;
            gap: 6px;
            margin-top: 20px;
        }

        .creature-empty {
            font-size: 13px;
            color: var(--muted);
            border: 1px dashed #27306b;
            border-radius: 10px;
            padding: 12px;
            text-align: center;
        }

        .creature-inline input[type="number"] {
            max-width: 120px;
        }

        .creature-legend {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            font-size: 12px;
            color: var(--muted);
        }

        input[type="text"],
        input[type="number"],
        textarea,
        select {
            width: 100%;
            padding: 10px 12px;
            border-radius: 10px;
            border: 1px solid #2f3d7a;
            background: #1a2452;
            color: var(--text)
        }

        .select-search {
            display: flex;
            flex-direction: column;
            gap: 6px;
            width: 100%;
        }

        .row .select-search {
            flex: 1;
        }

        .select-search-input {
            padding: 8px 10px;
            border-radius: 8px;
            border: 1px solid #2f3d7a;
            background: #202d5f;
            color: var(--text);
            transition: border-color .2s ease, box-shadow .2s ease;
        }

        .select-search-input:focus {
            outline: none;
            border-color: #4b65d4;
            box-shadow: 0 0 0 2px rgba(75, 101, 212, 0.25);
        }

        .select-search-empty {
            font-size: 12px;
            color: var(--muted);
            padding-left: 4px;
            display: none;
        }

        .select-search.is-empty .select-search-empty {
            display: block;
        }

        textarea {
            min-height: 80px
        }

        .btn {
            padding: 9px 12px;
            border-radius: 10px;
            border: 1px solid #2742a2;
            background: linear-gradient(180deg, #2541a0, #1a2e77);
            color: white;
            cursor: pointer
        }

        .btn:disabled {
            opacity: .5;
            cursor: not-allowed
        }

        .btn.secondary {
            border-color: #2a355f;
            background: linear-gradient(180deg, #1a224a, #141b34)
        }

        .btn.danger {
            border-color: #5a2231;
            background: linear-gradient(180deg, #7a273a, #541a28)
        }

        .chips {
            display: flex;
            flex-wrap: wrap;
            gap: 8px
        }

        .chip {
            padding: 6px 9px;
            border: 1px solid #32428c;
            background: #1b2a58;
            border-radius: 999px;
            font-size: 12px;
            color: #d9e5ff
        }

        .frame-duration-list {
            display: flex;
            flex-direction: column;
            gap: 8px;
            width: 100%
        }

        .frame-duration-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px 10px;
            border-radius: 10px;
            border: 1px solid #2f3d7a;
            background: #1c2856
        }

        .frame-duration-index {
            font-size: 12px;
            color: var(--muted);
            min-width: 32px
        }

        .frame-duration-name {
            flex: 1;
            font-size: 13px;
            color: var(--text);
            opacity: .85;
            word-break: break-all
        }

        .frame-duration-item input[type="number"] {
            max-width: 90px
        }

        .frame-duration-suffix {
            font-size: 12px;
            color: var(--muted)
        }

        .frame-duration-empty,
        .frame-duration-hint {
            font-size: 12px;
            color: var(--muted)
        }

        .list {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(240px, 1fr));
            gap: 12px
        }

        .card {
            background: #1a2552;
            border: 1px solid #2a3778;
            border-radius: 14px;
            padding: 12px;
            display: flex;
            gap: 10px
        }

        .card img {
            width: 48px;
            height: 48px;
            object-fit: cover;
            border-radius: 10px;
            border: 1px solid #2b3a7c
        }

        .card-actions {
            display: flex;
            flex-direction: column;
            gap: 6px
        }

        .thumbs {
            margin-top: 10px;
            display: flex;
            flex-wrap: wrap;
            gap: 8px
        }

        .thumbs img {
            width: 52px;
            height: 52px;
            object-fit: cover;
            border-radius: 8px;
            border: 1px solid #2b3a7c;
            background: #1c2856
        }

        .terrain-item {
            border: 1px solid #2a3778;
            border-radius: 14px;
            background: #1a2552;
            box-shadow: var(--shadow);
            padding: 0 12px 12px;
            color: var(--text)
        }

        .terrain-item[open] {
            border-color: #4b65d4;
            background: linear-gradient(180deg, rgba(44, 58, 120, .45), rgba(28, 38, 90, .92)), #1a2552;
        }

        .terrain-summary {
            list-style: none;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 12px;
            padding: 14px 0;
            cursor: pointer;
            font-weight: 600;
        }

        .terrain-summary::after {
            content: '\25BC';
            font-size: 12px;
            color: var(--muted);
            transition: transform .2s ease;
        }

        .terrain-item[open] .terrain-summary::after {
            transform: rotate(-180deg);
        }

        .terrain-summary::-webkit-details-marker {
            display: none;
        }

        .terrain-summary .title-wrap {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .terrain-summary .title {
            font-size: 15px;
        }

        .terrain-summary .meta {
            display: flex;
            gap: 12px;
            font-size: 12px;
            color: var(--muted);
        }

        .terrain-body {
            border-top: 1px solid #1d2550;
            margin-top: 6px;
            padding-top: 12px;
            display: grid;
            gap: 12px;
        }

        .terrain-form {
            display: grid;
            gap: 8px;
        }

        .terrain-form .row {
            display: grid;
            grid-template-columns: 110px 1fr;
            gap: 10px;
            align-items: center;
        }

        @media (max-width:600px) {
            .terrain-form .row {
                grid-template-columns: 1fr;
            }
        }

        .terrain-actions {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }

        .terrain-images {
            display: grid;
            gap: 10px;
        }

        .terrain-image-card {
            display: grid;
            grid-template-columns: auto 1fr;
            gap: 12px;
            padding: 10px;
            border: 1px solid #2b3a7c;
            border-radius: 12px;
            background: #1f2f64;
        }

        .terrain-image-card a {
            display: inline-flex;
            border-radius: 10px;
            overflow: hidden;
            border: 1px solid #2b3a7c;
        }

        .terrain-image-card img {
            width: 72px;
            height: 72px;
            object-fit: cover;
        }

        .terrain-image-info {
            display: grid;
            gap: 6px;
        }

        .terrain-image-info .meta {
            font-size: 12px;
            color: var(--muted);
        }

        .terrain-image-actions {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }

        .terrain-image-toggle {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            font-size: 12px;
            color: var(--muted);
        }

        .terrain-image-toggle input {
            margin: 0;
        }

        .checklist {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
        }

        .checklist label {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 6px 10px;
            border-radius: 999px;
            border: 1px solid #2b3a7c;
            background: #1b2a58;
            font-size: 13px;
            cursor: pointer;
        }

        .checklist input[type="checkbox"] {
            margin: 0;
        }

        .drop-editor-wrap {
            width: 100%;
        }

        .row.item-drop-row>label,
        .row.item-ui-row>label {
            align-self: flex-start;
            padding-top: 6px;
        }

        .drop-editor {
            display: grid;
            gap: 10px;
            padding: 10px;
            border: 1px solid #2b3a7c;
            border-radius: 12px;
            background: rgba(28, 38, 90, 0.82);
        }

        .drop-editor .drop-list {
            display: grid;
            gap: 8px;
        }

        .drop-editor .drop-row {
            display: grid;
            grid-template-columns: minmax(90px, 0.8fr) minmax(70px, 0.5fr) minmax(70px, 0.5fr) minmax(150px, 1fr) minmax(160px, 1.2fr) auto;
            gap: 8px;
            align-items: center;
            padding: 6px 8px;
            border: 1px dashed rgba(86, 110, 190, 0.6);
            border-radius: 10px;
            background: rgba(32, 44, 100, 0.35);
        }

        .drop-editor .drop-row input,
        .drop-editor .drop-row select {
            width: 100%;
        }

        .drop-editor .drop-row button {
            justify-self: end;
            padding: 6px 10px;
            border-radius: 8px;
            border: 1px solid #4a2850;
            background: linear-gradient(180deg, #7a273a, #541a28);
            color: #fff;
            cursor: pointer;
        }

        .drop-editor .drop-empty {
            padding: 10px;
            border-radius: 8px;
            border: 1px dashed rgba(58, 78, 150, 0.4);
            text-align: center;
            color: var(--muted);
            font-size: 13px;
        }

        .drop-editor .drop-actions {
            display: flex;
            align-items: center;
            gap: 10px;
            flex-wrap: wrap;
        }

        .drop-editor .drop-note {
            font-size: 12px;
            color: var(--muted);
        }

        .drop-editor .btn-add-drop {
            padding: 7px 12px;
            border-radius: 10px;
            border: 1px solid #2742a2;
            background: linear-gradient(180deg, rgba(39, 66, 162, 0.65), rgba(26, 46, 119, 0.8));
            color: #fff;
            cursor: pointer;
        }

        .drop-editor .btn-add-drop:disabled {
            opacity: .6;
            cursor: not-allowed;
        }

        .ui-gallery-host {
            width: 100%;
        }

        .ui-gallery {
            display: flex;
            flex-direction: column;
            gap: 10px;
            width: 100%;
        }

        .ui-gallery-list {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
            gap: 10px;
        }

        .ui-gallery-empty {
            border: 1px dashed rgba(58, 78, 150, 0.4);
            border-radius: 12px;
            padding: 16px;
            text-align: center;
            font-size: 13px;
            color: var(--muted);
            background: rgba(30, 42, 95, 0.45);
        }

        .ui-thumb {
            display: flex;
            flex-direction: column;
            gap: 8px;
            padding: 10px;
            border-radius: 12px;
            border: 1px solid rgba(64, 90, 180, 0.55);
            background: linear-gradient(180deg, rgba(30, 45, 105, 0.8), rgba(22, 32, 82, 0.85));
        }

        .ui-thumb img {
            width: 100%;
            height: 110px;
            object-fit: cover;
            border-radius: 8px;
            background: rgba(4, 9, 28, 0.55);
        }

        .ui-thumb .ui-thumb-label {
            width: 100%;
            border-radius: 8px;
            border: 1px solid #314395;
            background: rgba(14, 24, 64, 0.65);
            color: var(--text);
            padding: 6px 8px;
        }

        .ui-thumb .ui-thumb-note {
            font-size: 11px;
            color: var(--muted);
        }

        .ui-thumb .ui-thumb-actions {
            display: flex;
            justify-content: space-between;
            gap: 8px;
        }

        .ui-thumb .ui-thumb-actions button {
            flex: 1;
            padding: 6px 8px;
            border-radius: 8px;
            border: 1px solid #3a4ca0;
            background: linear-gradient(180deg, rgba(58, 76, 160, 0.75), rgba(32, 46, 118, 0.85));
            color: #fff;
            cursor: pointer;
        }

        .ui-thumb .ui-thumb-actions button.danger {
            border-color: #7a2c3c;
            background: linear-gradient(180deg, rgba(122, 44, 60, 0.8), rgba(88, 28, 40, 0.85));
        }

        .ui-gallery-actions {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            align-items: center;
        }

        .ui-gallery-actions .btn-upload-ui {
            padding: 7px 12px;
            border-radius: 10px;
            border: 1px solid #2742a2;
            background: linear-gradient(180deg, rgba(39, 66, 162, 0.65), rgba(26, 46, 119, 0.8));
            color: #fff;
            cursor: pointer;
        }

        .ui-gallery-actions .ui-gallery-note {
            font-size: 12px;
            color: var(--muted);
        }

        @media (max-width:780px) {
            .drop-editor .drop-row {
                grid-template-columns: repeat(2, minmax(0, 1fr));
            }

            .drop-editor .drop-row button {
                justify-self: stretch;
            }
        }

        .item-group {
            border: 1px solid #2a3778;
            border-radius: 14px;
            background: #1a2552;
            box-shadow: var(--shadow);
            padding: 0 12px 12px;
            color: var(--text);
        }

        .item-group[open] {
            border-color: #8cb2ff;
            background: linear-gradient(180deg, rgba(58, 80, 150, .4), rgba(28, 38, 90, .92)), #1a2552;
        }

        .item-summary {
            list-style: none;
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 12px;
            padding: 14px 0;
            cursor: pointer;
            font-weight: 600;
        }

        .item-summary::-webkit-details-marker {
            display: none;
        }

        .item-summary::after {
            content: '\25BC';
            font-size: 12px;
            color: var(--muted);
            transition: transform .2s ease;
        }

        .item-group[open] .item-summary::after {
            transform: rotate(-180deg);
        }

        .item-summary .meta {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            font-size: 12px;
            color: var(--muted);
        }

        .item-entries {
            display: grid;
            gap: 10px;
        }

        .item-card {
            border: 1px solid #2b3a7c;
            border-radius: 12px;
            background: #1f2f64;
            padding: 0 12px 12px;
        }

        .item-card[open] {
            border-color: #7aa2ff;
        }

        .item-card summary {
            list-style: none;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 12px;
            padding: 12px 0;
            cursor: pointer;
            font-weight: 600;
        }

        .item-card summary::-webkit-details-marker {
            display: none;
        }

        .item-card summary::after {
            content: '\25B6';
            font-size: 12px;
            color: var(--muted);
            transition: transform .2s ease;
        }

        .item-card[open] summary::after {
            transform: rotate(90deg);
        }

        .item-body {
            border-top: 1px solid #2b3a7c;
            padding-top: 12px;
            display: grid;
            gap: 12px;
        }

        .item-form {
            display: grid;
            gap: 10px;
        }

        .item-form .row {
            display: grid;
            grid-template-columns: 120px 1fr;
            gap: 10px;
            align-items: center;
        }

        @media (max-width:600px) {
            .item-form .row {
                grid-template-columns: 1fr;
            }
        }

        .item-actions {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }

        .item-image-preview {
            display: flex;
            gap: 12px;
            align-items: flex-start;
        }

        .item-image-preview img {
            width: 96px;
            height: 96px;
            object-fit: cover;
            border-radius: 12px;
            border: 1px solid #2b3a7c;
            background: #1f2f64;
        }

        .item-image-meta {
            display: grid;
            gap: 6px;
        }

        .terrain-empty {
            font-size: 12px;
            color: var(--muted);
        }

        .card .title {
            font-weight: 600
        }

        .kvs {
            display: grid;
            grid-template-columns: 100px 1fr;
            gap: 6px;
            font-size: 13px;
            color: #cfd8ff
        }

        .kvs div:nth-child(odd) {
            color: #91a2ff
        }

        .pill {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            border: 1px solid #32428c;
            background: #1b2a58;
            border-radius: 999px;
            padding: 6px 9px
        }

        .small {
            font-size: 12px;
            color: var(--muted)
        }

        canvas {
            background: #1b2b5a;
            border: 1px dashed #3a4ca0;
            border-radius: 10px;
            max-width: 100%;
            touch-action: none
        }

        .toolbar {
            display: flex;
            gap: 8px;
            flex-wrap: wrap
        }

        .note {
            font-size: 12px;
            color: #9fb4ff
        }

        .footer {
            margin-top: 16px;
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            align-items: center
        }
    </style>
</head>

<body>
    <header>
        <div class="bar">
            <h1>Game Asset CMS</h1>
            <div class="tag">Items / Animals (Animations) / Entities (Hitboxes) / Terrains – 本機儲存、可匯入匯出</div>
            <div style="flex:1"></div>
            <button class="btn secondary" id="btnReset">重置</button>
            <label class="btn secondary" for="importJson">匯入 JSON</label>
            <input id="importJson" type="file" accept="application/json" style="display:none" />
            <button class="btn" id="btnExport">匯出 JSON</button>
        </div>
    </header>

    <div class="wrap">
        <div class="tabs" id="tabs"></div>

        <!-- Terrains -->
        <section class="panel" data-tab="terrains">
            <div class="head">
                <h2>Terrains 地形管理</h2>
            </div>
            <div class="body">
                <div class="grid">
                    <div>
                        <div class="row"><label>名稱</label><input id="tName" type="text" placeholder="例：草地" /></div>
                        <div class="row"><label>Tag</label><input id="tTag" type="text"
                                placeholder="例：walkable / slippery / lava" /></div>
                        <div class="row"><label>圖片</label><input id="tImages" type="file" accept="image/*" multiple />
                        </div>
                        <div class="row"><button id="addTerrain" class="btn">新增地形</button></div>
                    </div>
                    <div>
                        <div class="list" id="terrainList"></div>
                    </div>
                </div>
            </div>
        </section>

        <!-- Items -->
        <section class="panel" data-tab="items">
            <div class="head">
                <h2>Items 物品 → 可放置地形</h2>
            </div>
            <div class="body">
                <div class="grid">
                    <div>
                        <div class="item-form">
                            <div class="item-main">
                                <div class="row"><label>名稱</label><input id="iName" type="text" placeholder="紅寶石礦 / 木箱 / 陷阱" /></div>
                                <div class="row"><label>分類</label>
                                    <select id="iCategory"></select>
                                </div>
                                <div class="row"><label>圖片</label><input id="iIcon" type="file" accept="image/*" /></div>
                                <div class="row"><label>備註</label><textarea id="iNote" placeholder="限制、互動規則等…"></textarea></div>
                                <div class="row"><button id="addItem" class="btn">新增物品</button></div>
                            </div>
                            <div class="item-options">
                                <div class="row"><label>適用地形</label>
                                    <div id="iTerrainChecks" class="checklist"></div>
                                </div>
                                <div class="row item-drop-row"><label>掉落設定</label>
                                    <div id="iDropEditor" class="drop-editor-wrap"></div>
                                </div>
                                <div class="row item-ui-row" id="iUiFields">
                                    <label>互動 UI 圖片</label>
                                    <div class="ui-gallery-host" id="iUiGallery"></div>
                                </div>
                                <div class="row creature-row" id="iCreatureFields">
                                    <label>生物設定</label>
                                    <div class="creature-editor-host" id="iCreatureEditorHost"></div>
                                </div>
                                <div class="row ai-row" id="iAiFields">
                                    <label>AI 設定</label>
                                    <div class="ai-editor-host" id="iAiEditorHost"></div>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div>
                        <div class="list" id="itemList"></div>
                    </div>
                </div>
            </div>
        </section>

        <!-- Animals -->
        <section class="panel" data-tab="animals">
            <div class="head">
                <h2>Animals 動物 → 動畫列表</h2>
            </div>
            <div class="body">
                <div class="grid">
                    <div>
                        <div class="row"><label>名稱</label><input id="aName" type="text" placeholder="小安德 / 史萊姆" /></div>
                        <div class="row"><label>預覽圖</label><input id="aPreview" type="file" accept="image/*" /></div>
                        <div class="row"><label>動畫名稱</label><input id="clipName" type="text"
                                placeholder="idle / walk / attack" /></div>
                        <div class="row"><label>FPS</label><input id="clipFps" type="number" value="6" min="1"
                                max="60" /></div>
                        <div class="row"><label>動畫幀圖片</label><input id="clipFrames" type="file" accept="image/*"
                                multiple /></div>
                        <div class="row"><label>各幀秒數</label>
                                <div id="clipFrameList" class="frame-duration-list">
                                    <div class="frame-duration-empty">尚未選擇圖片</div>
                                </div>
                            </div>
                        <div class="row"><label>生成地形</label>
                            <div id="aTerrainChecks" class="chips"></div>
                        </div>
                        <div class="toolbar">
                            <button id="addClip" class="btn secondary">加入動畫到此動物</button>
                            <button id="addAnimal" class="btn">新增/更新 動物</button>
                        </div>
                        <div class="note">提示：可以先選擇預覽圖與動畫幀，再按「加入動畫」；重複加入多個 clip。</div>
                    </div>
                    <div>
                        <div class="list" id="animalList"></div>
                        <div class="panel" style="margin-top:12px">
                            <div class="head">
                                <h2>動畫即時預覽</h2>
                            </div>
                            <div class="body">
                                <canvas id="animCanvas" width="320" height="240"></canvas>
                                <div class="row">
                                    <label>選擇動物</label>
                                    <select id="previewAnimal"></select>
                                </div>
                                <div class="row">
                                    <label>選擇動畫</label>
                                    <select id="previewClip"></select>
                                </div>
                                <div class="row">
                                    <label>速度倍率</label>
                                    <input id="previewSpeed" type="number" value="1" step="0.1" min="0.1" />
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <!-- Entities / Hitboxes -->
        <section class="panel" data-tab="entities">
            <div class="head">
                <h2>Entities 生物 → 碰撞箱（矩形）</h2>
            </div>
            <div class="body">
                <div class="grid">
                    <div>
                        <div class="row"><label>來源</label><select id="eSource"></select></div>
                        <div class="row"><label>名稱</label><input id="eName" type="text" placeholder="敵人或可互動物件名稱" />
                        </div>
                        <div class="row"><label>底圖</label><input id="eImage" type="file" accept="image/*" /></div>
                        <div class="toolbar">
                            <span class="pill">Shift+左鍵拖曳：新增碰撞箱</span>
                            <span class="pill">右鍵：刪除此框</span>
                            <span class="pill">拖曳角落：縮放</span>
                            <button id="clearHitboxes" class="btn danger">清空所有框</button>
                            <button id="saveEntity" class="btn">新增/更新 生物</button>
                        </div>
                        <canvas id="hitCanvas" width="420" height="320"></canvas>
                        <div class="small">儲存為 0..1 正規化座標（與圖片無關比例，可安全匯出到遊戲）</div>
                    </div>
                    <div>
                        <div class="list" id="entityList"></div>
                        <div class="panel" style="margin-top:12px">
                            <div class="head">
                                <h2>目前碰撞框</h2>
                            </div>
                            <div class="body" id="hitList"></div>
                        </div>
                    </div>
                </div>
            </div>
        </section>
    </div>

    <template id="tpl-card">
        <div class="card">
            <img />
            <div class="card-body" style="flex:1">
                <div class="title"></div>
                <div class="kvs"></div>
            </div>
            <div class="card-actions">
                <button class="btn secondary edit">編輯</button>
                <button class="btn danger del">刪除</button>
            </div>
        </div>
    </template>

    <script>
        // ----------------------------- Data Types -----------------------------
        const LS_KEY = 'asset-cms-v1';
        const uid = () => Math.random().toString(36).slice(2, 9);
        const terrainApiUrl = 'terrain_api.php';
        const itemApiUrl = 'item_api.php';
        let pendingOpenItemId = null;
        let pendingOpenCategoryId = null;
        const selectSearchControls = new WeakMap();
        const defaultItemCategories = [
            { id: 'decor', label: '裝飾' },
            { id: 'interactive', label: '可互動' },
            { id: 'building', label: '建材' },
            { id: 'drop', label: '掉落物' },
            { id: 'resource', label: '素材' },
            { id: 'consumable', label: '消耗品' },
            { id: 'crop', label: '農作物' },
            { id: 'mineral', label: '礦物' },
            { id: 'tree', label: '樹木' },
            { id: 'animal', label: '生物' }
        ];

        const emptyProject = () => ({
            meta: { name: 'My Game Assets', version: '1.0.0', updatedAt: new Date().toISOString() },
            terrains: [
                { id: 'grass', name: '草地', tag: 'walkable' },
                { id: 'sand', name: '沙地', tag: 'walkable' },
                { id: 'snow', name: '雪地', tag: 'slippery' },
                { id: 'stone', name: '岩地', tag: 'walkable' },
                { id: 'water', name: '水域', tag: 'swim' },
            ],
            itemCategories: defaultItemCategories.slice(),
            items: [],
            animals: [],
            entities: [],
        });

        let project = JSON.parse(localStorage.getItem(LS_KEY) || 'null') || emptyProject();
        if (!Array.isArray(project.itemCategories) || project.itemCategories.length === 0) {
            project.itemCategories = defaultItemCategories.slice();
        }
        if (!Array.isArray(project.items)) {
            project.items = [];
        }
        if (!Array.isArray(project.animals)) {
            project.animals = [];
        }
        upgradeAnimalClips();
        const saveProject = () => { project.meta.updatedAt = new Date().toISOString(); localStorage.setItem(LS_KEY, JSON.stringify(project)); renderAll(); };

        // ----------------------------- Tabs -----------------------------
        const tabsEl = document.getElementById('tabs');
        const sections = Array.from(document.querySelectorAll('[data-tab]'));
        const tabNames = ['terrains', 'items', 'animals', 'entities'];
        let currentTab = localStorage.getItem('asset-cms-tab') || 'terrains';
        const switchTab = (name) => {
            currentTab = name; localStorage.setItem('asset-cms-tab', name);
            sections.forEach(sec => sec.style.display = sec.getAttribute('data-tab') === name ? 'block' : 'none');
            Array.from(tabsEl.children).forEach(btn => btn.classList.toggle('active', btn.dataset.name === name));
        };
        tabNames.forEach(n => {
            const b = document.createElement('button'); b.className = 'tab-btn'; b.dataset.name = n; b.textContent = n.toUpperCase(); b.onclick = () => switchTab(n); tabsEl.appendChild(b);
        });

        // ----------------------------- Terrains -----------------------------
        const tName = document.getElementById('tName');
        const tTag = document.getElementById('tTag');
        const tImages = document.getElementById('tImages');
        const addTerrain = document.getElementById('addTerrain');
        const terrainList = document.getElementById('terrainList');

        addTerrain.onclick = async () => {
            const name = tName.value.trim();
            if (!name) return alert('請輸入名稱');
            const originalText = addTerrain.textContent;
            const tag = tTag.value.trim();
            const files = Array.from(tImages.files || []);
            const formData = new FormData();
            formData.append('action', 'create');
            formData.append('name', name);
            formData.append('tag', tag);
            files.forEach(file => formData.append('images[]', file));
            addTerrain.disabled = true;
            addTerrain.textContent = '儲存中...';
            try {
                const res = await fetch(terrainApiUrl, { method: 'POST', body: formData });
                const data = await res.json();
                if (!res.ok || data.status !== 'ok') {
                    throw new Error(data.message || '新增地形失敗');
                }
                project.terrains = Array.isArray(data.terrains) ? data.terrains : [];
                tName.value = '';
                tTag.value = '';
                tImages.value = '';
                saveProject();
            } catch (err) {
                console.error('Failed to create terrain', err);
                alert('新增地形失敗：' + (err.message || '發生未知錯誤'));
            } finally {
                addTerrain.disabled = false;
                addTerrain.textContent = originalText;
            }
        };

        function renderTerrains() {
            const previouslyOpen = new Set(Array.from(terrainList.querySelectorAll('.terrain-item[open]')).map(el => el.dataset.terrainId));
            terrainList.innerHTML = '';
            (project.terrains || []).forEach(tr => {
                const tagText = tr.tag || '-';
                const images = Array.isArray(tr.images) ? tr.images : [];
                const imageCount = images.length;

                const details = document.createElement('details');
                details.className = 'terrain-item';
                details.dataset.terrainId = tr.id;
                if (previouslyOpen.has(tr.id)) details.open = true;

                const summary = document.createElement('summary');
                summary.className = 'terrain-summary';
                summary.innerHTML = `
                    <div class="title-wrap">
                        <span class="title">${tr.name}</span>
                        <span class="pill">Tag: ${tagText}</span>
                    </div>
                    <div class="meta">
                        <span>ID: ${tr.id}</span>
                        <span>圖片 ${imageCount} 張</span>
                    </div>`;
                details.appendChild(summary);

                const body = document.createElement('div');
                body.className = 'terrain-body';

                // Editable form for name/tag
                const form = document.createElement('div');
                form.className = 'terrain-form';

                const nameRow = document.createElement('div'); nameRow.className = 'row';
                const nameLabel = document.createElement('label'); nameLabel.textContent = '名稱';
                const nameInput = document.createElement('input'); nameInput.type = 'text'; nameInput.value = tr.name;
                nameRow.appendChild(nameLabel); nameRow.appendChild(nameInput);

                const tagRow = document.createElement('div'); tagRow.className = 'row';
                const tagLabel = document.createElement('label'); tagLabel.textContent = 'Tag';
                const tagInput = document.createElement('input'); tagInput.type = 'text'; tagInput.value = tr.tag || '';
                tagRow.appendChild(tagLabel); tagRow.appendChild(tagInput);

                form.appendChild(nameRow);
                form.appendChild(tagRow);

                const formActions = document.createElement('div'); formActions.className = 'terrain-actions';
                const saveBtn = document.createElement('button'); saveBtn.className = 'btn'; saveBtn.textContent = '儲存變更';
                const addImageBtn = document.createElement('button'); addImageBtn.className = 'btn secondary'; addImageBtn.textContent = '新增圖片';
                const deleteBtn = document.createElement('button'); deleteBtn.className = 'btn danger'; deleteBtn.textContent = '刪除此地形';
                formActions.append(saveBtn, addImageBtn, deleteBtn);
                form.appendChild(formActions);

                body.appendChild(form);

                // Image gallery
                if (imageCount === 0) {
                    const empty = document.createElement('div');
                    empty.className = 'terrain-empty';
                    empty.textContent = '尚未上傳圖片';
                    body.appendChild(empty);
                } else {
                    const imagesContainer = document.createElement('div');
                    imagesContainer.className = 'terrain-images';
                    images.forEach(img => {
                        if (!img || !img.path) return;
                        const card = document.createElement('div');
                        card.className = 'terrain-image-card';

                        const link = document.createElement('a');
                        link.href = img.path;
                        link.target = '_blank';
                        const imageEl = document.createElement('img');
                        imageEl.src = img.path;
                        imageEl.alt = `${tr.name} 圖片`;
                        link.appendChild(imageEl);
                        card.appendChild(link);

                        const info = document.createElement('div');
                        info.className = 'terrain-image-info';
                        const labelInput = document.createElement('input');
                        labelInput.type = 'text';
                        labelInput.value = (img.label && img.label.trim()) || (img.filename ? img.filename.replace(/\.[^/.]+$/, '') : '');
                        labelInput.placeholder = '顯示名稱';
                        info.appendChild(labelInput);

                        const renameToggle = document.createElement('label');
                        renameToggle.className = 'terrain-image-toggle';
                        const renameCheckbox = document.createElement('input');
                        renameCheckbox.type = 'checkbox';
                        renameToggle.appendChild(renameCheckbox);
                        renameToggle.append(' 同步修改檔案名稱');
                        info.appendChild(renameToggle);

                        const meta = document.createElement('div');
                        meta.className = 'meta';
                        const uploadedAt = img.uploadedAt ? new Date(img.uploadedAt).toLocaleString() : '';
                        meta.textContent = `檔案: ${img.filename || '未知'}${uploadedAt ? `｜上傳：${uploadedAt}` : ''}`;
                        info.appendChild(meta);

                        const imgActions = document.createElement('div');
                        imgActions.className = 'terrain-image-actions';
                        const renameBtn = document.createElement('button');
                        renameBtn.className = 'btn secondary';
                        renameBtn.textContent = '更新名稱';
                        const removeBtn = document.createElement('button');
                        removeBtn.className = 'btn danger';
                        removeBtn.textContent = '刪除此圖片';
                        imgActions.append(renameBtn, removeBtn);
                        info.appendChild(imgActions);

                        card.appendChild(info);
                        imagesContainer.appendChild(card);

                        renameBtn.onclick = async (e) => {
                            e.preventDefault();
                            const newLabel = labelInput.value.trim();
                            if (newLabel === '') {
                                return alert('名稱不可為空');
                            }
                            const original = renameBtn.textContent;
                            renameBtn.disabled = true;
                            renameBtn.textContent = '更新中...';
                            const formData = new FormData();
                            formData.append('action', 'update');
                            formData.append('id', tr.id);
                            formData.append('name', nameInput.value.trim() || tr.name);
                            formData.append('tag', tagInput.value.trim());
                            formData.append('renameImages', JSON.stringify([
                                { filename: img.filename, label: newLabel, renameFile: renameCheckbox.checked }
                            ]));
                            try {
                                const res = await fetch(terrainApiUrl, { method: 'POST', body: formData });
                                const data = await res.json();
                                if (!res.ok || data.status !== 'ok') throw new Error(data.message || '更新失敗');
                                project.terrains = Array.isArray(data.terrains) ? data.terrains : [];
                                saveProject();
                            } catch (err) {
                                console.error('Failed to rename image', err);
                                alert('更新圖片名稱失敗：' + (err.message || '未知錯誤'));
                            } finally {
                                renameBtn.disabled = false;
                                renameBtn.textContent = original;
                            }
                        };

                        removeBtn.onclick = async (e) => {
                            e.preventDefault();
                            if (!confirm('確定刪除此圖片？檔案將被移除。')) return;
                            const original = removeBtn.textContent;
                            removeBtn.disabled = true;
                            removeBtn.textContent = '刪除中...';
                            const formData = new FormData();
                            formData.append('action', 'update');
                            formData.append('id', tr.id);
                            formData.append('name', nameInput.value.trim() || tr.name);
                            formData.append('tag', tagInput.value.trim());
                            formData.append('removeImages', JSON.stringify([img.filename]));
                            try {
                                const res = await fetch(terrainApiUrl, { method: 'POST', body: formData });
                                const data = await res.json();
                                if (!res.ok || data.status !== 'ok') throw new Error(data.message || '刪除失敗');
                                project.terrains = Array.isArray(data.terrains) ? data.terrains : [];
                                saveProject();
                            } catch (err) {
                                console.error('Failed to delete image', err);
                                alert('刪除圖片失敗：' + (err.message || '未知錯誤'));
                            } finally {
                                removeBtn.disabled = false;
                                removeBtn.textContent = original;
                            }
                        };
                    });
                    body.appendChild(imagesContainer);
                }

                details.appendChild(body);

                // Button behaviors
                saveBtn.onclick = async (e) => {
                    e.preventDefault();
                    const newName = nameInput.value.trim();
                    if (newName === '') return alert('地形名稱不可為空');
                    const original = saveBtn.textContent;
                    saveBtn.disabled = true;
                    saveBtn.textContent = '儲存中...';
                    const formData = new FormData();
                    formData.append('action', 'update');
                    formData.append('id', tr.id);
                    formData.append('name', newName);
                    formData.append('tag', tagInput.value.trim());
                    try {
                        const res = await fetch(terrainApiUrl, { method: 'POST', body: formData });
                        const data = await res.json();
                        if (!res.ok || data.status !== 'ok') throw new Error(data.message || '儲存失敗');
                        project.terrains = Array.isArray(data.terrains) ? data.terrains : [];
                        saveProject();
                    } catch (err) {
                        console.error('Failed to update terrain', err);
                        alert('更新地形失敗：' + (err.message || '發生未知錯誤'));
                    } finally {
                        saveBtn.disabled = false;
                        saveBtn.textContent = original;
                    }
                };

                addImageBtn.onclick = () => {
                    const input = document.createElement('input');
                    input.type = 'file';
                    input.accept = 'image/*';
                    input.multiple = true;
                    input.onchange = async () => {
                        const files = Array.from(input.files || []);
                        if (files.length === 0) return;
                        const original = addImageBtn.textContent;
                        addImageBtn.disabled = true;
                        addImageBtn.textContent = '上傳中...';
                        const formData = new FormData();
                        formData.append('action', 'update');
                        formData.append('id', tr.id);
                        formData.append('name', nameInput.value.trim() || tr.name);
                        formData.append('tag', tagInput.value.trim());
                        files.forEach(file => formData.append('images[]', file));
                        try {
                            const res = await fetch(terrainApiUrl, { method: 'POST', body: formData });
                            const data = await res.json();
                            if (!res.ok || data.status !== 'ok') throw new Error(data.message || '新增圖片失敗');
                            project.terrains = Array.isArray(data.terrains) ? data.terrains : [];
                            saveProject();
                            details.open = true;
                        } catch (err) {
                            console.error('Failed to append images', err);
                            alert('新增圖片失敗：' + (err.message || '發生未知錯誤'));
                        } finally {
                            addImageBtn.disabled = false;
                            addImageBtn.textContent = original;
                            input.value = '';
                        }
                    };
                    input.click();
                };

                deleteBtn.onclick = async (e) => {
                    e.preventDefault();
                    if (!confirm('刪除此地形？已綁定的 Items / Animals 會保留其 ID。')) return;
                    const original = deleteBtn.textContent;
                    deleteBtn.disabled = true;
                    deleteBtn.textContent = '刪除中...';
                    const formData = new FormData();
                    formData.append('action', 'delete');
                    formData.append('id', tr.id);
                    try {
                        const res = await fetch(terrainApiUrl, { method: 'POST', body: formData });
                        const data = await res.json();
                        if (!res.ok || data.status !== 'ok') throw new Error(data.message || '刪除地形失敗');
                        project.terrains = Array.isArray(data.terrains) ? data.terrains : [];
                        (project.items || []).forEach(it => {
                            if (!Array.isArray(it.terrains)) return;
                            it.terrains = it.terrains.filter(id => id !== tr.id);
                        });
                        (project.animals || []).forEach(an => {
                            if (!Array.isArray(an.spawnTerrains)) return;
                            an.spawnTerrains = an.spawnTerrains.filter(id => id !== tr.id);
                        });
                        saveProject();
                    } catch (err) {
                        console.error('Failed to delete terrain', err);
                        alert('刪除地形失敗：' + (err.message || '發生未知錯誤'));
                    } finally {
                        deleteBtn.disabled = false;
                        deleteBtn.textContent = original;
                    }
                };

                terrainList.appendChild(details);
            });
            renderItemTerrainChecks();
            renderAnimalTerrainChecks();
        }

        function populateTerrainChecklist(container, selected = []) {
            container.innerHTML = '';
            const selectedSet = new Set(selected);
            (project.terrains || []).forEach(tr => {
                const label = document.createElement('label');
                const ck = document.createElement('input');
                ck.type = 'checkbox';
                ck.dataset.tid = tr.id;
                ck.checked = selectedSet.has(tr.id);
                label.appendChild(ck);
                label.append(' ' + tr.name);
                container.appendChild(label);
            });
        }

        function renderItemTerrainChecks() {
            const wrap = document.getElementById('iTerrainChecks');
            populateTerrainChecklist(wrap, []);
        }

        function renderAnimalTerrainChecks() {
            const wrap = document.getElementById('aTerrainChecks');
            if (!wrap) return;
            wrap.innerHTML = '';
            (project.terrains || []).forEach(tr => {
                const id = 'achk_' + tr.id;
                const label = document.createElement('label');
                label.className = 'pill';
                label.textContent = tr.name;
                label.style.cursor = 'pointer';
                label.htmlFor = id;
                const ck = document.createElement('input');
                ck.type = 'checkbox';
                ck.id = id;
                ck.dataset.tid = tr.id;
                ck.style.marginRight = '6px';
                const holder = document.createElement('div');
                holder.className = 'row';
                holder.appendChild(ck);
                holder.appendChild(label);
                wrap.appendChild(holder);
            });
        }

        async function syncTerrainsFromServer() {
            try {
                const res = await fetch(`${terrainApiUrl}?_=${Date.now()}`);
                if (!res.ok) throw new Error('網路錯誤');
                const data = await res.json();
                if (data.status !== 'ok' || !Array.isArray(data.terrains)) {
                    throw new Error(data.message || '資料格式錯誤');
                }
                project.terrains = data.terrains;
                saveProject();
            } catch (err) {
                console.warn('同步地形資料失敗', err);
            }
        }

        async function syncItemsFromServer() {
            try {
                const res = await fetch(`${itemApiUrl}?_=${Date.now()}`);
                if (!res.ok) throw new Error('網路錯誤');
                const data = await res.json();
                if (data.status !== 'ok' || !Array.isArray(data.items)) {
                    throw new Error(data.message || '資料格式錯誤');
                }
                updateItemsState(data.items, data.categories);
            } catch (err) {
                console.warn('同步物品資料失敗', err);
            }
        }

        // ----------------------------- Items -----------------------------
        const iName = document.getElementById('iName');
        const iCategory = document.getElementById('iCategory');
        const iIcon = document.getElementById('iIcon');
        const iNote = document.getElementById('iNote');
        const addItem = document.getElementById('addItem');
        const itemList = document.getElementById('itemList');

        async function fileToDataUrl(file) {
            return await new Promise((res, rej) => { const r = new FileReader(); r.onload = () => res(String(r.result)); r.onerror = rej; r.readAsDataURL(file); });
        }

        function ensureItemCategories(categories) {
            if (Array.isArray(categories) && categories.length > 0) {
                project.itemCategories = categories;
            } else if (!Array.isArray(project.itemCategories) || project.itemCategories.length === 0) {
                project.itemCategories = defaultItemCategories.slice();
            }
        }

        function parseBooleanLike(value) {
            if (typeof value === 'boolean') return value;
            if (typeof value === 'string') {
                const normalized = value.trim().toLowerCase();
                if (['true', '1', 'yes', 'y', 'on'].includes(normalized)) return true;
                if (['false', '0', 'no', 'n', 'off', ''].includes(normalized)) return false;
            }
            if (typeof value === 'number') {
                return value !== 0;
            }
            return false;
        }

        function enableSelectSearch(select, { placeholder = '搜尋…', emptyText = '沒有符合的選項', alwaysVisible = [] } = {}) {
            if (!select) return null;
            const opts = { placeholder, emptyText, alwaysVisible };
            let control = selectSearchControls.get(select);
            if (control) {
                if (control.input) control.input.placeholder = opts.placeholder;
                if (control.empty) control.empty.textContent = opts.emptyText;
                control.setAlwaysVisible(opts.alwaysVisible);
                control.refresh();
                return control;
            }
            const wrapper = document.createElement('div');
            wrapper.className = 'select-search';
            const input = document.createElement('input');
            input.type = 'search';
            input.className = 'select-search-input';
            input.placeholder = opts.placeholder;
            const empty = document.createElement('div');
            empty.className = 'select-search-empty';
            empty.textContent = opts.emptyText;
            select.parentNode.insertBefore(wrapper, select);
            wrapper.appendChild(input);
            wrapper.appendChild(select);
            wrapper.appendChild(empty);

            let alwaysVisibleSet = new Set(Array.isArray(opts.alwaysVisible) ? opts.alwaysVisible : []);

            const filter = () => {
                const query = input.value.trim().toLowerCase();
                let visibleCount = 0;
                Array.from(select.options).forEach(option => {
                    const skip = option.disabled || option.dataset.searchSkip === '1' || alwaysVisibleSet.has(option.value);
                    if (!query || skip) {
                        option.hidden = false;
                        if (!skip && option.value !== '') visibleCount++;
                        return;
                    }
                    const text = (option.textContent || '').toLowerCase();
                    const value = (option.value || '').toLowerCase();
                    const match = text.includes(query) || value.includes(query);
                    option.hidden = !match;
                    if (match) visibleCount++;
                });
                wrapper.classList.toggle('has-query', query.length > 0);
                wrapper.classList.toggle('is-empty', query.length > 0 && visibleCount === 0);
            };

            const refresh = () => {
                if (!input.value.trim()) {
                    Array.from(select.options).forEach(option => option.hidden = false);
                    wrapper.classList.remove('has-query');
                    wrapper.classList.remove('is-empty');
                    return;
                }
                filter();
            };

            const clear = () => {
                if (!input.value) return;
                input.value = '';
                refresh();
            };

            input.addEventListener('input', filter);
            input.addEventListener('keydown', ev => {
                if (ev.key === 'Escape' && input.value) {
                    clear();
                    ev.preventDefault();
                }
            });

            select.addEventListener('change', () => {
                const selected = select.options[select.selectedIndex];
                if (selected && selected.hidden) {
                    clear();
                }
            });

            control = {
                wrapper,
                input,
                empty,
                filter,
                refresh,
                clear,
                setAlwaysVisible(list) {
                    alwaysVisibleSet = new Set(Array.isArray(list) ? list : []);
                }
            };
            selectSearchControls.set(select, control);
            refresh();
            return control;
        }

        function sanitizeAiData(raw) {
            const source = raw && typeof raw === 'object' ? raw : {};
            const enabled = parseBooleanLike(source.enabled);
            const dialogues = Array.isArray(source.dialogues) ? source.dialogues.map(dialog => {
                if (!dialog || typeof dialog !== 'object') return null;
                const trigger = (dialog.trigger ?? '').toString().trim();
                const tone = (dialog.tone ?? '').toString().trim();
                const line = (dialog.line ?? dialog.text ?? '').toString().trim();
                if (!trigger && !tone && !line) return null;
                const entry = {};
                if (trigger) entry.trigger = trigger;
                if (tone) entry.tone = tone;
                if (line) entry.line = line;
                return entry;
            }).filter(Boolean) : [];
            return { enabled, dialogues };
        }

        function sanitizeUiData(raw) {
            const pickLabel = (value) => {
                if (value === null || value === undefined) return '';
                return String(value);
            };
            const normalizeScreens = (screens) => {
                if (!Array.isArray(screens)) return [];
                return screens.map(screen => {
                    if (!screen || typeof screen !== 'object') return null;
                    const id = (screen.id ?? '').toString().trim();
                    const path = (screen.path ?? '').toString().trim();
                    const filename = (screen.filename ?? '').toString().trim();
                    if (!id && !path && !filename) return null;
                    const entry = {
                        id: id || `ui_${Math.random().toString(36).slice(2, 9)}`,
                        path,
                        filename
                    };
                    const label = pickLabel(screen.label);
                    if (label) entry.label = label;
                    const uploadedAt = (screen.uploadedAt ?? '').toString().trim();
                    if (uploadedAt) entry.uploadedAt = uploadedAt;
                    return entry;
                }).filter(Boolean);
            };
            if (Array.isArray(raw)) {
                return { screens: normalizeScreens(raw) };
            }
            const source = raw && typeof raw === 'object' ? raw : {};
            return { screens: normalizeScreens(source.screens || []) };
        }

        function sanitizeCreatureData(raw) {
            const dispositions = new Set(['friendly', 'neutral', 'hostile']);
            const base = {
                disposition: 'neutral',
                animations: [],
                skills: [],
                drops: []
            };
            if (!raw || typeof raw !== 'object') {
                return { ...base };
            }
            const entry = { ...base };
            const disposition = (raw.disposition ?? '').toString().trim().toLowerCase();
            entry.disposition = dispositions.has(disposition) ? disposition : 'neutral';

            const sanitizeAnimation = (anim) => {
                if (!anim || typeof anim !== 'object') return null;
                const id = (anim.id ?? '').toString().trim() || `anim_${uid()}`;
                const animalId = (anim.animalId ?? anim.animal ?? '').toString().trim();
                const clipName = (anim.clipName ?? anim.clip ?? '').toString().trim();
                let chance = Number(anim.chance ?? anim.triggerChance ?? 0);
                if (!Number.isFinite(chance)) chance = 0;
                chance = Math.max(0, Math.min(1, chance));
                const idle = parseBooleanLike(anim.idle ?? anim.isIdle ?? false);
                const label = (anim.label ?? anim.name ?? '').toString().trim();
                if (!animalId && !clipName) return null;
                const entry = { id, animalId, clipName, chance, idle };
                if (label) entry.label = label;
                return entry;
            };

            const sanitizeSkill = (skill) => {
                if (!skill || typeof skill !== 'object') return null;
                const id = (skill.id ?? '').toString().trim() || `skill_${uid()}`;
                const name = (skill.name ?? '').toString().trim();
                const description = (skill.description ?? skill.desc ?? '').toString().trim();
                const cooldown = (skill.cooldown ?? '').toString().trim();
                if (!name && !description && !cooldown) return null;
                const entry = { id };
                if (name) entry.name = name;
                if (description) entry.description = description;
                if (cooldown) entry.cooldown = cooldown;
                return entry;
            };

            const sanitizeDrop = (drop) => {
                if (!drop || typeof drop !== 'object') return null;
                let chance = Number(drop.chance ?? drop.triggerChance ?? 0);
                if (!Number.isFinite(chance)) chance = 0;
                chance = Math.max(0, Math.min(1, chance));
                let min = parseInt(drop.min ?? 1, 10);
                if (!Number.isFinite(min) || isNaN(min)) min = 1;
                if (min < 0) min = 0;
                let max = parseInt(drop.max ?? min, 10);
                if (!Number.isFinite(max) || isNaN(max) || max < min) max = min;
                const sourceType = (drop.sourceType ?? '').toString().trim().toLowerCase();
                const sourceId = (drop.sourceId ?? '').toString().trim().replace(/[^a-zA-Z0-9_\-]/g, '');
                const entry = { chance, min, max };
                if (sourceType) entry.sourceType = sourceType;
                if (sourceId) entry.sourceId = sourceId;
                return entry;
            };

            entry.animations = Array.isArray(raw.animations) ? raw.animations.map(sanitizeAnimation).filter(Boolean) : [];
            entry.skills = Array.isArray(raw.skills) ? raw.skills.map(sanitizeSkill).filter(Boolean) : [];
            entry.drops = Array.isArray(raw.drops) ? raw.drops.map(sanitizeDrop).filter(Boolean) : [];
            return entry;
        }

        function formatAiSummary(ai) {
            const data = sanitizeAiData(ai);
            if (!data.enabled) return '未啟用';
            const parts = ['啟用'];
            parts.push(`對話 ${data.dialogues.length} 則`);
            const preview = data.dialogues.find(d => d.line)?.line || data.dialogues[0]?.trigger || '';
            if (preview) {
                const short = preview.length > 12 ? `${preview.slice(0, 12)}…` : preview;
                parts.push(`範例：${short}`);
            }
            return parts.join('｜');
        }

        function formatCreatureSummary(creature, dropOptions) {
            const data = sanitizeCreatureData(creature);
            if (!data) return '—';
            const parts = [];
            const dispositionLabel = creatureDispositionLabels[data.disposition] || '中立';
            parts.push(`性格：${dispositionLabel}`);
            if (data.animations.length > 0) {
                const idleCount = data.animations.filter(anim => anim.idle).length;
                let text = `動畫 ${data.animations.length} 個`;
                if (idleCount > 0) {
                    text += `（閒置 ${idleCount}）`;
                }
                parts.push(text);
            }
            if (data.skills.length > 0) {
                parts.push(`技能 ${data.skills.length} 個`);
            }
            if (data.drops.length > 0) {
                parts.push(`掉落 ${data.drops.length} 組`);
            }
            return parts.join('｜') || '—';
        }

        function updateItemsState(items, categories) {
            if (Array.isArray(items)) {
                project.items = items.map(it => {
                    if (!it || typeof it !== 'object') return it;
                    const copy = { ...it };
                    const category = String(copy.categoryId || '');
                    const rawCreature = copy.creature;
                    if (category === 'animal') {
                        const legacyCreatureAi = rawCreature && typeof rawCreature === 'object' && !('disposition' in rawCreature) && (rawCreature.enabled !== undefined || Array.isArray(rawCreature.dialogues));
                        if (!copy.ai && legacyCreatureAi) {
                            copy.ai = sanitizeAiData(rawCreature);
                        } else {
                            copy.ai = sanitizeAiData(copy.ai);
                        }
                        copy.creature = sanitizeCreatureData(rawCreature);
                    } else {
                        if (copy.ai) {
                            copy.ai = sanitizeAiData(copy.ai);
                        }
                        if (copy.creature !== undefined) {
                            delete copy.creature;
                        }
                    }
                    copy.ui = sanitizeUiData(copy.ui);
                    return copy;
                });
            } else {
                project.items = [];
            }
            ensureItemCategories(categories);
            saveProject();
        }

        function renderItemCategoryOptions() {
            if (!iCategory) return;
            const current = iCategory.value;
            iCategory.innerHTML = '';
            ensureItemCategories(project.itemCategories);
            (project.itemCategories || []).forEach(cat => {
                const opt = document.createElement('option');
                opt.value = cat.id;
                opt.textContent = cat.label;
                iCategory.appendChild(opt);
            });
            if (current && Array.from(iCategory.options).some(opt => opt.value === current)) {
                iCategory.value = current;
            } else if (iCategory.options.length > 0 && !iCategory.value) {
                iCategory.value = iCategory.options[0].value;
            }
            const search = enableSelectSearch(iCategory, { placeholder: '搜尋分類…', emptyText: '沒有符合的分類' });
            search?.refresh();
            updateCreateAiVisibility();
        }

        const dropLabelFallback = {
            entity: '動畫生物',
            material: '素材',
            weapon: '武器',
            armor: '防具',
            decor: '裝飾',
            interactive: '可互動',
            building: '建材',
            resource: '素材',
            consumable: '消耗品',
            crop: '農作物',
            mineral: '礦物',
            tree: '樹木',
            animal: '生物'
        };

        const creatureDispositionLabels = {
            friendly: '友善',
            neutral: '中立',
            hostile: '敵對'
        };

        function getDropSourceOptions() {
            ensureItemCategories(project.itemCategories);
            const options = [];
            const seen = new Set();
            const add = (id, label) => {
                if (!id || seen.has(id)) return;
                seen.add(id);
                options.push({ id, label: label || dropLabelFallback[id] || id });
            };
            add('entity', dropLabelFallback.entity);
            (project.itemCategories || []).forEach(cat => {
                if (!cat || !cat.id || cat.id === 'drop') return;
                add(cat.id, cat.label || cat.name || dropLabelFallback[cat.id] || cat.id);
            });
            ['material', 'weapon', 'armor'].forEach(id => add(id, dropLabelFallback[id]));
            return options;
        }

        function formatDropSummary(drops, sourceOptions = getDropSourceOptions()) {
            if (!Array.isArray(drops) || drops.length === 0) return '—';
            const labelMap = new Map((sourceOptions || []).map(opt => [opt.id, opt.label]));
            return drops.map(d => {
                const chanceNum = Math.max(0, Math.min(1, Number(d?.chance ?? 0)));
                const chance = Math.round(chanceNum * 100);
                let min = parseInt(d?.min ?? 0, 10);
                if (!Number.isFinite(min) || isNaN(min) || min < 0) min = 0;
                let max = parseInt(d?.max ?? min, 10);
                if (!Number.isFinite(max) || isNaN(max) || max < min) max = min;
                const qty = min === max ? `${min}` : `${min}-${max}`;
                const type = (d?.sourceType ?? '').toString().trim();
                const label = type ? (labelMap.get(type) || dropLabelFallback[type] || type) : '';
                const sourceId = (d?.sourceId ?? '').toString().trim();
                const sourceText = type ? `${label}${sourceId ? `:${sourceId}` : ''}` : '';
                return `${chance}% × ${qty}${sourceText ? `（${sourceText}）` : ''}`;
            }).join('；');
        }

        function createDropEditor({ initialDrops = [], sourceOptions = [], addButtonLabel = '＋新增掉落規則', noteText = '機率 0–1；來源可為分類（不含掉落物）或實體 ID。', onChange } = {}) {
            let options = Array.isArray(sourceOptions) ? sourceOptions.map(opt => ({ ...opt })) : [];
            const container = document.createElement('div');
            container.className = 'drop-editor';
            const list = document.createElement('div');
            list.className = 'drop-list';
            const actions = document.createElement('div');
            actions.className = 'drop-actions';
            const addBtn = document.createElement('button');
            addBtn.type = 'button';
            addBtn.className = 'btn-add-drop';
            addBtn.textContent = addButtonLabel;
            const note = document.createElement('div');
            note.className = 'drop-note';
            note.textContent = noteText;
            actions.appendChild(addBtn);
            container.append(list, actions, note);

            const sanitize = (raw) => {
                const baseType = options.length > 0 ? options[0].id : 'entity';
                let chance = parseFloat(raw?.chance ?? 0);
                if (!Number.isFinite(chance)) chance = 0;
                chance = Math.max(0, Math.min(1, chance));
                let min = parseInt(raw?.min ?? 0, 10);
                if (!Number.isFinite(min) || isNaN(min) || min < 0) min = 0;
                let max = parseInt(raw?.max ?? min, 10);
                if (!Number.isFinite(max) || isNaN(max) || max < min) max = min;
                let sourceType = (raw?.sourceType ?? '').toString().trim();
                if (sourceType === '') sourceType = baseType;
                const sourceId = (raw?.sourceId ?? '').toString().trim();
                return { chance, min, max, sourceType, sourceId };
            };

            let drops = Array.isArray(initialDrops) ? initialDrops.map(sanitize) : [];
            const getDropsSnapshot = () => drops.map(sanitize);

            function buildOptionElements(select, value) {
                select.innerHTML = '';
                options.forEach(opt => {
                    const option = document.createElement('option');
                    option.value = opt.id;
                    option.textContent = opt.label;
                    select.appendChild(option);
                });
                if (value && !options.some(opt => opt.id === value)) {
                    const option = document.createElement('option');
                    option.value = value;
                    option.textContent = value;
                    select.appendChild(option);
                }
                select.value = value || (options[0]?.id ?? '');
            }

            function triggerChange() {
                if (typeof onChange === 'function') {
                    onChange(getDropsSnapshot());
                }
            }

            function render() {
                list.innerHTML = '';
                if (drops.length === 0) {
                    const empty = document.createElement('div');
                    empty.className = 'drop-empty';
                    empty.textContent = '尚未設定掉落規則';
                    list.appendChild(empty);
                    return;
                }
                drops.forEach((drop, idx) => {
                    const row = document.createElement('div');
                    row.className = 'drop-row';
                    row.dataset.idx = String(idx);

                    const chanceInput = document.createElement('input');
                    chanceInput.type = 'number';
                    chanceInput.step = '0.01';
                    chanceInput.min = '0';
                    chanceInput.max = '1';
                    chanceInput.value = String(drop.chance);

                    const minInput = document.createElement('input');
                    minInput.type = 'number';
                    minInput.step = '1';
                    minInput.min = '0';
                    minInput.value = String(drop.min);

                    const maxInput = document.createElement('input');
                    maxInput.type = 'number';
                    maxInput.step = '1';
                    maxInput.min = '0';
                    maxInput.value = String(drop.max);

                    const typeSelect = document.createElement('select');
                    buildOptionElements(typeSelect, drop.sourceType);

                    const idInput = document.createElement('input');
                    idInput.type = 'text';
                    idInput.placeholder = '來源 ID（例：forest_wolf / wheat）';
                    idInput.value = drop.sourceId;

                    const delBtn = document.createElement('button');
                    delBtn.type = 'button';
                    delBtn.textContent = '刪除';

                    chanceInput.addEventListener('change', () => {
                        const sanitized = sanitize({ ...drops[idx], chance: chanceInput.value });
                        drops[idx].chance = sanitized.chance;
                        chanceInput.value = String(drops[idx].chance);
                        triggerChange();
                    });

                    minInput.addEventListener('change', () => {
                        const sanitized = sanitize({ ...drops[idx], min: minInput.value });
                        drops[idx].min = sanitized.min;
                        if (drops[idx].max < drops[idx].min) {
                            drops[idx].max = drops[idx].min;
                            maxInput.value = String(drops[idx].max);
                        }
                        minInput.value = String(drops[idx].min);
                        triggerChange();
                    });

                    maxInput.addEventListener('change', () => {
                        const sanitized = sanitize({ ...drops[idx], max: maxInput.value });
                        drops[idx].max = sanitized.max < drops[idx].min ? drops[idx].min : sanitized.max;
                        maxInput.value = String(drops[idx].max);
                        triggerChange();
                    });

                    typeSelect.addEventListener('change', () => {
                        drops[idx].sourceType = typeSelect.value;
                        triggerChange();
                    });

                    idInput.addEventListener('input', () => {
                        drops[idx].sourceId = idInput.value;
                    });

                    idInput.addEventListener('blur', () => {
                        drops[idx].sourceId = idInput.value.trim();
                        triggerChange();
                    });

                    delBtn.addEventListener('click', () => {
                        drops.splice(idx, 1);
                        render();
                        triggerChange();
                    });

                    row.append(chanceInput, minInput, maxInput, typeSelect, idInput, delBtn);
                    list.appendChild(row);
                });
            }

            addBtn.addEventListener('click', () => {
                const defaultType = options[0]?.id ?? 'entity';
                drops.push(sanitize({ chance: 1, min: 1, max: 1, sourceType: defaultType, sourceId: '' }));
                render();
                triggerChange();
            });

            render();

            return {
                element: container,
                getDrops() {
                    return getDropsSnapshot();
                },
                setDrops(newDrops) {
                    drops = Array.isArray(newDrops) ? newDrops.map(sanitize) : [];
                    render();
                    triggerChange();
                },
                setSourceOptions(newOptions) {
                    options = Array.isArray(newOptions) ? newOptions.map(opt => ({ ...opt })) : [];
                    drops = drops.map(drop => sanitize(drop));
                    render();
                }
            };
        }

        function createUiGallery({ initialScreens = [], buttonLabel = '＋選擇圖片', noteText = '支援多張介面截圖，可描述互動提示或互動視窗。', onChange } = {}) {
            let existing = sanitizeUiData(initialScreens).screens.map(screen => ({ ...screen, label: screen.label || '' }));
            let removedIds = new Set();
            let newFiles = [];

            const container = document.createElement('div');
            container.className = 'ui-gallery';
            const list = document.createElement('div');
            list.className = 'ui-gallery-list';
            const actions = document.createElement('div');
            actions.className = 'ui-gallery-actions';
            const addBtn = document.createElement('button');
            addBtn.type = 'button';
            addBtn.className = 'btn-upload-ui';
            addBtn.textContent = buttonLabel;
            const note = document.createElement('div');
            note.className = 'ui-gallery-note';
            note.textContent = noteText;
            const fileInput = document.createElement('input');
            fileInput.type = 'file';
            fileInput.accept = 'image/*';
            fileInput.multiple = true;
            fileInput.style.display = 'none';

            actions.append(addBtn, note);
            container.append(list, actions, fileInput);

            const revokePreview = (entry) => {
                if (entry.previewUrl) {
                    URL.revokeObjectURL(entry.previewUrl);
                    entry.previewUrl = '';
                }
            };

            const getSnapshot = () => ({
                existing: existing.map(screen => ({ id: screen.id, label: screen.label || '' })),
                removed: Array.from(removedIds),
                newCount: newFiles.length,
                total: existing.length + newFiles.length
            });

            const notifyChange = () => {
                if (typeof onChange === 'function') {
                    onChange(getSnapshot());
                }
            };

            function render() {
                list.innerHTML = '';
                if (existing.length === 0 && newFiles.length === 0) {
                    const empty = document.createElement('div');
                    empty.className = 'ui-gallery-empty';
                    empty.textContent = '尚未加入 UI 圖片';
                    list.appendChild(empty);
                    return;
                }

                existing.forEach(screen => {
                    const item = document.createElement('div');
                    item.className = 'ui-thumb';

                    const img = document.createElement('img');
                    img.src = screen.path || screen.filename || '';
                    img.alt = screen.label || 'UI 圖片';

                    const labelInput = document.createElement('input');
                    labelInput.type = 'text';
                    labelInput.className = 'ui-thumb-label';
                    labelInput.placeholder = '顯示名稱';
                    labelInput.value = screen.label || '';
                    labelInput.addEventListener('input', () => {
                        screen.label = labelInput.value;
                    });
                    labelInput.addEventListener('change', () => {
                        screen.label = labelInput.value.trim();
                        labelInput.value = screen.label;
                        notifyChange();
                    });

                    const noteLine = document.createElement('div');
                    noteLine.className = 'ui-thumb-note';
                    noteLine.textContent = screen.uploadedAt ? `上傳：${new Date(screen.uploadedAt).toLocaleString()}` : '已儲存於物品中';

                    const actionsWrap = document.createElement('div');
                    actionsWrap.className = 'ui-thumb-actions';
                    const previewBtn = document.createElement('button');
                    previewBtn.type = 'button';
                    previewBtn.textContent = '預覽';
                    previewBtn.addEventListener('click', () => {
                        if (screen.path) window.open(screen.path, '_blank');
                    });
                    const removeBtn = document.createElement('button');
                    removeBtn.type = 'button';
                    removeBtn.className = 'danger';
                    removeBtn.textContent = '移除';
                    removeBtn.addEventListener('click', () => {
                        removedIds.add(screen.id);
                        existing = existing.filter(s => s.id !== screen.id);
                        render();
                        notifyChange();
                    });
                    actionsWrap.append(previewBtn, removeBtn);

                    item.append(img, labelInput, noteLine, actionsWrap);
                    list.appendChild(item);
                });

                newFiles.forEach(entry => {
                    const item = document.createElement('div');
                    item.className = 'ui-thumb';

                    const img = document.createElement('img');
                    img.src = entry.previewUrl;
                    img.alt = entry.file?.name || '暫存 UI 圖片';

                    const labelInput = document.createElement('input');
                    labelInput.type = 'text';
                    labelInput.className = 'ui-thumb-label';
                    labelInput.placeholder = '顯示名稱';
                    labelInput.value = entry.label;
                    labelInput.addEventListener('input', () => {
                        entry.label = labelInput.value;
                    });
                    labelInput.addEventListener('change', () => {
                        entry.label = labelInput.value.trim();
                        labelInput.value = entry.label;
                        notifyChange();
                    });

                    const noteLine = document.createElement('div');
                    noteLine.className = 'ui-thumb-note';
                    noteLine.textContent = '新增後記得儲存變更';

                    const actionsWrap = document.createElement('div');
                    actionsWrap.className = 'ui-thumb-actions';
                    const previewBtn = document.createElement('button');
                    previewBtn.type = 'button';
                    previewBtn.textContent = '預覽';
                    previewBtn.addEventListener('click', () => {
                        if (entry.previewUrl) window.open(entry.previewUrl, '_blank');
                    });
                    const removeBtn = document.createElement('button');
                    removeBtn.type = 'button';
                    removeBtn.className = 'danger';
                    removeBtn.textContent = '取消';
                    removeBtn.addEventListener('click', () => {
                        revokePreview(entry);
                        newFiles = newFiles.filter(f => f.id !== entry.id);
                        render();
                        notifyChange();
                    });
                    actionsWrap.append(previewBtn, removeBtn);

                    item.append(img, labelInput, noteLine, actionsWrap);
                    list.appendChild(item);
                });
            }

            function appendFiles(files) {
                const arr = Array.isArray(files) ? files : [];
                arr.forEach(file => {
                    if (!file || typeof file !== 'object') return;
                    if (file.error !== undefined && file.error !== 0) return;
                    const previewUrl = URL.createObjectURL(file);
                    const baseName = (file.name || '').replace(/\.[^.]+$/, '');
                    newFiles.push({ id: uid(), file, label: baseName || '', previewUrl });
                });
                render();
                notifyChange();
            }

            addBtn.addEventListener('click', () => fileInput.click());
            fileInput.addEventListener('change', () => {
                const files = Array.from(fileInput.files || []);
                appendFiles(files);
                fileInput.value = '';
            });

            render();
            notifyChange();

            return {
                element: container,
                setScreens(screens) {
                    existing = sanitizeUiData(screens).screens.map(screen => ({ ...screen, label: screen.label || '' }));
                    removedIds.clear();
                    newFiles.forEach(revokePreview);
                    newFiles = [];
                    render();
                    notifyChange();
                },
                getExistingMeta() {
                    return existing.map(screen => ({ id: screen.id, label: screen.label || '' }));
                },
                getRemovedIds() {
                    return Array.from(removedIds);
                },
                getNewFiles() {
                    return newFiles.map(entry => ({ file: entry.file, label: entry.label || '' }));
                },
                appendFiles(files) {
                    appendFiles(files);
                },
                reset() {
                    existing = [];
                    removedIds.clear();
                    newFiles.forEach(revokePreview);
                    newFiles = [];
                    render();
                    notifyChange();
                },
                getSnapshot,
                getDisplayCount() {
                    return existing.length + newFiles.length;
                }
            };
        }

        function createAiEditor({ initialValue = null, onChange } = {}) {
            const toInternal = (input) => {
                const sanitized = sanitizeAiData(input || {});
                return {
                    enabled: !!sanitized.enabled,
                    dialogues: sanitized.dialogues.map(dialog => ({ ...dialog, uid: uid() }))
                };
            };
            let value = toInternal(initialValue);

            const getValue = () => {
                const enabled = !!parseBooleanLike(value.enabled);
                const dialogues = value.dialogues.map(dialog => {
                    const trigger = (dialog.trigger ?? '').toString().trim();
                    const tone = (dialog.tone ?? '').toString().trim();
                    const line = (dialog.line ?? '').toString().trim();
                    if (!trigger && !tone && !line) return null;
                    const entry = {};
                    if (trigger) entry.trigger = trigger;
                    if (tone) entry.tone = tone;
                    if (line) entry.line = line;
                    return entry;
                }).filter(Boolean);
                return { enabled, dialogues };
            };

            const emitChange = () => {
                if (typeof onChange === 'function') {
                    onChange(getValue());
                }
            };

            const container = document.createElement('div');
            container.className = 'ai-editor';

            const toggleGroup = document.createElement('div');
            toggleGroup.className = 'ai-group';
            const toggleTitle = document.createElement('div');
            toggleTitle.className = 'ai-group-title';
            toggleTitle.textContent = '啟用狀態';
            const toggleWrap = document.createElement('div');
            toggleWrap.className = 'ai-toggle';
            const toggleCheckbox = document.createElement('input');
            toggleCheckbox.type = 'checkbox';
            toggleCheckbox.checked = !!value.enabled;
            const toggleLabel = document.createElement('span');
            toggleLabel.textContent = '此物品具備 AI 行為';
            toggleWrap.append(toggleCheckbox, toggleLabel);
            const toggleNote = document.createElement('div');
            toggleNote.className = 'ai-note';
            toggleNote.textContent = '開啟後可設定對話腳本與其他反應。';
            toggleGroup.append(toggleTitle, toggleWrap, toggleNote);
            container.appendChild(toggleGroup);

            const dialoguesGroup = document.createElement('div');
            dialoguesGroup.className = 'ai-group';
            const dialoguesTitle = document.createElement('div');
            dialoguesTitle.className = 'ai-group-title';
            dialoguesTitle.textContent = '對話腳本';
            const dialoguesNote = document.createElement('div');
            dialoguesNote.className = 'ai-note';
            dialoguesNote.textContent = '整理 AI 在不同情境下的台詞，提供觸發條件與語氣等補充資訊。';
            const dialogueList = document.createElement('div');
            dialogueList.className = 'ai-dialogue-list';
            const addBtn = document.createElement('button');
            addBtn.type = 'button';
            addBtn.className = 'btn secondary';
            addBtn.textContent = '＋新增對話';
            dialoguesGroup.append(dialoguesTitle, dialoguesNote, dialogueList, addBtn);
            container.appendChild(dialoguesGroup);

            function renderDialogues() {
                const disabled = !value.enabled;
                dialogueList.innerHTML = '';
                if (value.dialogues.length === 0) {
                    const empty = document.createElement('div');
                    empty.className = 'ai-empty';
                    empty.textContent = value.enabled ? '尚未新增對話。' : '尚未啟用 AI。勾選上方開關後可新增對話。';
                    dialogueList.appendChild(empty);
                }
                value.dialogues.forEach((dialog, idx) => {
                    if (!dialog.uid) dialog.uid = uid();
                    const row = document.createElement('div');
                    row.className = 'ai-dialogue-row';

                    const fields = document.createElement('div');
                    fields.className = 'ai-dialogue-fields';

                    const triggerWrap = document.createElement('div');
                    triggerWrap.className = 'ai-inline small';
                    const triggerLabel = document.createElement('div');
                    triggerLabel.className = 'ai-inline-label';
                    triggerLabel.textContent = '觸發條件';
                    const triggerInput = document.createElement('input');
                    triggerInput.type = 'text';
                    triggerInput.placeholder = '例：玩家互動、遭遇戰鬥';
                    triggerInput.value = dialog.trigger || '';
                    triggerInput.addEventListener('input', () => {
                        dialog.trigger = triggerInput.value;
                    });
                    triggerInput.addEventListener('change', () => {
                        dialog.trigger = triggerInput.value.trim();
                        triggerInput.value = dialog.trigger;
                        emitChange();
                    });
                    triggerWrap.append(triggerLabel, triggerInput);

                    const toneWrap = document.createElement('div');
                    toneWrap.className = 'ai-inline small';
                    const toneLabel = document.createElement('div');
                    toneLabel.className = 'ai-inline-label';
                    toneLabel.textContent = '語氣 / 情緒';
                    const toneInput = document.createElement('input');
                    toneInput.type = 'text';
                    toneInput.placeholder = '例：開心、緊張';
                    toneInput.value = dialog.tone || '';
                    toneInput.addEventListener('input', () => {
                        dialog.tone = toneInput.value;
                    });
                    toneInput.addEventListener('change', () => {
                        dialog.tone = toneInput.value.trim();
                        toneInput.value = dialog.tone;
                        emitChange();
                    });
                    toneWrap.append(toneLabel, toneInput);

                    const lineWrap = document.createElement('div');
                    lineWrap.className = 'ai-inline grow';
                    const lineLabel = document.createElement('div');
                    lineLabel.className = 'ai-inline-label';
                    lineLabel.textContent = '對話內容';
                    const lineInput = document.createElement('textarea');
                    lineInput.placeholder = '輸入 AI 要說的話或劇本描述…';
                    lineInput.value = dialog.line || '';
                    lineInput.addEventListener('input', () => {
                        dialog.line = lineInput.value;
                    });
                    lineInput.addEventListener('change', () => {
                        dialog.line = lineInput.value.trim();
                        lineInput.value = dialog.line;
                        emitChange();
                    });
                    lineWrap.append(lineLabel, lineInput);

                    fields.append(triggerWrap, toneWrap, lineWrap);
                    row.appendChild(fields);

                    const actions = document.createElement('div');
                    actions.className = 'ai-dialogue-actions';
                    const removeBtn = document.createElement('button');
                    removeBtn.type = 'button';
                    removeBtn.className = 'btn secondary';
                    removeBtn.textContent = '移除';
                    removeBtn.addEventListener('click', () => {
                        value.dialogues.splice(idx, 1);
                        renderDialogues();
                        emitChange();
                    });
                    actions.appendChild(removeBtn);
                    row.appendChild(actions);

                    [triggerInput, toneInput, lineInput, removeBtn].forEach(el => {
                        el.disabled = disabled;
                    });

                    dialogueList.appendChild(row);
                });
                addBtn.disabled = disabled;
            }

            addBtn.addEventListener('click', () => {
                if (!value.enabled) return;
                value.dialogues.push({ uid: uid(), trigger: '', tone: '', line: '' });
                renderDialogues();
                emitChange();
            });

            toggleCheckbox.addEventListener('change', () => {
                value.enabled = toggleCheckbox.checked;
                renderDialogues();
                emitChange();
            });

            renderDialogues();

            return {
                element: container,
                getValue,
                setValue(newValue) {
                    value = toInternal(newValue);
                    toggleCheckbox.checked = !!value.enabled;
                    renderDialogues();
                }
            };
        }

        function createCreatureEditor({ initialValue = null, dropOptions = [], animals = [], onChange } = {}) {
            let state = sanitizeCreatureData(initialValue);
            let animalOptions = [];
            let dropSourceOptions = Array.isArray(dropOptions) ? dropOptions.map(opt => ({ ...opt })) : [];
            let dropEditor = null;

            const mapAnimals = (list) => {
                if (!Array.isArray(list)) return [];
                return list.map(an => {
                    if (!an || typeof an !== 'object') return null;
                    const id = (an.id ?? '').toString().trim();
                    if (!id) return null;
                    const name = (an.name ?? id).toString();
                    const clips = Array.isArray(an.clips) ? an.clips.map(clip => {
                        if (!clip) return null;
                        if (typeof clip === 'string') return clip;
                        const clipName = (clip.name ?? clip.id ?? '').toString().trim();
                        return clipName || null;
                    }).filter(Boolean) : [];
                    return { id, name, clips };
                }).filter(Boolean);
            };

            const setAnimalOptions = (list) => {
                animalOptions = mapAnimals(list);
            };
            setAnimalOptions(animals);

            const findAnimal = (id) => animalOptions.find(an => an.id === id);
            const getClipsForAnimal = (id) => {
                const found = findAnimal(id);
                return Array.isArray(found?.clips) ? found.clips : [];
            };
            const hasAvailableAnimation = () => animalOptions.some(an => (an.clips || []).length > 0);

            const container = document.createElement('div');
            container.className = 'creature-editor';

            const getValue = () => {
                const snapshot = {
                    ...state,
                    drops: dropEditor ? dropEditor.getDrops() : (state.drops || [])
                };
                return sanitizeCreatureData(snapshot);
            };

            const notifyChange = () => {
                if (typeof onChange === 'function') {
                    onChange(getValue());
                }
            };

            const basicSection = document.createElement('div');
            basicSection.className = 'creature-section';
            const basicTitle = document.createElement('div');
            basicTitle.className = 'creature-section-title';
            basicTitle.textContent = '基本';
            basicSection.appendChild(basicTitle);
            const dispositionField = document.createElement('div');
            dispositionField.className = 'creature-inline small';
            const dispositionLabel = document.createElement('div');
            dispositionLabel.className = 'inline-label';
            dispositionLabel.textContent = '友善度';
            const dispositionSelect = document.createElement('select');
            [
                ['friendly', '友善'],
                ['neutral', '中立'],
                ['hostile', '敵對']
            ].forEach(([value, label]) => {
                const opt = document.createElement('option');
                opt.value = value;
                opt.textContent = label;
                dispositionSelect.appendChild(opt);
            });
            dispositionSelect.value = state.disposition;
            dispositionSelect.addEventListener('change', () => {
                state.disposition = dispositionSelect.value;
                notifyChange();
            });
            dispositionField.append(dispositionLabel, dispositionSelect);
            basicSection.appendChild(dispositionField);

            const animSection = document.createElement('div');
            animSection.className = 'creature-section';
            const animHead = document.createElement('div');
            animHead.className = 'creature-section-head';
            const animTitle = document.createElement('div');
            animTitle.className = 'creature-section-title';
            animTitle.textContent = '動畫';
            const addAnimBtn = document.createElement('button');
            addAnimBtn.type = 'button';
            addAnimBtn.className = 'btn secondary';
            addAnimBtn.textContent = '＋新增動畫';
            animHead.append(animTitle, addAnimBtn);
            animSection.appendChild(animHead);
            const animNote = document.createElement('div');
            animNote.className = 'creature-note';
            animNote.textContent = '引用「動物」分頁的 clip，並設定觸發機率與是否為閒置動作。';
            animSection.appendChild(animNote);
            const animationList = document.createElement('div');
            animationList.className = 'creature-animation-list';
            animSection.appendChild(animationList);

            const updateAddAnimationState = () => {
                const available = hasAvailableAnimation();
                addAnimBtn.disabled = !available;
                addAnimBtn.title = available ? '' : '請先在動物分頁新增動畫 clip';
            };

            const renderAnimations = () => {
                animationList.innerHTML = '';
                if (state.animations.length === 0) {
                    const empty = document.createElement('div');
                    empty.className = 'creature-empty';
                    empty.textContent = hasAvailableAnimation() ? '尚未設定動畫，可使用上方按鈕新增。' : '尚未建立可用的動物動畫。';
                    animationList.appendChild(empty);
                }
                state.animations.forEach((anim, idx) => {
                    if (!anim.id) anim.id = `anim_${uid()}`;
                    const row = document.createElement('div');
                    row.className = 'creature-animation-row';

                    const animalField = document.createElement('div');
                    animalField.className = 'creature-inline';
                    const animalLabel = document.createElement('div');
                    animalLabel.className = 'inline-label';
                    animalLabel.textContent = '動物';
                    const animalSelect = document.createElement('select');
                    const applyAnimalOptions = () => {
                        const current = anim.animalId || '';
                        animalSelect.innerHTML = '';
                        let hasCurrent = false;
                        if (current && !findAnimal(current)) {
                            const opt = document.createElement('option');
                            opt.value = current;
                            opt.textContent = `缺少動物：${current}`;
                            opt.dataset.searchSkip = '1';
                            animalSelect.appendChild(opt);
                            hasCurrent = true;
                        }
                        animalOptions.forEach(an => {
                            const opt = document.createElement('option');
                            opt.value = an.id;
                            opt.textContent = an.name;
                            animalSelect.appendChild(opt);
                            if (an.id === current) hasCurrent = true;
                        });
                        if (!hasCurrent) {
                            anim.animalId = animalOptions[0]?.id || current || '';
                        }
                        animalSelect.value = anim.animalId || '';
                    };
                    animalField.append(animalLabel, animalSelect);
                    applyAnimalOptions();
                    const animalSearch = enableSelectSearch(animalSelect, { placeholder: '選擇動物…', emptyText: '沒有符合的動物' });
                    animalSearch?.refresh();

                    const clipField = document.createElement('div');
                    clipField.className = 'creature-inline';
                    const clipLabel = document.createElement('div');
                    clipLabel.className = 'inline-label';
                    clipLabel.textContent = '動畫 clip';
                    const clipSelect = document.createElement('select');
                    const applyClipOptions = () => {
                        const clips = getClipsForAnimal(anim.animalId);
                        const current = anim.clipName || '';
                        clipSelect.innerHTML = '';
                        let hasCurrent = false;
                        if (current && !clips.includes(current)) {
                            const opt = document.createElement('option');
                            opt.value = current;
                            opt.textContent = `缺少動畫：${current}`;
                            opt.dataset.searchSkip = '1';
                            clipSelect.appendChild(opt);
                            hasCurrent = true;
                        }
                        clips.forEach(name => {
                            const opt = document.createElement('option');
                            opt.value = name;
                            opt.textContent = name;
                            clipSelect.appendChild(opt);
                            if (name === current) hasCurrent = true;
                        });
                        if (!hasCurrent) {
                            anim.clipName = clips[0] || current || '';
                        }
                        clipSelect.value = anim.clipName || '';
                    };
                    clipField.append(clipLabel, clipSelect);
                    applyClipOptions();
                    const clipSearch = enableSelectSearch(clipSelect, { placeholder: '選擇動畫…', emptyText: '沒有符合的動畫' });
                    clipSearch?.refresh();

                    animalSelect.addEventListener('change', () => {
                        anim.animalId = animalSelect.value;
                        applyClipOptions();
                        notifyChange();
                    });
                    clipSelect.addEventListener('change', () => {
                        anim.clipName = clipSelect.value;
                        notifyChange();
                    });

                    const chanceField = document.createElement('div');
                    chanceField.className = 'creature-inline small';
                    const chanceLabel = document.createElement('div');
                    chanceLabel.className = 'inline-label';
                    chanceLabel.textContent = '觸發機率 %';
                    const chanceInput = document.createElement('input');
                    chanceInput.type = 'number';
                    chanceInput.min = '0';
                    chanceInput.max = '100';
                    chanceInput.step = '1';
                    const chanceValue = Math.round(Math.max(0, Math.min(1, Number(anim.chance ?? 0))) * 100);
                    chanceInput.value = String(chanceValue);
                    chanceInput.addEventListener('change', () => {
                        let value = Number(chanceInput.value);
                        if (!Number.isFinite(value)) value = 0;
                        value = Math.max(0, Math.min(100, value));
                        chanceInput.value = String(value);
                        anim.chance = value / 100;
                        notifyChange();
                    });
                    chanceField.append(chanceLabel, chanceInput);

                    const idleField = document.createElement('div');
                    idleField.className = 'creature-inline tiny';
                    const idleLabel = document.createElement('div');
                    idleLabel.className = 'inline-label';
                    idleLabel.textContent = '閒置';
                    const idleToggle = document.createElement('label');
                    idleToggle.className = 'creature-toggle';
                    const idleCheckbox = document.createElement('input');
                    idleCheckbox.type = 'checkbox';
                    idleCheckbox.checked = !!anim.idle;
                    idleCheckbox.addEventListener('change', () => {
                        anim.idle = idleCheckbox.checked;
                        notifyChange();
                    });
                    idleToggle.append(idleCheckbox, document.createTextNode('閒置動畫'));
                    idleField.append(idleLabel, idleToggle);

                    const actions = document.createElement('div');
                    actions.className = 'creature-actions';
                    const removeBtn = document.createElement('button');
                    removeBtn.type = 'button';
                    removeBtn.className = 'btn secondary';
                    removeBtn.textContent = '移除';
                    removeBtn.addEventListener('click', () => {
                        state.animations.splice(idx, 1);
                        renderAnimations();
                        notifyChange();
                    });
                    actions.appendChild(removeBtn);

                    row.append(animalField, clipField, chanceField, idleField, actions);
                    animationList.appendChild(row);
                });
            };

            addAnimBtn.addEventListener('click', () => {
                if (!hasAvailableAnimation()) {
                    alert('請先在動物分頁建立至少一個帶有動畫 clip 的生物。');
                    return;
                }
                const preferred = animalOptions.find(an => (an.clips || []).length > 0) || animalOptions[0];
                const clipName = preferred?.clips?.[0] || '';
                state.animations.push({
                    id: `anim_${uid()}`,
                    animalId: preferred?.id || '',
                    clipName,
                    chance: 1,
                    idle: false
                });
                renderAnimations();
                notifyChange();
            });

            const skillSection = document.createElement('div');
            skillSection.className = 'creature-section';
            const skillHead = document.createElement('div');
            skillHead.className = 'creature-section-head';
            const skillTitle = document.createElement('div');
            skillTitle.className = 'creature-section-title';
            skillTitle.textContent = '技能';
            const addSkillBtn = document.createElement('button');
            addSkillBtn.type = 'button';
            addSkillBtn.className = 'btn secondary';
            addSkillBtn.textContent = '＋新增技能';
            skillHead.append(skillTitle, addSkillBtn);
            skillSection.appendChild(skillHead);
            const skillNote = document.createElement('div');
            skillNote.className = 'creature-note';
            skillNote.textContent = '記錄生物可使用的技能與描述，必要時補充冷卻或備註。';
            skillSection.appendChild(skillNote);
            const skillList = document.createElement('div');
            skillList.className = 'creature-skill-list';
            skillSection.appendChild(skillList);

            const renderSkills = () => {
                skillList.innerHTML = '';
                if (state.skills.length === 0) {
                    const empty = document.createElement('div');
                    empty.className = 'creature-empty';
                    empty.textContent = '尚未新增技能。';
                    skillList.appendChild(empty);
                }
                state.skills.forEach((skill, idx) => {
                    if (!skill.id) skill.id = `skill_${uid()}`;
                    const row = document.createElement('div');
                    row.className = 'creature-skill-row';

                    const nameField = document.createElement('div');
                    nameField.className = 'creature-inline';
                    const nameLabel = document.createElement('div');
                    nameLabel.className = 'inline-label';
                    nameLabel.textContent = '技能名稱';
                    const nameInput = document.createElement('input');
                    nameInput.type = 'text';
                    nameInput.placeholder = '例：火球 / 治療波';
                    nameInput.value = skill.name || '';
                    nameInput.addEventListener('input', () => {
                        skill.name = nameInput.value;
                    });
                    nameInput.addEventListener('change', () => {
                        skill.name = nameInput.value.trim();
                        nameInput.value = skill.name;
                        notifyChange();
                    });
                    nameField.append(nameLabel, nameInput);

                    const descField = document.createElement('div');
                    descField.className = 'creature-inline grow';
                    const descLabel = document.createElement('div');
                    descLabel.className = 'inline-label';
                    descLabel.textContent = '描述';
                    const descInput = document.createElement('textarea');
                    descInput.placeholder = '輸入技能效果、範圍或其他說明…';
                    descInput.value = skill.description || '';
                    descInput.addEventListener('input', () => {
                        skill.description = descInput.value;
                    });
                    descInput.addEventListener('change', () => {
                        skill.description = descInput.value.trim();
                        descInput.value = skill.description;
                        notifyChange();
                    });
                    descField.append(descLabel, descInput);

                    const cdField = document.createElement('div');
                    cdField.className = 'creature-inline small';
                    const cdLabel = document.createElement('div');
                    cdLabel.className = 'inline-label';
                    cdLabel.textContent = '冷卻 / 備註';
                    const cdInput = document.createElement('input');
                    cdInput.type = 'text';
                    cdInput.placeholder = '例：CD 8 秒';
                    cdInput.value = skill.cooldown || '';
                    cdInput.addEventListener('input', () => {
                        skill.cooldown = cdInput.value;
                    });
                    cdInput.addEventListener('change', () => {
                        skill.cooldown = cdInput.value.trim();
                        cdInput.value = skill.cooldown;
                        notifyChange();
                    });
                    cdField.append(cdLabel, cdInput);

                    const actions = document.createElement('div');
                    actions.className = 'creature-actions';
                    const removeBtn = document.createElement('button');
                    removeBtn.type = 'button';
                    removeBtn.className = 'btn secondary';
                    removeBtn.textContent = '移除';
                    removeBtn.addEventListener('click', () => {
                        state.skills.splice(idx, 1);
                        renderSkills();
                        notifyChange();
                    });
                    actions.appendChild(removeBtn);

                    row.append(nameField, descField, cdField, actions);
                    skillList.appendChild(row);
                });
            };

            addSkillBtn.addEventListener('click', () => {
                state.skills.push({ id: `skill_${uid()}`, name: '', description: '', cooldown: '' });
                renderSkills();
                notifyChange();
            });

            const dropSection = document.createElement('div');
            dropSection.className = 'creature-section';
            const dropHead = document.createElement('div');
            dropHead.className = 'creature-section-head';
            const dropTitle = document.createElement('div');
            dropTitle.className = 'creature-section-title';
            dropTitle.textContent = '掉落物';
            dropHead.appendChild(dropTitle);
            dropSection.appendChild(dropHead);
            const dropNote = document.createElement('div');
            dropNote.className = 'creature-note';
            dropNote.textContent = '設定此生物被擊敗後的專屬掉落。';
            dropSection.appendChild(dropNote);
            const dropHost = document.createElement('div');
            dropEditor = createDropEditor({
                initialDrops: state.drops,
                sourceOptions: dropSourceOptions,
                addButtonLabel: '＋新增掉落',
                noteText: '機率 0–1；可引用分類或特定實體。',
                onChange: drops => {
                    state.drops = drops;
                    notifyChange();
                }
            });
            dropHost.appendChild(dropEditor.element);
            dropSection.appendChild(dropHost);

            container.append(basicSection, animSection, skillSection, dropSection);

            const setValue = (input) => {
                state = sanitizeCreatureData(input);
                dispositionSelect.value = state.disposition;
                renderAnimations();
                renderSkills();
                updateAddAnimationState();
                dropEditor?.setDrops(state.drops);
            };

            setValue(initialValue);
            updateAddAnimationState();

            return {
                element: container,
                getValue,
                setValue(value) {
                    setValue(value);
                    notifyChange();
                },
                setAnimals(newAnimals) {
                    const before = JSON.stringify(getValue());
                    setAnimalOptions(newAnimals);
                    renderAnimations();
                    updateAddAnimationState();
                    const after = JSON.stringify(getValue());
                    if (before !== after) notifyChange();
                },
                setDropOptions(newOptions) {
                    dropSourceOptions = Array.isArray(newOptions) ? newOptions.map(opt => ({ ...opt })) : [];
                    dropEditor?.setSourceOptions(dropSourceOptions);
                },
                reset() {
                    setValue(null);
                    notifyChange();
                }
            };
        }
        const iDropContainer = document.getElementById('iDropEditor');
        const createItemDropEditor = iDropContainer ? createDropEditor({ initialDrops: [], sourceOptions: getDropSourceOptions() }) : null;
        if (createItemDropEditor && iDropContainer) {
            iDropContainer.appendChild(createItemDropEditor.element);
        }

        const iUiFields = document.getElementById('iUiFields');
        const iUiHost = document.getElementById('iUiGallery');
        const createItemUiGallery = iUiHost ? createUiGallery({ initialScreens: [] }) : null;
        if (createItemUiGallery && iUiHost) {
            iUiHost.innerHTML = '';
            iUiHost.appendChild(createItemUiGallery.element);
        }

        const iCreatureFields = document.getElementById('iCreatureFields');
        const iCreatureHost = document.getElementById('iCreatureEditorHost');
        const createItemCreatureEditor = iCreatureHost ? createCreatureEditor({ dropOptions: getDropSourceOptions(), animals: project.animals }) : null;
        if (createItemCreatureEditor && iCreatureHost) {
            iCreatureHost.appendChild(createItemCreatureEditor.element);
        }

        const iAiFields = document.getElementById('iAiFields');
        const iAiHost = document.getElementById('iAiEditorHost');
        const createItemAiEditor = iAiHost ? createAiEditor() : null;
        if (createItemAiEditor && iAiHost) {
            iAiHost.appendChild(createItemAiEditor.element);
        }

        function updateCreateAiVisibility() {
            if (!iAiFields) return;
            const isAnimal = (iCategory?.value || '') === 'animal';
            iAiFields.style.display = isAnimal ? '' : 'none';
        }

        function updateCreateCreatureVisibility() {
            if (!iCreatureFields) return;
            const isAnimal = (iCategory?.value || '') === 'animal';
            iCreatureFields.style.display = isAnimal ? '' : 'none';
        }

        function updateCreateUiVisibility() {
            if (!iUiFields) return;
            const isInteractive = (iCategory?.value || '') === 'interactive';
            iUiFields.style.display = isInteractive ? '' : 'none';
        }

        if (iCategory) {
            iCategory.addEventListener('change', () => {
                updateCreateAiVisibility();
                updateCreateCreatureVisibility();
                updateCreateUiVisibility();
            });
            updateCreateAiVisibility();
            updateCreateCreatureVisibility();
            updateCreateUiVisibility();
        }

        addItem.onclick = async () => {
            const name = iName.value.trim();
            if (!name) return alert('請輸入名稱');
            const categoryId = iCategory.value || (project.itemCategories?.[0]?.id ?? 'decor');
            const terrains = Array.from(document.querySelectorAll('#iTerrainChecks input[type=checkbox]:checked')).map(x => x.dataset.tid);
            const notes = iNote.value.trim();

            const originalText = addItem.textContent;
            addItem.disabled = true;
            addItem.textContent = '儲存中...';

            const formData = new FormData();
            formData.append('action', 'create');
            formData.append('name', name);
            formData.append('categoryId', categoryId);
            formData.append('notes', notes);
            formData.append('terrains', JSON.stringify(terrains));
            if (createItemDropEditor) {
                formData.append('drops', JSON.stringify(createItemDropEditor.getDrops()));
            } else {
                formData.append('drops', '[]');
            }
            if (createItemAiEditor) {
                if (categoryId === 'animal') {
                    formData.append('ai', JSON.stringify(createItemAiEditor.getValue()));
                } else {
                    formData.append('ai', 'null');
                }
            }
            if (createItemCreatureEditor) {
                if (categoryId === 'animal') {
                    formData.append('creature', JSON.stringify(createItemCreatureEditor.getValue()));
                } else {
                    formData.append('creature', 'null');
                }
            }
            if (createItemUiGallery) {
                if (categoryId === 'interactive') {
                    const uiMeta = createItemUiGallery.getExistingMeta();
                    if (uiMeta.length > 0) {
                        formData.append('uiScreens', JSON.stringify(uiMeta));
                    }
                    const newFiles = createItemUiGallery.getNewFiles();
                    newFiles.forEach(entry => {
                        if (entry.file) {
                            formData.append('uiImages[]', entry.file);
                            formData.append('uiImageLabels[]', entry.label || '');
                        }
                    });
                } else {
                    formData.append('clearUi', '1');
                }
            }
            if (iIcon.files && iIcon.files[0]) {
                formData.append('image', iIcon.files[0]);
            }

            try {
                const res = await fetch(itemApiUrl, { method: 'POST', body: formData });

                // 先讀文字（500 可能不是 JSON）
                const raw = await res.text();

                if (!res.ok) {
                    throw new Error(`HTTP ${res.status}${raw ? ' | ' + raw : ''}`);
                }

                // 是 2xx 才 parse JSON
                let data;
                try { data = JSON.parse(raw); }
                catch { throw new Error('後端不是有效的 JSON：' + raw.slice(0, 180)); }

                if (data.status !== 'ok') {
                    throw new Error(data.message || '新增物品失敗');
                }

                pendingOpenItemId = data.item?.id || null;
                pendingOpenCategoryId = data.item?.categoryId || null;
                updateItemsState(data.items, data.categories);

                iName.value = '';
                iNote.value = '';
                iIcon.value = '';
                if (createItemDropEditor) {
                    createItemDropEditor.setDrops([]);
                }
                if (createItemAiEditor) {
                    createItemAiEditor.setValue(null);
                }
                if (createItemCreatureEditor) {
                    createItemCreatureEditor.reset();
                }
                if (createItemUiGallery) {
                    createItemUiGallery.reset();
                }
                updateCreateAiVisibility();
                updateCreateCreatureVisibility();
                updateCreateUiVisibility();
                populateTerrainChecklist(document.getElementById('iTerrainChecks'), []);
            } catch (err) {
                console.error('Failed to create item', err);
                alert('新增物品失敗：' + (err.message || '發生未知錯誤'));
            } finally {
                addItem.disabled = false;
                addItem.textContent = originalText;
            }

        };

        function createCategorySelect(selectedId) {
            const select = document.createElement('select');
            ensureItemCategories(project.itemCategories);
            (project.itemCategories || []).forEach(cat => {
                const opt = document.createElement('option');
                opt.value = cat.id;
                opt.textContent = cat.label;
                if (cat.id === selectedId) opt.selected = true;
                select.appendChild(opt);
            });
            return select;
        }

        function buildItemCard(item, openItems, dropOptions) {
            const terrainsLookup = new Map((project.terrains || []).map(t => [t.id, t.name]));
            const terrainNames = (item.terrains || []).map(id => terrainsLookup.get(id) || id);
            let aiEditor = null;
            let creatureEditor = null;
            let uiGallery = null;

            const card = document.createElement('details');
            card.className = 'item-card';
            card.dataset.itemId = item.id;
            if (openItems.has(item.id)) card.open = true;

            const summary = document.createElement('summary');
            const terrainText = terrainNames.length > 0 ? terrainNames.join(', ') : '-';
            const titleSpan = document.createElement('span');
            titleSpan.textContent = item.name;
            const meta = document.createElement('div');
            meta.className = 'meta';
            const idSpan = document.createElement('span');
            idSpan.textContent = `ID: ${item.id}`;
            const terrainSpan = document.createElement('span');
            terrainSpan.textContent = `地形：${terrainText}`;
            const dropMeta = document.createElement('span');
            dropMeta.className = 'item-drop-meta';
            dropMeta.textContent = `掉落：${formatDropSummary(item.drops, dropOptions)}`;
            const uiMeta = document.createElement('span');
            uiMeta.className = 'item-ui-meta';
            uiMeta.style.display = 'none';
            const creatureMeta = document.createElement('span');
            creatureMeta.className = 'item-creature-meta';
            creatureMeta.style.display = 'none';
            const aiMeta = document.createElement('span');
            aiMeta.className = 'item-ai-meta';
            aiMeta.style.display = 'none';
            meta.append(idSpan, terrainSpan, dropMeta, uiMeta, creatureMeta, aiMeta);
            summary.append(titleSpan, meta);
            card.appendChild(summary);

            const body = document.createElement('div');
            body.className = 'item-body';

            const form = document.createElement('div');
            form.className = 'item-form';

            const nameRow = document.createElement('div'); nameRow.className = 'row';
            const nameLabel = document.createElement('label'); nameLabel.textContent = '名稱';
            const nameInput = document.createElement('input'); nameInput.type = 'text'; nameInput.value = item.name;
            nameRow.appendChild(nameLabel); nameRow.appendChild(nameInput);

            const catRow = document.createElement('div'); catRow.className = 'row';
            const catLabel = document.createElement('label'); catLabel.textContent = '分類';
            const catSelect = createCategorySelect(item.categoryId);
            catRow.appendChild(catLabel); catRow.appendChild(catSelect);
            const catSearch = enableSelectSearch(catSelect, { placeholder: '搜尋分類…', emptyText: '沒有符合的分類' });
            catSearch?.refresh();

            const applyUiMeta = (count) => {
                if (!uiMeta) return;
                const isInteractive = catSelect.value === 'interactive';
                if (isInteractive) {
                    uiMeta.style.display = '';
                    uiMeta.textContent = `UI 圖片：${count > 0 ? `${count} 張` : '—'}`;
                } else {
                    uiMeta.style.display = 'none';
                }
            };

            const updateCreatureMeta = () => {
                if (!creatureMeta) return;
                if (catSelect.value === 'animal') {
                    const data = creatureEditor ? creatureEditor.getValue() : item.creature;
                    creatureMeta.style.display = '';
                    creatureMeta.textContent = `生物：${formatCreatureSummary(data, dropOptions)}`;
                } else {
                    creatureMeta.style.display = 'none';
                }
            };

            const updateAiMeta = () => {
                if (!aiMeta) return;
                if (catSelect.value === 'animal') {
                    const data = aiEditor ? aiEditor.getValue() : item.ai;
                    aiMeta.style.display = '';
                    aiMeta.textContent = `AI：${formatAiSummary(data)}`;
                } else {
                    aiMeta.style.display = 'none';
                }
            };

            const notesRow = document.createElement('div'); notesRow.className = 'row';
            const notesLabel = document.createElement('label'); notesLabel.textContent = '備註';
            const notesField = document.createElement('textarea'); notesField.value = item.notes || '';
            notesRow.appendChild(notesLabel); notesRow.appendChild(notesField);

            const dropRow = document.createElement('div'); dropRow.className = 'row item-drop-row';
            const dropLabel = document.createElement('label'); dropLabel.textContent = '掉落設定';
            const dropWrap = document.createElement('div'); dropWrap.className = 'drop-editor-wrap';
            const dropEditor = createDropEditor({
                initialDrops: Array.isArray(item.drops) ? item.drops : [],
                sourceOptions: dropOptions,
                noteText: '調整後記得按「儲存變更」。',
                onChange: drops => { dropMeta.textContent = `掉落：${formatDropSummary(drops, dropOptions)}`; }
            });
            dropWrap.appendChild(dropEditor.element);
            dropRow.appendChild(dropLabel);
            dropRow.appendChild(dropWrap);

            const uiRow = document.createElement('div');
            uiRow.className = 'row item-ui-row';
            const uiLabel = document.createElement('label');
            uiLabel.textContent = 'UI 圖片';
            const uiHost = document.createElement('div');
            uiHost.className = 'ui-gallery-host';
            uiGallery = createUiGallery({
                initialScreens: sanitizeUiData(item.ui).screens,
                onChange: snapshot => applyUiMeta(snapshot.total)
            });
            uiHost.appendChild(uiGallery.element);
            uiRow.append(uiLabel, uiHost);

            const creatureRow = document.createElement('div');
            creatureRow.className = 'row creature-row';
            const creatureLabel = document.createElement('label');
            creatureLabel.textContent = '生物設定';
            const creatureHost = document.createElement('div');
            creatureHost.className = 'creature-editor-host';
            creatureRow.append(creatureLabel, creatureHost);
            creatureEditor = createCreatureEditor({
                initialValue: item.creature,
                dropOptions,
                animals: project.animals,
                onChange: updateCreatureMeta
            });
            creatureHost.appendChild(creatureEditor.element);

            const aiRow = document.createElement('div'); aiRow.className = 'row ai-row';
            const aiLabel = document.createElement('label'); aiLabel.textContent = 'AI 設定';
            const aiHost = document.createElement('div'); aiHost.className = 'ai-editor-host';
            aiRow.appendChild(aiLabel); aiRow.appendChild(aiHost);
            aiEditor = createAiEditor({
                initialValue: item.ai,
                onChange: updateAiMeta
            });
            aiHost.appendChild(aiEditor.element);

            const handleCategoryToggle = () => {
                const isAnimal = catSelect.value === 'animal';
                const isInteractive = catSelect.value === 'interactive';
                aiRow.style.display = isAnimal ? '' : 'none';
                creatureRow.style.display = isAnimal ? '' : 'none';
                uiRow.style.display = isInteractive ? '' : 'none';
                updateAiMeta();
                updateCreatureMeta();
                applyUiMeta(isInteractive ? (uiGallery?.getDisplayCount?.() ?? 0) : 0);
            };
            catSelect.addEventListener('change', handleCategoryToggle);
            handleCategoryToggle();

            const terrainRow = document.createElement('div'); terrainRow.className = 'row';
            const terrainLabel = document.createElement('label'); terrainLabel.textContent = '適用地形';
            const terrainWrap = document.createElement('div'); terrainWrap.className = 'checklist';
            populateTerrainChecklist(terrainWrap, item.terrains || []);
            terrainRow.appendChild(terrainLabel); terrainRow.appendChild(terrainWrap);

            const actionsRow = document.createElement('div'); actionsRow.className = 'item-actions';
            const saveBtn = document.createElement('button'); saveBtn.className = 'btn'; saveBtn.textContent = '儲存變更';
            const uploadBtn = document.createElement('button'); uploadBtn.className = 'btn secondary'; uploadBtn.textContent = '替換圖片';
            const removeImageBtn = document.createElement('button'); removeImageBtn.className = 'btn secondary'; removeImageBtn.textContent = '移除圖片';
            const deleteBtn = document.createElement('button'); deleteBtn.className = 'btn danger'; deleteBtn.textContent = '刪除此物品';
            actionsRow.append(saveBtn, uploadBtn, removeImageBtn, deleteBtn);

            form.append(nameRow, catRow, notesRow, dropRow, uiRow, creatureRow, aiRow, terrainRow, actionsRow);
            body.appendChild(form);

            const imageSection = document.createElement('div');
            if (item.image) {
                imageSection.className = 'item-image-preview';
                const img = document.createElement('img');
                img.src = item.image.path;
                img.alt = item.name + ' 圖片';
                imageSection.appendChild(img);

                const metaWrap = document.createElement('div'); metaWrap.className = 'item-image-meta';
                const labelInput = document.createElement('input');
                labelInput.type = 'text';
                labelInput.value = item.image.label || item.name;
                labelInput.placeholder = '圖片顯示名稱';

                const toggle = document.createElement('label'); toggle.className = 'terrain-image-toggle';
                const renameCheckbox = document.createElement('input'); renameCheckbox.type = 'checkbox';
                toggle.appendChild(renameCheckbox);
                toggle.append(' 同步修改檔案名稱');

                const meta = document.createElement('div'); meta.className = 'small';
                const uploadedAt = item.image.uploadedAt ? new Date(item.image.uploadedAt).toLocaleString() : '';
                meta.textContent = `檔案：${item.image.filename}${uploadedAt ? `｜上傳：${uploadedAt}` : ''}`;

                const renameBtn = document.createElement('button'); renameBtn.className = 'btn secondary'; renameBtn.textContent = '更新圖片名稱';

                metaWrap.append(labelInput, toggle, meta, renameBtn);
                imageSection.appendChild(metaWrap);

                renameBtn.onclick = async (e) => {
                    e.preventDefault();
                    const label = labelInput.value.trim();
                    if (label === '') return alert('名稱不可為空');
                    const original = renameBtn.textContent;
                    renameBtn.disabled = true;
                    renameBtn.textContent = '更新中...';
                    const formData = new FormData();
                    formData.append('action', 'update');
                    formData.append('id', item.id);
                    formData.append('imageMeta', JSON.stringify({ label, renameFile: renameCheckbox.checked }));
                    try {
                        const res = await fetch(itemApiUrl, { method: 'POST', body: formData });
                        const data = await res.json();
                        if (!res.ok || data.status !== 'ok') throw new Error(data.message || '更新失敗');
                        updateItemsState(data.items, data.categories);
                    } catch (err) {
                        console.error('Failed to rename item image', err);
                        alert('更新圖片名稱失敗：' + (err.message || '未知錯誤'));
                    } finally {
                        renameBtn.disabled = false;
                        renameBtn.textContent = original;
                    }
                };
            } else {
                imageSection.className = 'terrain-empty';
                imageSection.textContent = '尚未上傳圖片';
            }
            body.appendChild(imageSection);

            card.appendChild(body);

            saveBtn.onclick = async (e) => {
                e.preventDefault();
                const newName = nameInput.value.trim();
                if (newName === '') return alert('物品名稱不可為空');
                const terrainsSelected = Array.from(terrainWrap.querySelectorAll('input[type=checkbox]:checked')).map(x => x.dataset.tid);
                const original = saveBtn.textContent;
                saveBtn.disabled = true;
                saveBtn.textContent = '儲存中...';
                const formData = new FormData();
                formData.append('action', 'update');
                formData.append('id', item.id);
                formData.append('name', newName);
                formData.append('categoryId', catSelect.value);
                formData.append('notes', notesField.value.trim());
                formData.append('terrains', JSON.stringify(terrainsSelected));
                formData.append('drops', JSON.stringify(dropEditor.getDrops()));
                if (uiGallery) {
                    if (catSelect.value === 'interactive') {
                        formData.append('uiScreens', JSON.stringify(uiGallery.getExistingMeta()));
                        uiGallery.getRemovedIds().forEach(id => formData.append('removeUiScreens[]', id));
                        uiGallery.getNewFiles().forEach(entry => {
                            if (entry.file) {
                                formData.append('uiImages[]', entry.file);
                                formData.append('uiImageLabels[]', entry.label || '');
                            }
                        });
                    } else {
                        formData.append('clearUi', '1');
                    }
                }
                if (aiEditor) {
                    if (catSelect.value === 'animal') {
                        formData.append('ai', JSON.stringify(aiEditor.getValue()));
                    } else {
                        formData.append('ai', 'null');
                    }
                }
                if (creatureEditor) {
                    if (catSelect.value === 'animal') {
                        formData.append('creature', JSON.stringify(creatureEditor.getValue()));
                    } else {
                        formData.append('creature', 'null');
                    }
                }
                try {
                    const res = await fetch(itemApiUrl, { method: 'POST', body: formData });
                    const data = await res.json();
                    if (!res.ok || data.status !== 'ok') throw new Error(data.message || '儲存失敗');
                    updateItemsState(data.items, data.categories);
                } catch (err) {
                    console.error('Failed to update item', err);
                    alert('更新物品失敗：' + (err.message || '未知錯誤'));
                } finally {
                    saveBtn.disabled = false;
                    saveBtn.textContent = original;
                }
            };

            uploadBtn.onclick = () => {
                const input = document.createElement('input');
                input.type = 'file';
                input.accept = 'image/*';
                input.onchange = async () => {
                    if (!input.files || !input.files[0]) return;
                    const original = uploadBtn.textContent;
                    uploadBtn.disabled = true;
                    uploadBtn.textContent = '上傳中...';
                    const formData = new FormData();
                    formData.append('action', 'update');
                    formData.append('id', item.id);
                    formData.append('image', input.files[0]);
                    try {
                        const res = await fetch(itemApiUrl, { method: 'POST', body: formData });
                        const data = await res.json();
                        if (!res.ok || data.status !== 'ok') throw new Error(data.message || '上傳失敗');
                        updateItemsState(data.items, data.categories);
                    } catch (err) {
                        console.error('Failed to upload item image', err);
                        alert('上傳圖片失敗：' + (err.message || '未知錯誤'));
                    } finally {
                        uploadBtn.disabled = false;
                        uploadBtn.textContent = original;
                        input.value = '';
                    }
                };
                input.click();
            };

            removeImageBtn.disabled = !item.image;
            removeImageBtn.onclick = async (e) => {
                e.preventDefault();
                if (!item.image) return;
                if (!confirm('確定移除圖片？')) return;
                const original = removeImageBtn.textContent;
                removeImageBtn.disabled = true;
                removeImageBtn.textContent = '處理中...';
                const formData = new FormData();
                formData.append('action', 'update');
                formData.append('id', item.id);
                formData.append('removeImage', 'true');
                try {
                    const res = await fetch(itemApiUrl, { method: 'POST', body: formData });
                    const data = await res.json();
                    if (!res.ok || data.status !== 'ok') throw new Error(data.message || '移除失敗');
                    updateItemsState(data.items, data.categories);
                } catch (err) {
                    console.error('Failed to remove item image', err);
                    alert('移除圖片失敗：' + (err.message || '未知錯誤'));
                } finally {
                    removeImageBtn.disabled = false;
                    removeImageBtn.textContent = original;
                }
            };

            deleteBtn.onclick = async (e) => {
                e.preventDefault();
                if (!confirm('刪除此物品？相關的圖片與資料將被移除。')) return;
                const original = deleteBtn.textContent;
                deleteBtn.disabled = true;
                deleteBtn.textContent = '刪除中...';
                const formData = new FormData();
                formData.append('action', 'delete');
                formData.append('id', item.id);
                try {
                    const res = await fetch(itemApiUrl, { method: 'POST', body: formData });
                    const data = await res.json();
                    if (!res.ok || data.status !== 'ok') throw new Error(data.message || '刪除失敗');
                    updateItemsState(data.items, data.categories);
                } catch (err) {
                    console.error('Failed to delete item', err);
                    alert('刪除物品失敗：' + (err.message || '未知錯誤'));
                } finally {
                    deleteBtn.disabled = false;
                    deleteBtn.textContent = original;
                }
            };

            return card;
        }

        function renderItems() {
            if (!itemList) return;
            renderItemCategoryOptions();
            const dropOptions = getDropSourceOptions();
            if (createItemDropEditor) createItemDropEditor.setSourceOptions(dropOptions);
            if (createItemCreatureEditor) {
                createItemCreatureEditor.setDropOptions(dropOptions);
                createItemCreatureEditor.setAnimals(project.animals);
            }
            const openGroups = new Set(Array.from(itemList.querySelectorAll('.item-group[open]')).map(el => el.dataset.catId));
            const openItems = new Set(Array.from(itemList.querySelectorAll('.item-card[open]')).map(el => el.dataset.itemId));

            if (pendingOpenCategoryId) openGroups.add(pendingOpenCategoryId);
            if (pendingOpenItemId) openItems.add(pendingOpenItemId);

            itemList.innerHTML = '';

            ensureItemCategories(project.itemCategories);
            const categories = (project.itemCategories || []).slice();
            const map = new Map(categories.map(cat => [cat.id, []]));
            const uncategorized = [];

            (project.items || []).forEach(item => {
                if (map.has(item.categoryId)) {
                    map.get(item.categoryId).push(item);
                } else {
                    uncategorized.push(item);
                }
            });

            const buildGroup = (catId, label, items) => {
                const group = document.createElement('details');
                group.className = 'item-group';
                group.dataset.catId = catId;
                if (openGroups.has(catId)) group.open = true;

                const summary = document.createElement('summary');
                summary.className = 'item-summary';
                summary.innerHTML = `<span>${label}</span><div class="meta"><span>${items.length} 件</span></div>`;
                group.appendChild(summary);

                const entries = document.createElement('div'); entries.className = 'item-entries';
                if (items.length === 0) {
                    const empty = document.createElement('div');
                    empty.className = 'terrain-empty';
                    empty.textContent = '尚未新增物品';
                    entries.appendChild(empty);
                } else {
                    const sorted = items.slice().sort((a, b) => (a.name || '').localeCompare(b.name || '', 'zh-Hant'));
                    sorted.forEach(it => entries.appendChild(buildItemCard(it, openItems, dropOptions)));
                }
                group.appendChild(entries);
                itemList.appendChild(group);
            };

            categories.forEach(cat => buildGroup(cat.id, cat.label, map.get(cat.id) || []));
            if (uncategorized.length > 0) {
                buildGroup('uncategorized', '未分類', uncategorized);
            }

            if (openGroups.size === 0 && itemList.firstElementChild instanceof HTMLElement) {
                const firstDetails = itemList.firstElementChild;
                if ('open' in firstDetails) firstDetails.open = true;
            }

            pendingOpenItemId = null;
            pendingOpenCategoryId = null;
        }

        // ----------------------------- Animals & Clips -----------------------------
        const aName = document.getElementById('aName');
        const aPreview = document.getElementById('aPreview');
        const clipName = document.getElementById('clipName');
        const clipFps = document.getElementById('clipFps');
        const clipFrames = document.getElementById('clipFrames');
        const clipFrameList = document.getElementById('clipFrameList');
        const addClip = document.getElementById('addClip');
        const addAnimal = document.getElementById('addAnimal');
        const animalList = document.getElementById('animalList');
        const previewAnimal = document.getElementById('previewAnimal');
        const previewClip = document.getElementById('previewClip');
        const previewSpeed = document.getElementById('previewSpeed');

        let tempClips = [];
        let selectedClipFrames = [];

        function normalizeClipFrames(clip) {
            if (!clip || typeof clip !== 'object') return [];
            if (!Array.isArray(clip.frames)) clip.frames = [];
            const fps = Math.max(1, Number(clip.fps || 6));
            const fallbackDuration = 1 / fps;
            clip.frames = clip.frames.map(frame => {
                if (typeof frame === 'string') {
                    return { src: frame, duration: fallbackDuration };
                }
                if (frame && typeof frame === 'object') {
                    const src = frame.src || frame.dataUrl || frame.image || '';
                    if (!src) return null;
                    const duration = Math.max(0.01, Number(frame.duration) || fallbackDuration);
                    return { src, duration };
                }
                return null;
            }).filter(Boolean);
            return clip.frames;
        }

        function renderClipFrameDurations() {
            if (!clipFrameList) return;
            clipFrameList.innerHTML = '';
            if (selectedClipFrames.length === 0) {
                const empty = document.createElement('div');
                empty.className = 'frame-duration-empty';
                empty.textContent = '尚未選擇圖片';
                clipFrameList.appendChild(empty);
                return;
            }
            selectedClipFrames.forEach((frame, idx) => {
                const item = document.createElement('div');
                item.className = 'frame-duration-item';
                const index = document.createElement('span');
                index.className = 'frame-duration-index';
                index.textContent = `#${idx + 1}`;
                const name = document.createElement('span');
                name.className = 'frame-duration-name';
                name.textContent = frame.name || `frame-${idx + 1}`;
                const input = document.createElement('input');
                input.type = 'number';
                input.step = '0.01';
                input.min = '0.01';
                input.value = String(frame.duration ?? '');
                input.oninput = () => { frame.custom = true; };
                input.onchange = () => {
                    const val = Math.max(0.01, Number(input.value || 0));
                    frame.duration = val;
                    frame.custom = true;
                    input.value = String(val);
                };
                const suffix = document.createElement('span');
                suffix.className = 'frame-duration-suffix';
                suffix.textContent = '秒';
                item.append(index, name, input, suffix);
                clipFrameList.appendChild(item);
            });
            const hint = document.createElement('div');
            hint.className = 'frame-duration-hint';
            hint.textContent = '提示：預設依 FPS 換算，可單獨調整。';
            clipFrameList.appendChild(hint);
        }

        function upgradeAnimalClips() {
            if (!Array.isArray(project.animals)) return;
            project.animals.forEach(an => {
                if (!Array.isArray(an.clips)) an.clips = [];
                an.clips.forEach(normalizeClipFrames);
            });
        }

        clipFrames.onchange = async () => {
            const files = Array.from(clipFrames.files || []);
            if (files.length === 0) {
                selectedClipFrames = [];
                renderClipFrameDurations();
                return;
            }
            if (clipFrameList) {
                clipFrameList.innerHTML = '';
                const loading = document.createElement('div');
                loading.className = 'frame-duration-empty';
                loading.textContent = '載入中...';
                clipFrameList.appendChild(loading);
            }
            const fps = Math.max(1, Number(clipFps.value || 6));
            const defaultDuration = 1 / fps;
            const loaded = [];
            try {
                for (const file of files) {
                    const src = await fileToDataUrl(file);
                    loaded.push({
                        id: uid(),
                        name: file.name || `frame-${loaded.length + 1}`,
                        src,
                        duration: defaultDuration,
                        custom: false
                    });
                }
                selectedClipFrames = loaded;
            } catch (err) {
                console.error('Failed to load clip frames', err);
                alert('載入動畫幀失敗：' + (err.message || '未知錯誤'));
                selectedClipFrames = [];
            }
            renderClipFrameDurations();
        };

        clipFps.onchange = () => {
            const fps = Math.max(1, Number(clipFps.value || 6));
            const defaultDuration = 1 / fps;
            let changed = false;
            selectedClipFrames.forEach(frame => {
                if (!frame.custom) {
                    frame.duration = defaultDuration;
                    changed = true;
                }
            });
            if (changed) renderClipFrameDurations();
        };

        renderClipFrameDurations();

        addClip.onclick = async () => {
            const name = clipName.value.trim();
            if (!name) return alert('請輸入動畫名稱');
            const fps = Math.max(1, Number(clipFps.value || 6));
            if (selectedClipFrames.length === 0) return alert('請選擇至少 1 張幀圖片');
            const fallbackDuration = 1 / fps;
            const frames = selectedClipFrames.map(frame => {
                const duration = Math.max(0.01, Number(frame.duration) || fallbackDuration);
                return { src: frame.src, duration };
            }).filter(f => !!f.src);
            if (frames.length === 0) return alert('請選擇至少 1 張有效的幀圖片');
            const totalSeconds = frames.reduce((sum, frame) => sum + frame.duration, 0);
            tempClips.push({ name, fps, frames });
            clipName.value = '';
            clipFps.value = '6';
            clipFrames.value = '';
            selectedClipFrames = [];
            renderClipFrameDurations();
            alert(`已加入動畫 ${name}（${frames.length} 幀，總時長 ${totalSeconds.toFixed(2)} 秒）`);
        };

        addAnimal.onclick = async () => {
            const name = aName.value.trim(); if (!name) return alert('請輸入動物名稱');
            let previewDataUrl = undefined;
            if (aPreview.files && aPreview.files[0]) previewDataUrl = await fileToDataUrl(aPreview.files[0]);

            const aTerrains = Array.from(document.querySelectorAll('#aTerrainChecks input[type=checkbox]'))
                .filter(x => x.checked).map(x => x.dataset.tid);

            const existing = project.animals.find(a => a.name === name);
            if (existing) {
                if (!Array.isArray(existing.clips)) existing.clips = [];
                existing.previewDataUrl = previewDataUrl || existing.previewDataUrl;
                existing.clips.push(...tempClips);
                if (aTerrains.length > 0) existing.spawnTerrains = aTerrains;
                previewAnimal.value = existing.id;
            } else {
                const newAn = { id: name.toLowerCase().replace(/\s+/g, '_') + '_' + uid(), name, previewDataUrl, clips: tempClips.slice(), notes: undefined, spawnTerrains: aTerrains };
                project.animals.push(newAn);
                previewAnimal.value = newAn.id;
            }
            tempClips = []; aName.value = ''; aPreview.value = ''; document.querySelectorAll('#aTerrainChecks input').forEach(x => x.checked = false);
            saveProject(); updatePreviewSelectors(); loadPreviewFrames();
        };

        function renderAnimals() {
            upgradeAnimalClips();
            animalList.innerHTML = '';
            project.animals.forEach(an => {
                const card = cloneCard();
                card.querySelector('img').src = an.previewDataUrl || placeholderIcon();
                card.querySelector('.title').textContent = an.name;
                const clipSummary = (an.clips || []).map(c => {
                    const frames = normalizeClipFrames(c);
                    const totalSec = frames.reduce((sum, frame) => sum + frame.duration, 0);
                    return `${c.name}(${frames.length}幀/${totalSec.toFixed(2)}秒)`;
                }).join('，') || '-';
                const terrainsText = (an.spawnTerrains || []).map(id => project.terrains.find(t => t.id === id)?.name || id).join(', ') || '-';
                card.querySelector('.kvs').innerHTML = `<div>ID</div><div>${an.id}</div><div>動畫</div><div>${clipSummary}</div><div>生成地形</div><div>${terrainsText}</div>`;
                card.querySelector('.edit').onclick = () => {
                    const newName = prompt('動物名稱', an.name) || an.name; an.name = newName;
                    const pick = prompt('以逗號輸入生成地形 ID（不改請留空）', (an.spawnTerrains || []).join(','));
                    if (pick !== null && pick.trim() !== '') an.spawnTerrains = pick.split(',').map(s => s.trim()).filter(Boolean);
                    saveProject(); updatePreviewSelectors();
                };
                card.querySelector('.del').onclick = () => { if (confirm('刪除此動物？')) { project.animals = project.animals.filter(x => x.id !== an.id); saveProject(); updatePreviewSelectors(); } };
                animalList.appendChild(card);
            });
        }

        function updatePreviewSelectors() {
            previewAnimal.innerHTML = '';
            project.animals.forEach(an => {
                const opt = document.createElement('option'); opt.value = an.id; opt.textContent = an.name; previewAnimal.appendChild(opt);
            });
            if (previewAnimal.options.length > 0 && !previewAnimal.value) {
                previewAnimal.value = previewAnimal.options[previewAnimal.options.length - 1].value;
            }
            const search = enableSelectSearch(previewAnimal, { placeholder: '搜尋動物…', emptyText: '沒有符合的動物' });
            search?.refresh();
            updatePreviewClips();
        }

        previewAnimal.onchange = updatePreviewClips;
        function updatePreviewClips() {
            previewClip.innerHTML = '';
            const an = project.animals.find(a => a.id === previewAnimal.value);
            (an?.clips || []).forEach(c => { const o = document.createElement('option'); o.value = c.name; o.textContent = c.name; previewClip.appendChild(o); });
            if (previewClip.options.length > 0 && !previewClip.value) { previewClip.value = previewClip.options[0].value; }
            const clipSearch = enableSelectSearch(previewClip, { placeholder: '搜尋動畫…', emptyText: '沒有符合的動畫' });
            clipSearch?.refresh();
            loadPreviewFrames();
        }

        // Animation preview loop
        const animCanvas = document.getElementById('animCanvas');
        const actx = animCanvas.getContext('2d');
        let animTimer = 0, animIdx = 0, loadedFrames = [], animLastTs = 0;
        function loadPreviewFrames() {
            const an = project.animals.find(a => a.id === previewAnimal.value); if (!an) { loadedFrames = []; animLastTs = 0; return; }
            const c = (an.clips || []).find(x => x.name === previewClip.value); if (!c) { loadedFrames = []; animLastTs = 0; return; }
            const frames = normalizeClipFrames(c);
            loadedFrames = frames.map(frame => {
                const img = new Image();
                img.src = frame.src;
                return { img, duration: frame.duration };
            });
            animIdx = 0; animTimer = 0; animLastTs = 0;
        }
        previewClip.onchange = loadPreviewFrames;
        previewSpeed.oninput = () => { };

        function animLoop(ts) {
            requestAnimationFrame(animLoop);
            actx.clearRect(0, 0, animCanvas.width, animCanvas.height);
            const an = project.animals.find(a => a.id === previewAnimal.value);
            const c = an?.clips.find(x => x.name === previewClip.value);
            if (!an || !c || loadedFrames.length === 0) { animLastTs = ts; return; }
            const dt = animLastTs ? Math.max(0, (ts - animLastTs) / 1000) : 0;
            animLastTs = ts;
            const sp = Math.max(0.1, Number(previewSpeed.value || 1));
            let frameData = loadedFrames[animIdx];
            if (!frameData) return;
            animTimer += dt * sp;
            let guard = 0;
            while (frameData && animTimer >= Math.max(0.01, frameData.duration) && guard < loadedFrames.length * 4) {
                animTimer -= Math.max(0.01, frameData.duration);
                animIdx = (animIdx + 1) % loadedFrames.length;
                frameData = loadedFrames[animIdx];
                guard++;
            }
            const img = frameData?.img;
            if (!img || !img.complete || !img.width || !img.height) return;
            const scale = Math.min(animCanvas.width / img.width, animCanvas.height / img.height);
            const w = img.width * scale, h = img.height * scale; const x = (animCanvas.width - w) / 2, y = (animCanvas.height - h) / 2;
            actx.imageSmoothingEnabled = false;
            actx.drawImage(img, x, y, w, h);
        }
        requestAnimationFrame(animLoop);
        setInterval(loadPreviewFrames, 500);

        // ----------------------------- Entities / Hitboxes -----------------------------
        const eSource = document.getElementById('eSource');
        const eName = document.getElementById('eName');
        const eImage = document.getElementById('eImage');
        const eImageRow = eImage?.closest('.row') || null;
        const hitCanvas = document.getElementById('hitCanvas');
        const hctx = hitCanvas.getContext('2d');
        const hitList = document.getElementById('hitList');
        const clearHitboxes = document.getElementById('clearHitboxes');
        const saveEntity = document.getElementById('saveEntity');
        const entityList = document.getElementById('entityList');

        let entityImage = null; // HTMLImageElement
        let entityImageSource = null;
        let hitboxes = []; // {id,x,y,w,h} normalized
        let drag = null; // {id, mode:'move'|'resize', ox, oy, corner}
        let entitySources = [];
        let currentEntityKey = null;
        let currentEntitySource = null;
        let pendingNewCustomKey = null;
        let needsEntityUpgradeSave = false;

        const CUSTOM_NEW_SENTINEL = '__custom_new__';
        const ENTITY_TYPE_LABELS = { item: '物品', animal: '生物', custom: '自訂', unknown: '未知' };

        function upgradeEntityRecords() {
            if (!Array.isArray(project.entities)) project.entities = [];
            project.entities.forEach(en => {
                if (!en || typeof en !== 'object') return;
                if (!en.id) { en.id = 'entity_' + uid(); needsEntityUpgradeSave = true; }
                if (!en.sourceKey) {
                    if (en.sourceType && en.sourceId) {
                        en.sourceKey = `${en.sourceType}:${en.sourceId}`;
                    } else {
                        en.sourceType = 'custom';
                        en.sourceId = en.id;
                        en.sourceKey = `custom:${en.id}`;
                    }
                    needsEntityUpgradeSave = true;
                }
                if (!en.sourceType && en.sourceKey) {
                    en.sourceType = en.sourceKey.split(':')[0] || 'custom';
                    needsEntityUpgradeSave = true;
                }
                if (!en.sourceId && en.sourceKey) {
                    const parts = en.sourceKey.split(':');
                    if (parts.length > 1) {
                        en.sourceId = parts.slice(1).join(':');
                        needsEntityUpgradeSave = true;
                    }
                }
            });
        }

        upgradeEntityRecords();

        function findEntityEntryByKey(key) {
            if (!key) return undefined;
            return (project.entities || []).find(en => en && en.sourceKey === key);
        }

        function loadEntityImage(src) {
            entityImageSource = src || null;
            if (!src) {
                entityImage = null;
                drawHitCanvas();
                return;
            }
            const img = new Image();
            entityImage = img;
            img.onload = () => drawHitCanvas();
            img.onerror = () => { entityImage = null; drawHitCanvas(); };
            img.src = src;
        }

        function updateImageInputState(type) {
            const isCustom = type === 'custom';
            if (eImageRow) eImageRow.style.display = isCustom ? '' : 'none';
            if (eImage) eImage.disabled = !isCustom;
        }

        eImage.onchange = async () => {
            if (!eImage.files || !eImage.files[0]) return;
            const dataUrl = await fileToDataUrl(eImage.files[0]);
            loadEntityImage(dataUrl);
        };

        function cloneHitboxesFromEntry(entry) {
            if (!entry || !Array.isArray(entry.hitboxes)) return [];
            return entry.hitboxes.map(b => ({ id: b.id || uid(), x: b.x, y: b.y, w: b.w, h: b.h }));
        }

        function getAnimalPreview(an) {
            if (!an) return placeholderIcon();
            if (an.previewDataUrl) return an.previewDataUrl;
            if (an.image && an.image.path) return an.image.path;
            if (Array.isArray(an.clips)) {
                for (const clip of an.clips) {
                    const frames = normalizeClipFrames(clip);
                    const first = frames.find(f => f && f.src);
                    if (first && first.src) return first.src;
                }
            }
            return placeholderIcon();
        }

        function collectEntitySources() {
            const entries = new Map();
            if (Array.isArray(project.entities)) {
                project.entities.forEach(en => {
                    if (!en || typeof en !== 'object') return;
                    if (!en.sourceKey) return;
                    entries.set(en.sourceKey, en);
                });
            }
            const used = new Set();
            const sources = [];
            const categoryMap = new Map((project.itemCategories || []).map(cat => [cat.id, cat]));

            (project.items || []).forEach(item => {
                if (!item || !item.id) return;
                const key = `item:${item.id}`;
                const entry = entries.get(key);
                const category = categoryMap.get(item.categoryId);
                const imageSrc = (item.image && item.image.path) || placeholderIcon();
                sources.push({
                    key,
                    type: 'item',
                    sourceId: item.id,
                    baseName: item.name || item.id,
                    displayName: (entry && entry.name) || item.name || item.id,
                    categoryLabel: category?.label || dropLabelFallback[item.categoryId] || item.categoryId || '',
                    imageSrc,
                    entry
                });
                used.add(key);
            });

            (project.animals || []).forEach(an => {
                if (!an || !an.id) return;
                const key = `animal:${an.id}`;
                const entry = entries.get(key);
                sources.push({
                    key,
                    type: 'animal',
                    sourceId: an.id,
                    baseName: an.name || an.id,
                    displayName: (entry && entry.name) || an.name || an.id,
                    categoryLabel: '生物',
                    imageSrc: getAnimalPreview(an),
                    entry
                });
                used.add(key);
            });

            entries.forEach((entry, key) => {
                if (used.has(key)) return;
                const type = entry.sourceType || (key.startsWith('custom:') ? 'custom' : 'unknown');
                const sourceId = entry.sourceId || key.replace(/^custom:/, '');
                const imageSrc = entry.imageDataUrl || entry.imagePath || placeholderIcon();
                sources.push({
                    key,
                    type,
                    sourceId,
                    baseName: entry.name || sourceId || key,
                    displayName: entry.name || sourceId || key,
                    categoryLabel: type === 'custom' ? '自訂' : '未知',
                    imageSrc,
                    entry,
                    orphan: type !== 'custom'
                });
            });

            const typeOrder = { item: 0, animal: 1, custom: 2, unknown: 3 };
            sources.sort((a, b) => {
                const ao = typeOrder[a.type] ?? 99;
                const bo = typeOrder[b.type] ?? 99;
                if (ao !== bo) return ao - bo;
                return (a.baseName || '').localeCompare(b.baseName || '', 'zh-Hant');
            });
            return sources;
        }

        function formatEntityOption(src) {
            const typeLabel = ENTITY_TYPE_LABELS[src.type] || '其他';
            const hitCount = src.entry && Array.isArray(src.entry.hitboxes) ? src.entry.hitboxes.length : 0;
            const hitText = hitCount > 0 ? `（${hitCount} 框）` : '（尚未設定）';
            const idText = src.sourceId ? ` [${src.sourceId}]` : '';
            return `[${typeLabel}] ${src.baseName}${idText} ${hitText}`;
        }

        function refreshEntitySourceOptions() {
            if (!eSource) return;
            const selectedValue = pendingNewCustomKey ? CUSTOM_NEW_SENTINEL : currentEntityKey;
            eSource.innerHTML = '';
            const placeholder = document.createElement('option');
            placeholder.value = '';
            placeholder.textContent = '選擇來源（物品 / 動物 或自訂）';
            placeholder.dataset.searchSkip = '1';
            eSource.appendChild(placeholder);
            const customOpt = document.createElement('option');
            customOpt.value = CUSTOM_NEW_SENTINEL;
            customOpt.textContent = '＋ 新增自訂生物底圖';
            customOpt.dataset.searchSkip = '1';
            eSource.appendChild(customOpt);
            entitySources.forEach(src => {
                const opt = document.createElement('option');
                opt.value = src.key;
                opt.textContent = formatEntityOption(src);
                eSource.appendChild(opt);
            });
            const validValues = new Set(Array.from(eSource.options).map(opt => opt.value));
            if (selectedValue && validValues.has(selectedValue)) {
                eSource.value = selectedValue;
            } else if (pendingNewCustomKey) {
                eSource.value = CUSTOM_NEW_SENTINEL;
            } else {
                eSource.value = '';
            }
            const search = enableSelectSearch(eSource, {
                placeholder: '搜尋來源…',
                emptyText: '沒有符合的來源',
                alwaysVisible: ['', CUSTOM_NEW_SENTINEL]
            });
            search?.refresh();
        }

        function renderEntityCards() {
            entityList.innerHTML = '';
            if (entitySources.length === 0) {
                const empty = document.createElement('div');
                empty.className = 'note';
                empty.textContent = '尚未同步到任何物品或動物資料，可先新增後再設定碰撞框。';
                entityList.appendChild(empty);
                return;
            }
            entitySources.forEach(src => {
                const card = cloneCard();
                card.querySelector('img').src = src.imageSrc || placeholderIcon();
                card.querySelector('.title').textContent = src.displayName || src.baseName || src.key;
                const kvs = [];
                const typeLabel = ENTITY_TYPE_LABELS[src.type] || src.type;
                kvs.push('<div>類型</div><div>' + typeLabel + '</div>');
                if (src.sourceId) kvs.push('<div>來源ID</div><div>' + src.sourceId + '</div>');
                if (src.type === 'item' && src.categoryLabel) kvs.push('<div>分類</div><div>' + src.categoryLabel + '</div>');
                const hitCount = src.entry && Array.isArray(src.entry.hitboxes) ? src.entry.hitboxes.length : 0;
                kvs.push('<div>碰撞框</div><div>' + (hitCount > 0 ? `${hitCount} 個` : '尚未設定') + '</div>');
                if (src.orphan) kvs.push('<div>狀態</div><div>來源不存在</div>');
                card.querySelector('.kvs').innerHTML = kvs.join('');
                card.querySelector('.edit').onclick = () => {
                    switchTab('entities');
                    selectEntitySource(src.key);
                };
                const delBtn = card.querySelector('.del');
                if (src.entry) {
                    delBtn.textContent = '清除碰撞框';
                    delBtn.disabled = false;
                    delBtn.onclick = () => {
                        if (!confirm('清除此來源的所有碰撞框？')) return;
                        project.entities = project.entities.filter(en => en !== src.entry);
                        if (currentEntityKey === src.key) {
                            hitboxes = [];
                            renderHitList();
                        }
                        saveProject();
                    };
                } else {
                    delBtn.textContent = '尚未設定';
                    delBtn.disabled = true;
                    delBtn.onclick = null;
                }
                entityList.appendChild(card);
            });
        }

        function selectEntitySource(key, { resetHitboxes = true } = {}) {
            if (!key) {
                currentEntityKey = null;
                currentEntitySource = null;
                pendingNewCustomKey = null;
                updateImageInputState(null);
                hitboxes = [];
                entityImage = null;
                entityImageSource = null;
                eImage.value = '';
                drawHitCanvas();
                renderHitList();
                refreshEntitySourceOptions();
                return;
            }
            pendingNewCustomKey = null;
            currentEntityKey = key;
            const source = entitySources.find(s => s.key === key) || null;
            currentEntitySource = source;
            if (!source) {
                updateImageInputState(null);
                hitboxes = [];
                entityImage = null;
                entityImageSource = null;
                drawHitCanvas();
                renderHitList();
                refreshEntitySourceOptions();
                return;
            }
            updateImageInputState(source.type);
            const entry = findEntityEntryByKey(key);
            if (source.type === 'custom') {
                const imgSrc = entry?.imageDataUrl || entry?.imagePath || null;
                loadEntityImage(imgSrc);
            } else {
                const imgSrc = source.imageSrc || placeholderIcon();
                if (entityImageSource !== imgSrc) loadEntityImage(imgSrc);
            }
            if (resetHitboxes) {
                hitboxes = cloneHitboxesFromEntry(entry);
                renderHitList();
            }
            const fallbackName = source.displayName || source.baseName || '';
            eName.value = entry?.name || fallbackName;
            refreshEntitySourceOptions();
            drawHitCanvas();
        }

        function prepareNewCustomEntity() {
            const newKey = `custom:${uid()}`;
            pendingNewCustomKey = newKey;
            currentEntityKey = newKey;
            currentEntitySource = { key: newKey, type: 'custom', baseName: '', displayName: '', sourceId: newKey.replace('custom:', '') };
            updateImageInputState('custom');
            eName.value = '';
            eImage.value = '';
            hitboxes = [];
            entityImage = null;
            entityImageSource = null;
            drawHitCanvas();
            renderHitList();
            refreshEntitySourceOptions();
        }

        if (eSource) {
            eSource.onchange = () => {
                if (eSource.value === CUSTOM_NEW_SENTINEL) {
                    prepareNewCustomEntity();
                    return;
                }
                if (!eSource.value) {
                    selectEntitySource(null);
                    return;
                }
                selectEntitySource(eSource.value);
            };
        }

        function toCanvas(px, py) { return { x: px * hitCanvas.width, y: py * hitCanvas.height }; }
        function toNorm(cx, cy) { return { x: cx / hitCanvas.width, y: cy / hitCanvas.height }; }

        function drawHitCanvas() {
            hctx.clearRect(0, 0, hitCanvas.width, hitCanvas.height);
            if (entityImage) {
                const scale = Math.min(hitCanvas.width / entityImage.width, hitCanvas.height / entityImage.height);
                const w = entityImage.width * scale, h = entityImage.height * scale, x = (hitCanvas.width - w) / 2, y = (hitCanvas.height - h) / 2;
                hctx.imageSmoothingEnabled = false; hctx.drawImage(entityImage, x, y, w, h);
            }
            hitboxes.forEach(b => {
                const { x, y } = toCanvas(b.x, b.y); const { x: rx, y: ry } = toCanvas(b.x + b.w, b.y + b.h);
                hctx.strokeStyle = '#7cffc4'; hctx.setLineDash([6, 4]); hctx.lineWidth = 2; hctx.strokeRect(x, y, rx - x, ry - y);
                hctx.setLineDash([]);
                hctx.fillStyle = 'rgba(124,255,196,0.15)'; hctx.fillRect(x, y, rx - x, ry - y);
                drawHandle(x, y); drawHandle(rx, y); drawHandle(x, ry); drawHandle(rx, ry);
            });
        }
        function drawHandle(x, y) { hctx.fillStyle = '#7aa2ff'; hctx.fillRect(x - 5, y - 5, 10, 10); }

        function hitAt(cx, cy) {
            for (const b of [...hitboxes].slice().reverse()) {
                const { x, y } = toCanvas(b.x, b.y); const { x: rx, y: ry } = toCanvas(b.x + b.w, b.y + b.h);
                const inBox = cx >= x && cy >= y && cx <= rx && cy <= ry;
                const csize = 14;
                const corners = [{ k: 'tl', X: x, Y: y }, { k: 'tr', X: rx, Y: y }, { k: 'bl', X: x, Y: ry }, { k: 'br', X: rx, Y: ry }];
                for (const c of corners) { if (Math.abs(cx - c.X) <= csize && Math.abs(cy - c.Y) <= csize) return { box: b, corner: c.k }; }
                if (inBox) return { box: b, corner: null };
            }
            return null;
        }

        hitCanvas.oncontextmenu = e => e.preventDefault();
        hitCanvas.onpointerdown = e => {
            const rect = hitCanvas.getBoundingClientRect(); const cx = e.clientX - rect.left, cy = e.clientY - rect.top;
            const h = hitAt(cx, cy);
            if (e.button === 2 && h) {
                hitboxes = hitboxes.filter(x => x !== h.box); drawHitCanvas(); renderHitList(); return;
            }
            if (h) {
                drag = { id: h.box.id, mode: h.corner ? 'resize' : 'move', ox: cx, oy: cy, corner: h.corner };
            } else if (e.button === 0 && e.shiftKey) {
                const { x, y } = toNorm(cx, cy); const b = { id: uid(), x, y, w: 0.01, h: 0.01 }; hitboxes.push(b); drag = { id: b.id, mode: 'resize', ox: cx, oy: cy, corner: 'br' };
            }
            drawHitCanvas(); renderHitList();
        };
        hitCanvas.onpointermove = e => {
            if (!drag) return;
            const rect = hitCanvas.getBoundingClientRect(); const cx = e.clientX - rect.left, cy = e.clientY - rect.top;
            const box = hitboxes.find(b => b.id === drag.id); if (!box) return;
            if (drag.mode === 'move') {
                const dx = (cx - drag.ox) / hitCanvas.width, dy = (cy - drag.oy) / hitCanvas.height; box.x += dx; box.y += dy; drag.ox = cx; drag.oy = cy;
            } else if (drag.mode === 'resize') {
                const nx = Math.min(Math.max(cx, 0), hitCanvas.width); const ny = Math.min(Math.max(cy, 0), hitCanvas.height);
                const { x: px, y: py } = toNorm(nx, ny); let nx0 = box.x, ny0 = box.y, nw = box.w, nh = box.h;
                if (drag.corner === 'br') { nw = px - box.x; nh = py - box.y; }
                if (drag.corner === 'tr') { nw = px - box.x; ny0 = py; nh = (box.y + box.h) - py; }
                if (drag.corner === 'bl') { nx0 = px; nw = (box.x + box.w) - px; nh = py - box.y; }
                if (drag.corner === 'tl') { nx0 = px; ny0 = py; nw = (box.x + box.w) - px; nh = (box.y + box.h) - py; }
                box.x = nx0; box.y = ny0; box.w = nw; box.h = nh;
            }
            clampBox(box); drawHitCanvas(); renderHitList();
        };
        hitCanvas.onpointerup = () => drag = null;
        function clampBox(b) {
            b.w = Math.max(0.001, Math.min(1 - b.x, b.w));
            b.h = Math.max(0.001, Math.min(1 - b.y, b.h));
            b.x = Math.max(0, Math.min(1 - b.w, b.x));
            b.y = Math.max(0, Math.min(1 - b.h, b.y));
        }

        clearHitboxes.onclick = () => {
            if (!currentEntityKey && !pendingNewCustomKey) {
                alert('請先選擇要編輯的來源');
                return;
            }
            if (confirm('清空目前畫布的碰撞框？')) { hitboxes = []; drawHitCanvas(); renderHitList(); }
        };

        saveEntity.onclick = async () => {
            if (!currentEntityKey) {
                alert('請先選擇來源或新增自訂生物');
                return;
            }
            const sourceType = currentEntitySource?.type || currentEntityKey.split(':')[0] || 'custom';
            const sourceId = currentEntitySource?.sourceId || currentEntityKey.split(':').slice(1).join(':') || currentEntityKey;
            const defaultName = currentEntitySource?.displayName || currentEntitySource?.baseName || sourceId || '';
            const name = eName.value.trim() || defaultName;
            if (!name) return alert('請輸入生物名稱');
            if (!entityImage) return alert('請先載入底圖');

            let entry = findEntityEntryByKey(currentEntityKey);
            if (!entry) {
                entry = {
                    id: 'entity_' + uid(),
                    sourceKey: currentEntityKey,
                    sourceType,
                    sourceId,
                    createdAt: new Date().toISOString()
                };
                project.entities.push(entry);
            }
            entry.sourceKey = currentEntityKey;
            entry.sourceType = sourceType;
            entry.sourceId = sourceId;
            entry.name = name;
            entry.hitboxes = JSON.parse(JSON.stringify(hitboxes));
            entry.updatedAt = new Date().toISOString();
            if (sourceType === 'custom') {
                entry.imageDataUrl = entityImageSource || (entityImage?.src ?? entry.imageDataUrl ?? null);
            } else {
                delete entry.imageDataUrl;
            }
            pendingNewCustomKey = null;
            saveProject();
        };

        function renderHitList() {
            hitList.innerHTML = '';
            if (hitboxes.length === 0) {
                const empty = document.createElement('div');
                empty.className = 'small';
                empty.textContent = '尚未設定碰撞框';
                hitList.appendChild(empty);
                return;
            }
            hitboxes.forEach((b, i) => {
                const div = document.createElement('div'); div.className = 'row';
                div.innerHTML = `<label>#${i + 1}</label><div class="chips">`
                    + `<span class="chip">x:${b.x.toFixed(3)}</span>`
                    + `<span class="chip">y:${b.y.toFixed(3)}</span>`
                    + `<span class="chip">w:${b.w.toFixed(3)}</span>`
                    + `<span class="chip">h:${b.h.toFixed(3)}</span>` + `</div>`;
                hitList.appendChild(div);
            });
        }

        function renderEntities() {
            entitySources = collectEntitySources();
            if (!pendingNewCustomKey && currentEntityKey) {
                const source = entitySources.find(s => s.key === currentEntityKey) || null;
                if (!source) {
                    currentEntitySource = null;
                    currentEntityKey = null;
                    updateImageInputState(null);
                    hitboxes = [];
                    entityImage = null;
                    entityImageSource = null;
                    drawHitCanvas();
                    renderHitList();
                } else {
                    currentEntitySource = source;
                    if (source.type !== 'custom') {
                        const imgSrc = source.imageSrc || placeholderIcon();
                        if (entityImageSource !== imgSrc) loadEntityImage(imgSrc);
                    }
                }
            }
            if (pendingNewCustomKey) {
                updateImageInputState('custom');
            } else if (currentEntitySource) {
                updateImageInputState(currentEntitySource.type);
            } else {
                updateImageInputState(null);
            }
            refreshEntitySourceOptions();
            renderEntityCards();
        }

        if (needsEntityUpgradeSave) {
            needsEntityUpgradeSave = false;
            saveProject();
        }
        // ----------------------------- Import / Export / Reset -----------------------------
        document.getElementById('btnExport').onclick = () => {
            const file = new Blob([JSON.stringify(project, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(file); const a = document.createElement('a'); a.href = url; a.download = 'game-assets.json'; a.click(); URL.revokeObjectURL(url);
        };
        document.getElementById('importJson').onchange = async (e) => {
            const f = e.target.files?.[0]; if (!f) return; const txt = await f.text();
            try { project = JSON.parse(txt); saveProject(); alert('匯入完成'); updatePreviewSelectors(); }
            catch (err) { alert('匯入失敗：JSON 格式錯誤'); }
            e.target.value = '';
        };
        document.getElementById('btnReset').onclick = () => { if (confirm('清空並重置所有資料？')) { project = emptyProject(); saveProject(); updatePreviewSelectors(); } };

        // ----------------------------- Helpers & Render -----------------------------
        function cloneCard() { return document.getElementById('tpl-card').content.firstElementChild.cloneNode(true); }
        function placeholderIcon() {
            return 'data:image/svg+xml,' + encodeURIComponent(svgIcon('#7cffc4'));
        }
        function svgIcon(color) {
            return `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64"><defs><linearGradient id="g" x1="0" y1="0" x2="1" y2="1"><stop offset="0" stop-color="${color}"/><stop offset="1" stop-color="#1e2a66"/></linearGradient></defs><rect rx="12" width="64" height="64" fill="url(#g)"/><g fill="#0b1020" opacity=".6"><circle cx="48" cy="14" r="4"/><circle cx="20" cy="46" r="6"/><rect x="12" y="14" width="24" height="12" rx="3"/></g></svg>`;
        }

        function renderAll() { renderTerrains(); renderItems(); renderAnimals(); renderEntities(); }

        // ----------------------------- Init -----------------------------
        renderAll(); switchTab(currentTab); updatePreviewSelectors(); drawHitCanvas();
        syncItemsFromServer();
        syncTerrainsFromServer();
    </script>

    <!-- Drops UI add-on v2 -->
    <script src="drops-addon.js"></script>
    <script>(function () { function f() { return document.querySelector('#item-editor-right') || document.querySelector('#item-editor') || document.querySelector('#items-panel') || document.querySelector('[data-tab="items"]') || document.body } if (typeof window.openItemEditor === 'function') { const o = window.openItemEditor; window.openItemEditor = function (i) { const r = o.apply(this, arguments); try { ItemDrops.onOpen(i, f()) } catch (e) { console.warn('[drops] onOpen warn:', e) } return r } } window.addEventListener('adventurelife:openItemEditor', ev => { const i = ev.detail && ev.detail.item; if (i) ItemDrops.onOpen(i, f()) }); function w() { const form = document.querySelector('form#item-form, form[name="item-form"]') || document.querySelector('#items form'); if (!form) return; form.addEventListener('submit', function (e) { try { const fd = new FormData(this); ItemDrops.onCollect(fd); } catch (err) { console.warn('[drops] submit hook warn:', err) } }, { capture: true }); } document.addEventListener('DOMContentLoaded', w); setTimeout(w, 800); })();</script>

</body>

</html>