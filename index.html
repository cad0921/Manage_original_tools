<!DOCTYPE html>
<html lang="zh-Hant">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Game Asset CMS – Items / Animals / Hitboxes</title>
    <style>
        :root {
            --bg: #0b1020;
            --panel: #121832;
            --panel2: #0f1530;
            --text: #e6ecff;
            --muted: #a6b2d6;
            --primary: #7aa2ff;
            --accent: #7cffc4;
            --danger: #ff7a7a;
            --br: 16px;
            --pad: 14px;
            --gap: 12px;
            --shadow: 0 8px 28px rgba(0, 0, 0, .45);
        }

        * {
            box-sizing: border-box
        }

        body {
            margin: 0;
            background: radial-gradient(1200px 600px at 20% -10%, #1e274a, transparent 60%), radial-gradient(1000px 500px at 120% 10%, #1a2142, transparent 50%), var(--bg);
            color: var(--text);
            font-family: system-ui, -apple-system, Segoe UI, Roboto, Noto Sans TC, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji"
        }

        header {
            position: sticky;
            top: 0;
            z-index: 5;
            background: linear-gradient(0deg, rgba(11, 16, 32, 0), rgba(11, 16, 32, .85)), var(--panel);
            backdrop-filter: saturate(1.2) blur(8px);
            border-bottom: 1px solid #1d2550
        }

        header .bar {
            max-width: 1400px;
            margin: auto;
            padding: 10px 16px;
            display: flex;
            gap: 10px;
            align-items: center
        }

        h1 {
            font-size: 18px;
            margin: 0 12px 0 0;
            letter-spacing: .5px
        }

        .tag {
            font-size: 12px;
            color: var(--muted)
        }

        .wrap {
            max-width: 1400px;
            margin: 20px auto;
            padding: 0 16px 48px
        }

        .tabs {
            display: flex;
            gap: 8px;
            flex-wrap: wrap
        }

        .tab-btn {
            border: 1px solid #22306b;
            background: linear-gradient(180deg, #1b2450, #141b3d);
            color: var(--text);
            padding: 8px 12px;
            border-radius: 999px;
            cursor: pointer
        }

        .tab-btn.active {
            border-color: #3b55c8;
            box-shadow: inset 0 0 0 1px #3b55c855
        }

        .grid {
            display: grid;
            grid-template-columns: minmax(0, 1.5fr) minmax(0, 1fr);
            gap: 20px
        }

        .panel[data-tab="items"] .grid {
            grid-template-columns: minmax(0, 1.8fr) minmax(0, 1.1fr);
            align-items: start;
        }

        .panel[data-tab="animals"] .grid {
            grid-template-columns: minmax(0, 1.95fr) minmax(0, 1.05fr);
            align-items: start;
        }
        .panel[data-tab="entities"] .grid {
            grid-template-columns: minmax(0, 1.8fr) minmax(0, 1fr);
        }

        @media (max-width:1000px) {
            .grid {
                grid-template-columns: 1fr
            }

            .panel[data-tab="items"] .grid,
            .panel[data-tab="animals"] .grid {
                grid-template-columns: 1fr;
            }
        }

        .panel {
            background: linear-gradient(180deg, var(--panel), var(--panel2));
            border: 1px solid #1d2550;
            border-radius: var(--br);
            box-shadow: var(--shadow)
        }

        .panel h2 {
            font-size: 16px;
            margin: 0 0 12px;
            color: #c9d5ff
        }

        .panel .head {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 14px;
            border-bottom: 1px solid #1d2550
        }

        .panel .body {
            padding: 16px;
            display: flex;
            flex-direction: column;
            gap: 12px
        }

        .row {
            display: flex;
            gap: 10px;
            align-items: center;
            flex-wrap: wrap
        }

        .row>label {
            min-width: 90px;
            color: var(--muted)
        }

        .row.creature-row {
            align-items: flex-start;
        }

        .creature-editor-host {
            flex: 1;
        }

        .creature-editor {
            display: flex;
            flex-direction: column;
            gap: 12px;
            width: 100%;
        }

        .creature-group {
            display: flex;
            flex-direction: column;
            gap: 10px;
            background: #0f1534;
            border: 1px solid #1d2550;
            border-radius: 12px;
            padding: 12px;
        }

        .creature-group-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 8px;
            font-size: 13px;
            color: var(--muted);
        }

        .creature-group-title {
            font-weight: 600;
            color: #d7e0ff;
        }

        .creature-list {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .creature-animation-row,
        .creature-skill-row {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            align-items: center;
            padding: 10px;
            border-radius: 10px;
            border: 1px solid #1f2955;
            background: #0c1434;
        }

        .creature-inline {
            display: flex;
            flex-direction: column;
            gap: 4px;
            flex: 1 1 160px;
            min-width: 140px;
        }

        .creature-inline.small {
            flex: 0 0 120px;
        }

        .creature-inline.checkbox {
            flex: 0 0 auto;
            flex-direction: row;
            align-items: center;
            gap: 6px;
            color: var(--muted);
        }

        .creature-inline.grow {
            flex: 2 1 260px;
            min-width: 200px;
        }

        .creature-inline-label {
            font-size: 12px;
            color: var(--muted);
        }

        .creature-note {
            font-size: 12px;
            color: var(--muted);
        }

        .creature-empty {
            font-size: 13px;
            color: var(--muted);
            border: 1px dashed #27306b;
            border-radius: 10px;
            padding: 12px;
            text-align: center;
        }

        .creature-animation-row .btn,
        .creature-skill-row .btn {
            flex: 0 0 auto;
        }

        .creature-editor .btn.secondary {
            align-self: flex-start;
        }

        .creature-skill-row textarea {
            min-height: 60px;
        }

        input[type="text"],
        input[type="number"],
        textarea,
        select {
            width: 100%;
            padding: 10px 12px;
            border-radius: 10px;
            border: 1px solid #27306b;
            background: #0e1533;
            color: var(--text)
        }

        textarea {
            min-height: 80px
        }

        .btn {
            padding: 9px 12px;
            border-radius: 10px;
            border: 1px solid #2742a2;
            background: linear-gradient(180deg, #2541a0, #1a2e77);
            color: white;
            cursor: pointer
        }

        .btn:disabled {
            opacity: .5;
            cursor: not-allowed
        }

        .btn.secondary {
            border-color: #2a355f;
            background: linear-gradient(180deg, #1a224a, #141b34)
        }

        .btn.danger {
            border-color: #5a2231;
            background: linear-gradient(180deg, #7a273a, #541a28)
        }

        .chips {
            display: flex;
            flex-wrap: wrap;
            gap: 8px
        }

        .chip {
            padding: 6px 9px;
            border: 1px solid #2a3a80;
            background: #121a3f;
            border-radius: 999px;
            font-size: 12px;
            color: #cfe0ff
        }

        .file-input-wrap {
            display: flex;
            flex-direction: column;
            gap: 6px;
            width: 100%;
        }

        .form-inline-check {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            font-size: 12px;
            color: var(--muted);
            cursor: pointer;
        }

        .form-inline-check input {
            margin: 0;
        }

        .preview-thumb-wrap {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            align-items: center;
        }

        .preview-thumb {
            width: 72px;
            height: 72px;
            object-fit: cover;
            border-radius: 10px;
            border: 1px solid #23306a;
            background: #0e1533;
        }

        .clip-section,
        .clip-drafts {
            border: 1px solid #1f2955;
            border-radius: 12px;
            background: #0c1434;
            padding: 12px;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .clip-section-head,
        .clip-drafts-header {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            justify-content: space-between;
            align-items: center;
        }

        .clip-section-title,
        .clip-drafts-title {
            font-size: 14px;
            font-weight: 600;
            color: #d7e0ff;
        }

        .clip-section-status,
        .clip-drafts-meta {
            font-size: 12px;
            color: var(--muted);
        }

        .clip-toolbar {
            justify-content: flex-end;
        }

        .clip-list {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .clip-item {
            display: flex;
            flex-direction: column;
            gap: 8px;
            border: 1px solid #27306b;
            border-radius: 10px;
            padding: 10px;
            background: #0e1533;
        }

        .clip-item.active {
            border-color: #3b55c8;
            box-shadow: inset 0 0 0 1px rgba(122, 162, 255, .3);
        }

        .clip-item-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 8px;
        }

        .clip-item-meta {
            font-size: 12px;
            color: var(--muted);
        }

        .clip-item-actions {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
        }

        .ghost-btn {
            padding: 4px 8px;
            border-radius: 8px;
            border: 1px solid #2a355f;
            background: rgba(18, 26, 63, .6);
            color: #c5d0ff;
            cursor: pointer;
            font-size: 12px;
        }

        .ghost-btn:hover {
            border-color: #3d57b8;
            color: white;
        }

        .ghost-btn.danger {
            border-color: #5a2231;
            color: #ff9fa6;
        }

        .ghost-btn.danger:hover {
            color: white;
        }

        .frame-duration-list {
            display: flex;
            flex-direction: column;
            gap: 8px;
            width: 100%
        }

        .frame-duration-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px 10px;
            border-radius: 10px;
            border: 1px solid #27306b;
            background: #10183a
        }

        .frame-duration-index {
            font-size: 12px;
            color: var(--muted);
            min-width: 32px
        }

        .frame-duration-name {
            flex: 1;
            font-size: 13px;
            color: var(--text);
            opacity: .85;
            word-break: break-all
        }

        .frame-duration-thumb {
            width: 44px;
            height: 44px;
            border-radius: 8px;
            border: 1px solid #23306a;
            object-fit: cover;
            background: #0e1533;
        }

        .frame-duration-item input[type="number"] {
            max-width: 90px
        }

        .frame-duration-suffix {
            font-size: 12px;
            color: var(--muted)
        }

        .frame-duration-actions {
            display: flex;
            gap: 6px;
            flex-wrap: wrap;
            margin-left: auto;
        }

        .frame-duration-item .ghost-btn {
            font-size: 11px;
            padding: 4px 6px;
        }

        .frame-duration-empty,
        .frame-duration-hint {
            font-size: 12px;
            color: var(--muted)
        }

        #aTerrainChecks {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }

        #aTerrainChecks label.terrain-chip {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 6px 10px;
            border-radius: 999px;
            border: 1px solid #2a3a80;
            background: #121a3f;
            font-size: 12px;
            color: #cfe0ff;
            cursor: pointer;
        }

        #aTerrainChecks label.terrain-chip input {
            margin: 0;
        }

        .list {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(240px, 1fr));
            gap: 12px
        }

        .panel[data-tab="animals"] .list {
            grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
        }

        .card {
            background: #0e1533;
            border: 1px solid #1f2755;
            border-radius: 14px;
            padding: 12px;
            display: flex;
            flex-wrap: wrap;
            align-items: flex-start;
            gap: 10px
        }

        .card img {
            width: 48px;
            height: 48px;
            object-fit: cover;
            border-radius: 10px;
            border: 1px solid #23306a
        }

        .card-actions {
            display: flex;
            flex-direction: column;
            gap: 6px;
            flex: 0 0 auto
        }

        .thumbs {
            margin-top: 10px;
            display: flex;
            flex-wrap: wrap;
            gap: 8px
        }

        .thumbs img {
            width: 52px;
            height: 52px;
            object-fit: cover;
            border-radius: 8px;
            border: 1px solid #23306a;
            background: #10183a
        }

        .terrain-item {
            border: 1px solid #1f2755;
            border-radius: 14px;
            background: #0e1533;
            box-shadow: var(--shadow);
            padding: 0 12px 12px;
            color: var(--text)
        }

        .terrain-item[open] {
            border-color: #3b55c8;
            background: linear-gradient(180deg, rgba(30, 40, 90, .45), rgba(12, 18, 46, .95)), #0e1533;
        }

        .terrain-summary {
            list-style: none;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 12px;
            padding: 14px 0;
            cursor: pointer;
            font-weight: 600;
        }

        .terrain-summary::after {
            content: '\25BC';
            font-size: 12px;
            color: var(--muted);
            transition: transform .2s ease;
        }

        .terrain-item[open] .terrain-summary::after {
            transform: rotate(-180deg);
        }

        .terrain-summary::-webkit-details-marker {
            display: none;
        }

        .terrain-summary .title-wrap {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .terrain-summary .title {
            font-size: 15px;
        }

        .terrain-summary .meta {
            display: flex;
            gap: 12px;
            font-size: 12px;
            color: var(--muted);
        }

        .terrain-body {
            border-top: 1px solid #1d2550;
            margin-top: 6px;
            padding-top: 12px;
            display: grid;
            gap: 12px;
        }

        .terrain-form {
            display: grid;
            gap: 8px;
        }

        .terrain-form .row {
            display: grid;
            grid-template-columns: 110px 1fr;
            gap: 10px;
            align-items: center;
        }

        @media (max-width:600px) {
            .terrain-form .row {
                grid-template-columns: 1fr;
            }
        }

        .terrain-actions {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }

        .terrain-images {
            display: grid;
            gap: 10px;
        }

        .terrain-image-card {
            display: grid;
            grid-template-columns: auto 1fr;
            gap: 12px;
            padding: 10px;
            border: 1px solid #23306a;
            border-radius: 12px;
            background: #0a1232;
        }

        .terrain-image-card a {
            display: inline-flex;
            border-radius: 10px;
            overflow: hidden;
            border: 1px solid #23306a;
        }

        .terrain-image-card img {
            width: 72px;
            height: 72px;
            object-fit: cover;
        }

        .terrain-image-info {
            display: grid;
            gap: 6px;
        }

        .terrain-image-info .meta {
            font-size: 12px;
            color: var(--muted);
        }

        .terrain-image-actions {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }

        .terrain-image-toggle {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            font-size: 12px;
            color: var(--muted);
        }

        .terrain-image-toggle input {
            margin: 0;
        }

        .checklist {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
        }

        .checklist label {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 6px 10px;
            border-radius: 999px;
            border: 1px solid #23306a;
            background: #111a3a;
            font-size: 13px;
            cursor: pointer;
        }

        .checklist input[type="checkbox"] {
            margin: 0;
        }

        .drop-editor-wrap {
            width: 100%;
        }

        .row.item-drop-row>label {
            align-self: flex-start;
            padding-top: 6px;
        }

        .drop-editor {
            display: grid;
            gap: 10px;
            padding: 10px;
            border: 1px solid #23306a;
            border-radius: 12px;
            background: rgba(8, 14, 42, 0.85);
        }

        .drop-editor .drop-list {
            display: grid;
            gap: 8px;
        }

        .drop-editor .drop-row {
            display: grid;
            grid-template-columns: minmax(90px, 0.8fr) minmax(70px, 0.5fr) minmax(70px, 0.5fr) minmax(150px, 1fr) minmax(160px, 1.2fr) auto;
            gap: 8px;
            align-items: center;
            padding: 6px 8px;
            border: 1px dashed rgba(58, 78, 150, 0.6);
            border-radius: 10px;
            background: rgba(10, 18, 48, 0.4);
        }

        .drop-editor .drop-row input,
        .drop-editor .drop-row select {
            width: 100%;
        }

        .drop-editor .drop-row button {
            justify-self: end;
            padding: 6px 10px;
            border-radius: 8px;
            border: 1px solid #4a2850;
            background: linear-gradient(180deg, #7a273a, #541a28);
            color: #fff;
            cursor: pointer;
        }

        .drop-editor .drop-empty {
            padding: 10px;
            border-radius: 8px;
            border: 1px dashed rgba(58, 78, 150, 0.4);
            text-align: center;
            color: var(--muted);
            font-size: 13px;
        }

        .drop-editor .drop-actions {
            display: flex;
            align-items: center;
            gap: 10px;
            flex-wrap: wrap;
        }

        .drop-editor .drop-note {
            font-size: 12px;
            color: var(--muted);
        }

        .drop-editor .btn-add-drop {
            padding: 7px 12px;
            border-radius: 10px;
            border: 1px solid #2742a2;
            background: linear-gradient(180deg, rgba(39, 66, 162, 0.65), rgba(26, 46, 119, 0.8));
            color: #fff;
            cursor: pointer;
        }

        .drop-editor .btn-add-drop:disabled {
            opacity: .6;
            cursor: not-allowed;
        }

        @media (max-width:780px) {
            .drop-editor .drop-row {
                grid-template-columns: repeat(2, minmax(0, 1fr));
            }

            .drop-editor .drop-row button {
                justify-self: stretch;
            }
        }

        .item-browser {
            display: grid;
            grid-template-columns: minmax(220px, 260px) 1fr;
            gap: 16px;
        }

        @media (max-width:900px) {
            .item-browser {
                grid-template-columns: 1fr;
            }

            .item-browser-nav {
                max-height: none;
                overflow-y: visible;
            }
        }

        .item-browser-nav {
            display: flex;
            flex-direction: column;
            gap: 12px;
            max-height: 560px;
            overflow-y: auto;
            padding-right: 4px;
        }

        .item-nav-group {
            border: 1px solid #1f2755;
            border-radius: 12px;
            background: linear-gradient(180deg, rgba(14, 20, 45, .9), rgba(10, 18, 44, .95));
            padding: 10px;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .item-nav-title {
            font-size: 13px;
            font-weight: 600;
            color: #9fb6ff;
            letter-spacing: .5px;
        }

        .item-nav-items {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .item-nav-item {
            border: 1px solid #23306a;
            border-radius: 9px;
            background: #0a1232;
            color: var(--text);
            padding: 8px 10px;
            text-align: left;
            font: inherit;
            cursor: pointer;
            transition: border-color .15s ease, background-color .15s ease, transform .15s ease;
        }

        .item-nav-item:hover {
            border-color: #3d57b8;
            background: #131d49;
        }

        .item-nav-item.active {
            border-color: #7aa2ff;
            background: #162356;
            box-shadow: inset 0 0 0 1px rgba(122, 162, 255, .3);
        }

        .item-nav-empty {
            font-size: 12px;
            color: var(--muted);
        }

        .item-browser-detail {
            min-height: 420px;
        }

        .item-card {
            border: 1px solid #23306a;
            border-radius: 12px;
            background: #0a1232;
            padding: 16px;
            display: grid;
            gap: 16px;
        }

        .item-card-header {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .item-card-title {
            font-size: 18px;
            font-weight: 600;
            margin: 0;
        }

        .item-card-meta {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            font-size: 13px;
            color: var(--muted);
        }

        .item-body {
            border-top: 1px solid #1d2550;
            padding-top: 12px;
            display: grid;
            gap: 12px;
        }

        .item-form {
            display: grid;
            gap: 10px;
        }

        .item-form .row {
            display: grid;
            grid-template-columns: 120px 1fr;
            gap: 10px;
            align-items: center;
        }

        @media (max-width:600px) {
            .item-form .row {
                grid-template-columns: 1fr;
            }
        }

        .item-actions {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }

        .item-image-preview {
            display: flex;
            gap: 12px;
            align-items: flex-start;
        }

        .item-image-preview img {
            width: 96px;
            height: 96px;
            object-fit: cover;
            border-radius: 12px;
            border: 1px solid #23306a;
            background: #0a1232;
        }

        .item-image-meta {
            display: grid;
            gap: 6px;
        }

        .terrain-empty {
            font-size: 12px;
            color: var(--muted);
        }

        .card .title {
            font-weight: 600
        }

        .kvs {
            display: grid;
            grid-template-columns: 100px 1fr;
            gap: 6px;
            font-size: 13px;
            color: #cfd8ff
        }

        .kvs div:nth-child(odd) {
            color: #91a2ff
        }

        .pill {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            border: 1px solid #2a3a80;
            background: #121a3f;
            border-radius: 999px;
            padding: 6px 9px
        }

        .small {
            font-size: 12px;
            color: var(--muted)
        }

        canvas {
            background: #0a1130;
            border: 1px dashed #32408b;
            border-radius: 10px;
            max-width: 100%;
            touch-action: none
        }

        .toolbar {
            display: flex;
            gap: 8px;
            flex-wrap: wrap
        }

        .note {
            font-size: 12px;
            color: #9fb4ff
        }

        .footer {
            margin-top: 16px;
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            align-items: center
        }
    </style>
</head>

<body>
    <header>
        <div class="bar">
            <h1>Game Asset CMS</h1>
            <div class="tag">Items / Animals (Animations) / Entities (Hitboxes) / Terrains – 本機儲存、可匯入匯出</div>
            <div style="flex:1"></div>
            <button class="btn secondary" id="btnReset">重置</button>
            <label class="btn secondary" for="importJson">匯入 JSON</label>
            <input id="importJson" type="file" accept="application/json" style="display:none" />
            <button class="btn" id="btnExport">匯出 JSON</button>
        </div>
    </header>

    <div class="wrap">
        <div class="tabs" id="tabs"></div>

        <!-- Terrains -->
        <section class="panel" data-tab="terrains">
            <div class="head">
                <h2>Terrains 地形管理</h2>
            </div>
            <div class="body">
                <div class="grid">
                    <div>
                        <div class="row"><label>名稱</label><input id="tName" type="text" placeholder="例：草地" /></div>
                        <div class="row"><label>Tag</label><input id="tTag" type="text"
                                placeholder="例：walkable / slippery / lava" /></div>
                        <div class="row"><label>圖片</label><input id="tImages" type="file" accept="image/*" multiple />
                        </div>
                        <div class="row"><button id="addTerrain" class="btn">新增地形</button></div>
                    </div>
                    <div>
                        <div class="list" id="terrainList"></div>
                    </div>
                </div>
            </div>
        </section>

        <!-- Items -->
        <section class="panel" data-tab="items">
            <div class="head">
                <h2>Items 物品 → 可放置地形</h2>
            </div>
            <div class="body">
                <div class="grid">
                    <div>
                        <div class="list" id="itemList"></div>
                    </div>
                    <div>
                        <div class="row">
                            <label>名稱</label>
                            <input id="iName" type="text" placeholder="紅寶石礦 / 木箱 / 陷阱" />
                        </div>
                        <div class="row">
                            <label>分類</label>
                            <select id="iCategory"></select>
                        </div>
                        <div class="row">
                            <label>圖片</label>
                            <input id="iIcon" type="file" accept="image/*" />
                        </div>
                        <div class="row">
                            <label>適用地形</label>
                            <div id="iTerrainChecks" class="checklist"></div>
                        </div>
                        <div class="row">
                            <label>備註</label>
                            <textarea id="iNote" placeholder="限制、互動規則等…"></textarea>
                        </div>
                        <div class="row item-drop-row">
                            <label>掉落設定</label>
                            <div id="iDropEditor" class="drop-editor-wrap"></div>
                        </div>
                        <div class="row creature-row" id="iCreatureFields">
                            <label>生物設定</label>
                            <div class="creature-editor-host" id="iCreatureEditorHost"></div>
                        </div>
                        <div class="row">
                            <button id="addItem" class="btn">新增物品</button>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <!-- Animals -->
        <section class="panel" data-tab="animals">
            <div class="head">
                <h2>Animals 動物 → 動畫列表</h2>
            </div>
            <div class="body">
                <div class="grid">
                    <div>
                        <div class="row">
                            <label>名稱</label>
                            <input id="aName" type="text" placeholder="小安德 / 史萊姆" />
                        </div>
                        <div class="row">
                            <label>預覽圖</label>
                            <div class="file-input-wrap">
                                <input id="aPreview" type="file" accept="image/*" />
                                <div class="preview-thumb-wrap">
                                    <img id="aPreviewThumb" class="preview-thumb" alt="預覽圖" style="display:none" />
                                    <button id="clearPreview" class="ghost-btn danger" type="button">移除預覽圖</button>
                                </div>
                            </div>
                        </div>
                        <div class="clip-section">
                            <div class="clip-section-head">
                                <div class="clip-section-title">動畫編輯</div>
                                <div class="clip-section-status" id="clipEditorStatus">新增動畫草稿</div>
                            </div>
                            <div class="row">
                                <label>動畫名稱</label>
                                <input id="clipName" type="text" placeholder="idle / walk / attack" />
                            </div>
                            <div class="row">
                                <label>FPS</label>
                                <input id="clipFps" type="number" value="6" min="1" max="60" />
                            </div>
                            <div class="row">
                                <label>動畫幀圖片</label>
                                <div class="file-input-wrap">
                                    <input id="clipFrames" type="file" accept="image/*" multiple />
                                    <label class="form-inline-check">
                                        <input id="clipFrameAppend" type="checkbox" />
                                        加到現有幀
                                    </label>
                                </div>
                            </div>
                            <div class="row">
                                <label>各幀秒數</label>
                                <div id="clipFrameList" class="frame-duration-list">
                                    <div class="frame-duration-empty">尚未選擇圖片</div>
                                </div>
                            </div>
                            <div class="toolbar clip-toolbar">
                                <button id="newClip" class="btn secondary" type="button">新增空白動畫</button>
                                <button id="addClip" class="btn" type="button">儲存動畫</button>
                            </div>
                        </div>
                        <div class="clip-drafts">
                            <div class="clip-drafts-header">
                                <div class="clip-drafts-title">此動物的動畫列表</div>
                                <div class="clip-drafts-meta">可在此調整順序或刪除動畫</div>
                            </div>
                            <div id="clipDraftList" class="clip-list"></div>
                        </div>
                        <div class="row">
                            <label>生成地形</label>
                            <div id="aTerrainChecks"></div>
                        </div>
                        <div class="toolbar animal-toolbar">
                            <button id="addAnimal" class="btn" type="button">儲存動物</button>
                            <button id="resetAnimal" class="btn secondary" type="button">清空表單</button>
                        </div>
                        <div class="note" id="animalEditorStatus">目前為新增模式</div>
                        <div class="note">提示：建立或編輯動畫後，記得儲存動物即可同步更新列表。</div>
                    </div>
                    <div>
                        <div class="list" id="animalList"></div>
                        <div class="panel" style="margin-top:12px">
                            <div class="head">
                                <h2>動畫即時預覽</h2>
                            </div>
                            <div class="body">
                                <canvas id="animCanvas" width="320" height="240"></canvas>
                                <div class="row">
                                    <label>選擇動物</label>
                                    <select id="previewAnimal"></select>
                                </div>
                                <div class="row">
                                    <label>選擇動畫</label>
                                    <select id="previewClip"></select>
                                </div>
                                <div class="row">
                                    <label>速度倍率</label>
                                    <input id="previewSpeed" type="number" value="1" step="0.1" min="0.1" />
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <!-- Entities / Hitboxes -->
        <section class="panel" data-tab="entities">
            <div class="head">
                <h2>Entities 生物 → 碰撞箱（矩形）</h2>
            </div>
            <div class="body">
                <div class="grid">
                    <div>
                        <div class="row"><label>來源</label><select id="eSource"></select></div>
                        <div class="row"><label>名稱</label><input id="eName" type="text" placeholder="敵人或可互動物件名稱" />
                        </div>
                        <div class="row"><label>底圖</label><input id="eImage" type="file" accept="image/*" /></div>
                        <div class="toolbar">
                            <span class="pill">Shift+左鍵拖曳：新增碰撞箱</span>
                            <span class="pill">右鍵：刪除此框</span>
                            <span class="pill">拖曳角落：縮放</span>
                            <button id="clearHitboxes" class="btn danger">清空所有框</button>
                            <button id="saveEntity" class="btn">新增/更新 生物</button>
                        </div>
                        <canvas id="hitCanvas" width="420" height="320"></canvas>
                        <div class="small">儲存為 0..1 正規化座標（與圖片無關比例，可安全匯出到遊戲）</div>
                    </div>
                    <div>
                        <div class="list" id="entityList"></div>
                        <div class="panel" style="margin-top:12px">
                            <div class="head">
                                <h2>目前碰撞框</h2>
                            </div>
                            <div class="body" id="hitList"></div>
                        </div>
                    </div>
                </div>
            </div>
        </section>
    </div>

    <template id="tpl-card">
        <div class="card">
            <img />
            <div class="card-body" style="flex:1">
                <div class="title"></div>
                <div class="kvs"></div>
            </div>
            <div class="card-actions">
                <button class="btn secondary edit">編輯</button>
                <button class="btn danger del">刪除</button>
            </div>
        </div>
    </template>

    <script>
        // ----------------------------- Data Types -----------------------------
        const LS_KEY = 'asset-cms-v1';
        const uid = () => Math.random().toString(36).slice(2, 9);
        const terrainApiUrl = 'terrain_api.php';
        const itemApiUrl = 'item_api.php';
        let pendingOpenItemId = null;
        let pendingOpenCategoryId = null;
        let selectedItemId = null;
        let selectedCategoryId = null;
        let editingAnimalTerrains = new Set();
        const defaultItemCategories = [
            { id: 'decor', label: '裝飾' },
            { id: 'interactive', label: '可互動' },
            { id: 'building', label: '建材' },
            { id: 'drop', label: '掉落物' },
            { id: 'resource', label: '素材' },
            { id: 'consumable', label: '消耗品' },
            { id: 'crop', label: '農作物' },
            { id: 'mineral', label: '礦物' },
            { id: 'tree', label: '樹木' },
            { id: 'animal', label: '生物' }
        ];

        const emptyProject = () => ({
            meta: { name: 'My Game Assets', version: '1.0.0', updatedAt: new Date().toISOString() },
            terrains: [
                { id: 'grass', name: '草地', tag: 'walkable' },
                { id: 'sand', name: '沙地', tag: 'walkable' },
                { id: 'snow', name: '雪地', tag: 'slippery' },
                { id: 'stone', name: '岩地', tag: 'walkable' },
                { id: 'water', name: '水域', tag: 'swim' },
            ],
            itemCategories: defaultItemCategories.slice(),
            items: [],
            animals: [],
            entities: [],
        });

        let project = JSON.parse(localStorage.getItem(LS_KEY) || 'null') || emptyProject();
        if (!Array.isArray(project.itemCategories) || project.itemCategories.length === 0) {
            project.itemCategories = defaultItemCategories.slice();
        }
        if (!Array.isArray(project.items)) {
            project.items = [];
        }
        if (!Array.isArray(project.animals)) {
            project.animals = [];
        }
        upgradeAnimalClips();
        const saveProject = () => { project.meta.updatedAt = new Date().toISOString(); localStorage.setItem(LS_KEY, JSON.stringify(project)); renderAll(); };

        // ----------------------------- Tabs -----------------------------
        const tabsEl = document.getElementById('tabs');
        const sections = Array.from(document.querySelectorAll('[data-tab]'));
        const tabNames = ['terrains', 'items', 'animals', 'entities'];
        let currentTab = localStorage.getItem('asset-cms-tab') || 'terrains';
        const switchTab = (name) => {
            currentTab = name; localStorage.setItem('asset-cms-tab', name);
            sections.forEach(sec => sec.style.display = sec.getAttribute('data-tab') === name ? 'block' : 'none');
            Array.from(tabsEl.children).forEach(btn => btn.classList.toggle('active', btn.dataset.name === name));
        };
        tabNames.forEach(n => {
            const b = document.createElement('button'); b.className = 'tab-btn'; b.dataset.name = n; b.textContent = n.toUpperCase(); b.onclick = () => switchTab(n); tabsEl.appendChild(b);
        });

        // ----------------------------- Terrains -----------------------------
        const tName = document.getElementById('tName');
        const tTag = document.getElementById('tTag');
        const tImages = document.getElementById('tImages');
        const addTerrain = document.getElementById('addTerrain');
        const terrainList = document.getElementById('terrainList');

        addTerrain.onclick = async () => {
            const name = tName.value.trim();
            if (!name) return alert('請輸入名稱');
            const originalText = addTerrain.textContent;
            const tag = tTag.value.trim();
            const files = Array.from(tImages.files || []);
            const formData = new FormData();
            formData.append('action', 'create');
            formData.append('name', name);
            formData.append('tag', tag);
            files.forEach(file => formData.append('images[]', file));
            addTerrain.disabled = true;
            addTerrain.textContent = '儲存中...';
            try {
                const res = await fetch(terrainApiUrl, { method: 'POST', body: formData });
                const data = await res.json();
                if (!res.ok || data.status !== 'ok') {
                    throw new Error(data.message || '新增地形失敗');
                }
                project.terrains = Array.isArray(data.terrains) ? data.terrains : [];
                tName.value = '';
                tTag.value = '';
                tImages.value = '';
                saveProject();
            } catch (err) {
                console.error('Failed to create terrain', err);
                alert('新增地形失敗：' + (err.message || '發生未知錯誤'));
            } finally {
                addTerrain.disabled = false;
                addTerrain.textContent = originalText;
            }
        };

        function renderTerrains() {
            const previouslyOpen = new Set(Array.from(terrainList.querySelectorAll('.terrain-item[open]')).map(el => el.dataset.terrainId));
            terrainList.innerHTML = '';
            (project.terrains || []).forEach(tr => {
                const tagText = tr.tag || '-';
                const images = Array.isArray(tr.images) ? tr.images : [];
                const imageCount = images.length;

                const details = document.createElement('details');
                details.className = 'terrain-item';
                details.dataset.terrainId = tr.id;
                if (previouslyOpen.has(tr.id)) details.open = true;

                const summary = document.createElement('summary');
                summary.className = 'terrain-summary';
                summary.innerHTML = `
                    <div class="title-wrap">
                        <span class="title">${tr.name}</span>
                        <span class="pill">Tag: ${tagText}</span>
                    </div>
                    <div class="meta">
                        <span>ID: ${tr.id}</span>
                        <span>圖片 ${imageCount} 張</span>
                    </div>`;
                details.appendChild(summary);

                const body = document.createElement('div');
                body.className = 'terrain-body';

                // Editable form for name/tag
                const form = document.createElement('div');
                form.className = 'terrain-form';

                const nameRow = document.createElement('div'); nameRow.className = 'row';
                const nameLabel = document.createElement('label'); nameLabel.textContent = '名稱';
                const nameInput = document.createElement('input'); nameInput.type = 'text'; nameInput.value = tr.name;
                nameRow.appendChild(nameLabel); nameRow.appendChild(nameInput);

                const tagRow = document.createElement('div'); tagRow.className = 'row';
                const tagLabel = document.createElement('label'); tagLabel.textContent = 'Tag';
                const tagInput = document.createElement('input'); tagInput.type = 'text'; tagInput.value = tr.tag || '';
                tagRow.appendChild(tagLabel); tagRow.appendChild(tagInput);

                form.appendChild(nameRow);
                form.appendChild(tagRow);

                const formActions = document.createElement('div'); formActions.className = 'terrain-actions';
                const saveBtn = document.createElement('button'); saveBtn.className = 'btn'; saveBtn.textContent = '儲存變更';
                const addImageBtn = document.createElement('button'); addImageBtn.className = 'btn secondary'; addImageBtn.textContent = '新增圖片';
                const deleteBtn = document.createElement('button'); deleteBtn.className = 'btn danger'; deleteBtn.textContent = '刪除此地形';
                formActions.append(saveBtn, addImageBtn, deleteBtn);
                form.appendChild(formActions);

                body.appendChild(form);

                // Image gallery
                if (imageCount === 0) {
                    const empty = document.createElement('div');
                    empty.className = 'terrain-empty';
                    empty.textContent = '尚未上傳圖片';
                    body.appendChild(empty);
                } else {
                    const imagesContainer = document.createElement('div');
                    imagesContainer.className = 'terrain-images';
                    images.forEach(img => {
                        if (!img || !img.path) return;
                        const card = document.createElement('div');
                        card.className = 'terrain-image-card';

                        const link = document.createElement('a');
                        link.href = img.path;
                        link.target = '_blank';
                        const imageEl = document.createElement('img');
                        imageEl.src = img.path;
                        imageEl.alt = `${tr.name} 圖片`;
                        link.appendChild(imageEl);
                        card.appendChild(link);

                        const info = document.createElement('div');
                        info.className = 'terrain-image-info';
                        const labelInput = document.createElement('input');
                        labelInput.type = 'text';
                        labelInput.value = (img.label && img.label.trim()) || (img.filename ? img.filename.replace(/\.[^/.]+$/, '') : '');
                        labelInput.placeholder = '顯示名稱';
                        info.appendChild(labelInput);

                        const renameToggle = document.createElement('label');
                        renameToggle.className = 'terrain-image-toggle';
                        const renameCheckbox = document.createElement('input');
                        renameCheckbox.type = 'checkbox';
                        renameToggle.appendChild(renameCheckbox);
                        renameToggle.append(' 同步修改檔案名稱');
                        info.appendChild(renameToggle);

                        const meta = document.createElement('div');
                        meta.className = 'meta';
                        const uploadedAt = img.uploadedAt ? new Date(img.uploadedAt).toLocaleString() : '';
                        meta.textContent = `檔案: ${img.filename || '未知'}${uploadedAt ? `｜上傳：${uploadedAt}` : ''}`;
                        info.appendChild(meta);

                        const imgActions = document.createElement('div');
                        imgActions.className = 'terrain-image-actions';
                        const renameBtn = document.createElement('button');
                        renameBtn.className = 'btn secondary';
                        renameBtn.textContent = '更新名稱';
                        const removeBtn = document.createElement('button');
                        removeBtn.className = 'btn danger';
                        removeBtn.textContent = '刪除此圖片';
                        imgActions.append(renameBtn, removeBtn);
                        info.appendChild(imgActions);

                        card.appendChild(info);
                        imagesContainer.appendChild(card);

                        renameBtn.onclick = async (e) => {
                            e.preventDefault();
                            const newLabel = labelInput.value.trim();
                            if (newLabel === '') {
                                return alert('名稱不可為空');
                            }
                            const original = renameBtn.textContent;
                            renameBtn.disabled = true;
                            renameBtn.textContent = '更新中...';
                            const formData = new FormData();
                            formData.append('action', 'update');
                            formData.append('id', tr.id);
                            formData.append('name', nameInput.value.trim() || tr.name);
                            formData.append('tag', tagInput.value.trim());
                            formData.append('renameImages', JSON.stringify([
                                { filename: img.filename, label: newLabel, renameFile: renameCheckbox.checked }
                            ]));
                            try {
                                const res = await fetch(terrainApiUrl, { method: 'POST', body: formData });
                                const data = await res.json();
                                if (!res.ok || data.status !== 'ok') throw new Error(data.message || '更新失敗');
                                project.terrains = Array.isArray(data.terrains) ? data.terrains : [];
                                saveProject();
                            } catch (err) {
                                console.error('Failed to rename image', err);
                                alert('更新圖片名稱失敗：' + (err.message || '未知錯誤'));
                            } finally {
                                renameBtn.disabled = false;
                                renameBtn.textContent = original;
                            }
                        };

                        removeBtn.onclick = async (e) => {
                            e.preventDefault();
                            if (!confirm('確定刪除此圖片？檔案將被移除。')) return;
                            const original = removeBtn.textContent;
                            removeBtn.disabled = true;
                            removeBtn.textContent = '刪除中...';
                            const formData = new FormData();
                            formData.append('action', 'update');
                            formData.append('id', tr.id);
                            formData.append('name', nameInput.value.trim() || tr.name);
                            formData.append('tag', tagInput.value.trim());
                            formData.append('removeImages', JSON.stringify([img.filename]));
                            try {
                                const res = await fetch(terrainApiUrl, { method: 'POST', body: formData });
                                const data = await res.json();
                                if (!res.ok || data.status !== 'ok') throw new Error(data.message || '刪除失敗');
                                project.terrains = Array.isArray(data.terrains) ? data.terrains : [];
                                saveProject();
                            } catch (err) {
                                console.error('Failed to delete image', err);
                                alert('刪除圖片失敗：' + (err.message || '未知錯誤'));
                            } finally {
                                removeBtn.disabled = false;
                                removeBtn.textContent = original;
                            }
                        };
                    });
                    body.appendChild(imagesContainer);
                }

                details.appendChild(body);

                // Button behaviors
                saveBtn.onclick = async (e) => {
                    e.preventDefault();
                    const newName = nameInput.value.trim();
                    if (newName === '') return alert('地形名稱不可為空');
                    const original = saveBtn.textContent;
                    saveBtn.disabled = true;
                    saveBtn.textContent = '儲存中...';
                    const formData = new FormData();
                    formData.append('action', 'update');
                    formData.append('id', tr.id);
                    formData.append('name', newName);
                    formData.append('tag', tagInput.value.trim());
                    try {
                        const res = await fetch(terrainApiUrl, { method: 'POST', body: formData });
                        const data = await res.json();
                        if (!res.ok || data.status !== 'ok') throw new Error(data.message || '儲存失敗');
                        project.terrains = Array.isArray(data.terrains) ? data.terrains : [];
                        saveProject();
                    } catch (err) {
                        console.error('Failed to update terrain', err);
                        alert('更新地形失敗：' + (err.message || '發生未知錯誤'));
                    } finally {
                        saveBtn.disabled = false;
                        saveBtn.textContent = original;
                    }
                };

                addImageBtn.onclick = () => {
                    const input = document.createElement('input');
                    input.type = 'file';
                    input.accept = 'image/*';
                    input.multiple = true;
                    input.onchange = async () => {
                        const files = Array.from(input.files || []);
                        if (files.length === 0) return;
                        const original = addImageBtn.textContent;
                        addImageBtn.disabled = true;
                        addImageBtn.textContent = '上傳中...';
                        const formData = new FormData();
                        formData.append('action', 'update');
                        formData.append('id', tr.id);
                        formData.append('name', nameInput.value.trim() || tr.name);
                        formData.append('tag', tagInput.value.trim());
                        files.forEach(file => formData.append('images[]', file));
                        try {
                            const res = await fetch(terrainApiUrl, { method: 'POST', body: formData });
                            const data = await res.json();
                            if (!res.ok || data.status !== 'ok') throw new Error(data.message || '新增圖片失敗');
                            project.terrains = Array.isArray(data.terrains) ? data.terrains : [];
                            saveProject();
                            details.open = true;
                        } catch (err) {
                            console.error('Failed to append images', err);
                            alert('新增圖片失敗：' + (err.message || '發生未知錯誤'));
                        } finally {
                            addImageBtn.disabled = false;
                            addImageBtn.textContent = original;
                            input.value = '';
                        }
                    };
                    input.click();
                };

                deleteBtn.onclick = async (e) => {
                    e.preventDefault();
                    if (!confirm('刪除此地形？已綁定的 Items / Animals 會保留其 ID。')) return;
                    const original = deleteBtn.textContent;
                    deleteBtn.disabled = true;
                    deleteBtn.textContent = '刪除中...';
                    const formData = new FormData();
                    formData.append('action', 'delete');
                    formData.append('id', tr.id);
                    try {
                        const res = await fetch(terrainApiUrl, { method: 'POST', body: formData });
                        const data = await res.json();
                        if (!res.ok || data.status !== 'ok') throw new Error(data.message || '刪除地形失敗');
                        project.terrains = Array.isArray(data.terrains) ? data.terrains : [];
                        (project.items || []).forEach(it => {
                            if (!Array.isArray(it.terrains)) return;
                            it.terrains = it.terrains.filter(id => id !== tr.id);
                        });
                        (project.animals || []).forEach(an => {
                            if (!Array.isArray(an.spawnTerrains)) return;
                            an.spawnTerrains = an.spawnTerrains.filter(id => id !== tr.id);
                        });
                        saveProject();
                    } catch (err) {
                        console.error('Failed to delete terrain', err);
                        alert('刪除地形失敗：' + (err.message || '發生未知錯誤'));
                    } finally {
                        deleteBtn.disabled = false;
                        deleteBtn.textContent = original;
                    }
                };

                terrainList.appendChild(details);
            });
            renderItemTerrainChecks();
            renderAnimalTerrainChecks();
        }

        function populateTerrainChecklist(container, selected = []) {
            container.innerHTML = '';
            const selectedSet = new Set(selected);
            (project.terrains || []).forEach(tr => {
                const label = document.createElement('label');
                const ck = document.createElement('input');
                ck.type = 'checkbox';
                ck.dataset.tid = tr.id;
                ck.checked = selectedSet.has(tr.id);
                label.appendChild(ck);
                label.append(' ' + tr.name);
                container.appendChild(label);
            });
        }

        function renderItemTerrainChecks() {
            const wrap = document.getElementById('iTerrainChecks');
            populateTerrainChecklist(wrap, []);
        }

        function renderAnimalTerrainChecks() {
            const wrap = document.getElementById('aTerrainChecks');
            if (!wrap) return;
            wrap.innerHTML = '';
            const selectedSet = editingAnimalTerrains instanceof Set ? editingAnimalTerrains : new Set();
            (project.terrains || []).forEach(tr => {
                const label = document.createElement('label');
                label.className = 'terrain-chip';
                const ck = document.createElement('input');
                ck.type = 'checkbox';
                ck.dataset.tid = tr.id;
                ck.checked = selectedSet.has(tr.id);
                ck.onchange = () => {
                    if (ck.checked) selectedSet.add(tr.id);
                    else selectedSet.delete(tr.id);
                };
                const span = document.createElement('span');
                span.textContent = tr.name;
                label.append(ck, span);
                wrap.appendChild(label);
            });
        }

        async function syncTerrainsFromServer() {
            try {
                const res = await fetch(`${terrainApiUrl}?_=${Date.now()}`);
                if (!res.ok) throw new Error('網路錯誤');
                const data = await res.json();
                if (data.status !== 'ok' || !Array.isArray(data.terrains)) {
                    throw new Error(data.message || '資料格式錯誤');
                }
                project.terrains = data.terrains;
                saveProject();
            } catch (err) {
                console.warn('同步地形資料失敗', err);
            }
        }

        async function syncItemsFromServer() {
            try {
                const res = await fetch(`${itemApiUrl}?_=${Date.now()}`);
                if (!res.ok) throw new Error('網路錯誤');
                const data = await res.json();
                if (data.status !== 'ok' || !Array.isArray(data.items)) {
                    throw new Error(data.message || '資料格式錯誤');
                }
                updateItemsState(data.items, data.categories);
            } catch (err) {
                console.warn('同步物品資料失敗', err);
            }
        }

        // ----------------------------- Items -----------------------------
        const iName = document.getElementById('iName');
        const iCategory = document.getElementById('iCategory');
        const iIcon = document.getElementById('iIcon');
        const iNote = document.getElementById('iNote');
        const addItem = document.getElementById('addItem');
        const itemList = document.getElementById('itemList');

        async function fileToDataUrl(file) {
            return await new Promise((res, rej) => { const r = new FileReader(); r.onload = () => res(String(r.result)); r.onerror = rej; r.readAsDataURL(file); });
        }

        function ensureItemCategories(categories) {
            if (Array.isArray(categories) && categories.length > 0) {
                project.itemCategories = categories;
            } else if (!Array.isArray(project.itemCategories) || project.itemCategories.length === 0) {
                project.itemCategories = defaultItemCategories.slice();
            }
        }

        const creatureDispositionLabels = {
            friendly: '友善',
            neutral: '中立',
            hostile: '敵對'
        };

        function parseBooleanLike(value) {
            if (typeof value === 'boolean') return value;
            if (typeof value === 'string') {
                const normalized = value.trim().toLowerCase();
                if (['true', '1', 'yes', 'y', 'on'].includes(normalized)) return true;
                if (['false', '0', 'no', 'n', 'off', ''].includes(normalized)) return false;
            }
            if (typeof value === 'number') {
                return value !== 0;
            }
            return false;
        }

        function sanitizeCreatureData(raw) {
            const allowed = Object.keys(creatureDispositionLabels);
            const source = raw && typeof raw === 'object' ? raw : {};
            let disposition = '';
            if (typeof source.disposition === 'string') {
                disposition = source.disposition.trim().toLowerCase();
            }
            if (!allowed.includes(disposition)) disposition = 'neutral';

            const animations = Array.isArray(source.animations) ? source.animations.map(anim => {
                if (!anim || typeof anim !== 'object') return null;
                const animalId = (anim.animalId ?? '').toString().trim();
                const clipName = (anim.clipName ?? '').toString().trim();
                let triggerChance = Number(anim.triggerChance);
                if (!Number.isFinite(triggerChance)) triggerChance = 1;
                triggerChance = Math.max(0, Math.min(1, triggerChance));
                const isIdle = parseBooleanLike(anim.isIdle);
                if (!animalId && !clipName) return null;
                return { animalId, clipName, triggerChance, isIdle };
            }).filter(Boolean) : [];

            const skills = Array.isArray(source.skills) ? source.skills.map(skill => {
                if (!skill || typeof skill !== 'object') return null;
                const name = (skill.name ?? '').toString().trim();
                const description = (skill.description ?? '').toString().trim();
                if (!name && !description) return null;
                return { name, description };
            }).filter(Boolean) : [];

            return { disposition, animations, skills };
        }

        function formatCreatureSummary(creature) {
            if (!creature || typeof creature !== 'object') return '—';
            const data = sanitizeCreatureData(creature);
            const parts = [];
            const dispositionLabel = creatureDispositionLabels[data.disposition] || creatureDispositionLabels.neutral;
            if (dispositionLabel) parts.push(`態度：${dispositionLabel}`);
            parts.push(`動畫 ${data.animations.length} 個`);
            parts.push(`技能 ${data.skills.length} 個`);
            const idleAnim = data.animations.find(anim => anim.isIdle);
            if (idleAnim) {
                const idleName = idleAnim.clipName || idleAnim.animalId || '';
                if (idleName) parts.push(`閒置：${idleName}`);
            }
            return parts.filter(Boolean).join('｜') || '—';
        }

        function updateItemsState(items, categories) {
            if (Array.isArray(items)) {
                project.items = items.map(it => {
                    if (it && typeof it === 'object' && String(it.categoryId || '') === 'animal') {
                        return { ...it, creature: sanitizeCreatureData(it.creature) };
                    }
                    return it;
                });
            } else {
                project.items = [];
            }
            ensureItemCategories(categories);
            saveProject();
        }

        function renderItemCategoryOptions() {
            if (!iCategory) return;
            const current = iCategory.value;
            iCategory.innerHTML = '';
            ensureItemCategories(project.itemCategories);
            (project.itemCategories || []).forEach(cat => {
                const opt = document.createElement('option');
                opt.value = cat.id;
                opt.textContent = cat.label;
                iCategory.appendChild(opt);
            });
            if (current && Array.from(iCategory.options).some(opt => opt.value === current)) {
                iCategory.value = current;
            } else if (iCategory.options.length > 0 && !iCategory.value) {
                iCategory.value = iCategory.options[0].value;
            }
            updateCreateCreatureVisibility();
        }

        const dropLabelFallback = {
            entity: '動畫生物',
            material: '素材',
            weapon: '武器',
            armor: '防具',
            decor: '裝飾',
            interactive: '可互動',
            building: '建材',
            resource: '素材',
            consumable: '消耗品',
            crop: '農作物',
            mineral: '礦物',
            tree: '樹木',
            animal: '生物'
        };

        function getDropSourceOptions() {
            ensureItemCategories(project.itemCategories);
            const options = [];
            const seen = new Set();
            const add = (id, label) => {
                if (!id || seen.has(id)) return;
                seen.add(id);
                options.push({ id, label: label || dropLabelFallback[id] || id });
            };
            add('entity', dropLabelFallback.entity);
            (project.itemCategories || []).forEach(cat => {
                if (!cat || !cat.id || cat.id === 'drop') return;
                add(cat.id, cat.label || cat.name || dropLabelFallback[cat.id] || cat.id);
            });
            ['material', 'weapon', 'armor'].forEach(id => add(id, dropLabelFallback[id]));
            return options;
        }

        function formatDropSummary(drops, sourceOptions = getDropSourceOptions()) {
            if (!Array.isArray(drops) || drops.length === 0) return '—';
            const labelMap = new Map((sourceOptions || []).map(opt => [opt.id, opt.label]));
            return drops.map(d => {
                const chanceNum = Math.max(0, Math.min(1, Number(d?.chance ?? 0)));
                const chance = Math.round(chanceNum * 100);
                let min = parseInt(d?.min ?? 0, 10);
                if (!Number.isFinite(min) || isNaN(min) || min < 0) min = 0;
                let max = parseInt(d?.max ?? min, 10);
                if (!Number.isFinite(max) || isNaN(max) || max < min) max = min;
                const qty = min === max ? `${min}` : `${min}-${max}`;
                const type = (d?.sourceType ?? '').toString().trim();
                const label = type ? (labelMap.get(type) || dropLabelFallback[type] || type) : '';
                const sourceId = (d?.sourceId ?? '').toString().trim();
                const sourceText = type ? `${label}${sourceId ? `:${sourceId}` : ''}` : '';
                return `${chance}% × ${qty}${sourceText ? `（${sourceText}）` : ''}`;
            }).join('；');
        }

        function createDropEditor({ initialDrops = [], sourceOptions = [], addButtonLabel = '＋新增掉落規則', noteText = '機率 0–1；來源可為分類（不含掉落物）或實體 ID。', onChange } = {}) {
            let options = Array.isArray(sourceOptions) ? sourceOptions.map(opt => ({ ...opt })) : [];
            const container = document.createElement('div');
            container.className = 'drop-editor';
            const list = document.createElement('div');
            list.className = 'drop-list';
            const actions = document.createElement('div');
            actions.className = 'drop-actions';
            const addBtn = document.createElement('button');
            addBtn.type = 'button';
            addBtn.className = 'btn-add-drop';
            addBtn.textContent = addButtonLabel;
            const note = document.createElement('div');
            note.className = 'drop-note';
            note.textContent = noteText;
            actions.appendChild(addBtn);
            container.append(list, actions, note);

            const sanitize = (raw) => {
                const baseType = options.length > 0 ? options[0].id : 'entity';
                let chance = parseFloat(raw?.chance ?? 0);
                if (!Number.isFinite(chance)) chance = 0;
                chance = Math.max(0, Math.min(1, chance));
                let min = parseInt(raw?.min ?? 0, 10);
                if (!Number.isFinite(min) || isNaN(min) || min < 0) min = 0;
                let max = parseInt(raw?.max ?? min, 10);
                if (!Number.isFinite(max) || isNaN(max) || max < min) max = min;
                let sourceType = (raw?.sourceType ?? '').toString().trim();
                if (sourceType === '') sourceType = baseType;
                const sourceId = (raw?.sourceId ?? '').toString().trim();
                return { chance, min, max, sourceType, sourceId };
            };

            let drops = Array.isArray(initialDrops) ? initialDrops.map(sanitize) : [];
            const getDropsSnapshot = () => drops.map(sanitize);

            function buildOptionElements(select, value) {
                select.innerHTML = '';
                options.forEach(opt => {
                    const option = document.createElement('option');
                    option.value = opt.id;
                    option.textContent = opt.label;
                    select.appendChild(option);
                });
                if (value && !options.some(opt => opt.id === value)) {
                    const option = document.createElement('option');
                    option.value = value;
                    option.textContent = value;
                    select.appendChild(option);
                }
                select.value = value || (options[0]?.id ?? '');
            }

            function triggerChange() {
                if (typeof onChange === 'function') {
                    onChange(getDropsSnapshot());
                }
            }

            function render() {
                list.innerHTML = '';
                if (drops.length === 0) {
                    const empty = document.createElement('div');
                    empty.className = 'drop-empty';
                    empty.textContent = '尚未設定掉落規則';
                    list.appendChild(empty);
                    return;
                }
                drops.forEach((drop, idx) => {
                    const row = document.createElement('div');
                    row.className = 'drop-row';
                    row.dataset.idx = String(idx);

                    const chanceInput = document.createElement('input');
                    chanceInput.type = 'number';
                    chanceInput.step = '0.01';
                    chanceInput.min = '0';
                    chanceInput.max = '1';
                    chanceInput.value = String(drop.chance);

                    const minInput = document.createElement('input');
                    minInput.type = 'number';
                    minInput.step = '1';
                    minInput.min = '0';
                    minInput.value = String(drop.min);

                    const maxInput = document.createElement('input');
                    maxInput.type = 'number';
                    maxInput.step = '1';
                    maxInput.min = '0';
                    maxInput.value = String(drop.max);

                    const typeSelect = document.createElement('select');
                    buildOptionElements(typeSelect, drop.sourceType);

                    const idInput = document.createElement('input');
                    idInput.type = 'text';
                    idInput.placeholder = '來源 ID（例：forest_wolf / wheat）';
                    idInput.value = drop.sourceId;

                    const delBtn = document.createElement('button');
                    delBtn.type = 'button';
                    delBtn.textContent = '刪除';

                    chanceInput.addEventListener('change', () => {
                        const sanitized = sanitize({ ...drops[idx], chance: chanceInput.value });
                        drops[idx].chance = sanitized.chance;
                        chanceInput.value = String(drops[idx].chance);
                        triggerChange();
                    });

                    minInput.addEventListener('change', () => {
                        const sanitized = sanitize({ ...drops[idx], min: minInput.value });
                        drops[idx].min = sanitized.min;
                        if (drops[idx].max < drops[idx].min) {
                            drops[idx].max = drops[idx].min;
                            maxInput.value = String(drops[idx].max);
                        }
                        minInput.value = String(drops[idx].min);
                        triggerChange();
                    });

                    maxInput.addEventListener('change', () => {
                        const sanitized = sanitize({ ...drops[idx], max: maxInput.value });
                        drops[idx].max = sanitized.max < drops[idx].min ? drops[idx].min : sanitized.max;
                        maxInput.value = String(drops[idx].max);
                        triggerChange();
                    });

                    typeSelect.addEventListener('change', () => {
                        drops[idx].sourceType = typeSelect.value;
                        triggerChange();
                    });

                    idInput.addEventListener('input', () => {
                        drops[idx].sourceId = idInput.value;
                    });

                    idInput.addEventListener('blur', () => {
                        drops[idx].sourceId = idInput.value.trim();
                        triggerChange();
                    });

                    delBtn.addEventListener('click', () => {
                        drops.splice(idx, 1);
                        render();
                        triggerChange();
                    });

                    row.append(chanceInput, minInput, maxInput, typeSelect, idInput, delBtn);
                    list.appendChild(row);
                });
            }

            addBtn.addEventListener('click', () => {
                const defaultType = options[0]?.id ?? 'entity';
                drops.push(sanitize({ chance: 1, min: 1, max: 1, sourceType: defaultType, sourceId: '' }));
                render();
                triggerChange();
            });

            render();

            return {
                element: container,
                getDrops() {
                    return getDropsSnapshot();
                },
                setDrops(newDrops) {
                    drops = Array.isArray(newDrops) ? newDrops.map(sanitize) : [];
                    render();
                    triggerChange();
                },
                setSourceOptions(newOptions) {
                    options = Array.isArray(newOptions) ? newOptions.map(opt => ({ ...opt })) : [];
                    drops = drops.map(drop => sanitize(drop));
                    render();
                }
            };
        }

        function createCreatureEditor({ initialValue = null, getAnimals = () => [], onChange } = {}) {
            let animalsProvider = typeof getAnimals === 'function' ? getAnimals : () => [];
            const toInternal = (input) => {
                const sanitized = sanitizeCreatureData(input || {});
                return {
                    disposition: sanitized.disposition,
                    animations: sanitized.animations.map(anim => ({ ...anim, uid: uid() })),
                    skills: sanitized.skills.map(skill => ({ ...skill, uid: uid() }))
                };
            };
            let value = toInternal(initialValue);

            function getValue() {
                const allowed = Object.keys(creatureDispositionLabels);
                const disposition = allowed.includes(value.disposition) ? value.disposition : 'neutral';
                const animations = value.animations.map(anim => {
                    const animalId = (anim.animalId ?? '').toString().trim();
                    const clipName = (anim.clipName ?? '').toString().trim();
                    let triggerChance = Number(anim.triggerChance);
                    if (!Number.isFinite(triggerChance)) triggerChance = 1;
                    triggerChance = Math.max(0, Math.min(1, triggerChance));
                    const isIdle = parseBooleanLike(anim.isIdle);
                    return { animalId, clipName, triggerChance, isIdle };
                }).filter(anim => anim.animalId || anim.clipName);
                const skills = value.skills.map(skill => {
                    const name = (skill.name ?? '').toString().trim();
                    const description = (skill.description ?? '').toString().trim();
                    return { name, description };
                }).filter(skill => skill.name || skill.description);
                return { disposition, animations, skills };
            }

            const emitChange = () => {
                if (typeof onChange === 'function') {
                    onChange(getValue());
                }
            };

            const container = document.createElement('div');
            container.className = 'creature-editor';

            const dispositionGroup = document.createElement('div');
            dispositionGroup.className = 'creature-group';
            const dispositionTitle = document.createElement('div');
            dispositionTitle.className = 'creature-group-title';
            dispositionTitle.textContent = '陣營 / 態度';
            const dispositionSelect = document.createElement('select');
            Object.entries(creatureDispositionLabels).forEach(([key, label]) => {
                const opt = document.createElement('option');
                opt.value = key;
                opt.textContent = label;
                dispositionSelect.appendChild(opt);
            });
            dispositionSelect.value = value.disposition;
            dispositionSelect.addEventListener('change', () => {
                value.disposition = dispositionSelect.value;
                emitChange();
            });
            const dispositionNote = document.createElement('div');
            dispositionNote.className = 'creature-note';
            dispositionNote.textContent = '決定生物對玩家的態度：友善、中立或敵對。';
            dispositionGroup.append(dispositionTitle, dispositionSelect, dispositionNote);
            container.appendChild(dispositionGroup);

            const animationsGroup = document.createElement('div');
            animationsGroup.className = 'creature-group';
            const animationsHeader = document.createElement('div');
            animationsHeader.className = 'creature-group-header';
            const animationsTitle = document.createElement('span');
            animationsTitle.className = 'creature-group-title';
            animationsTitle.textContent = '動畫';
            const animAddBtn = document.createElement('button');
            animAddBtn.type = 'button';
            animAddBtn.className = 'btn secondary';
            animAddBtn.textContent = '＋新增動畫';
            animationsHeader.append(animationsTitle, animAddBtn);
            const animList = document.createElement('div');
            animList.className = 'creature-list';
            const animationsNote = document.createElement('div');
            animationsNote.className = 'creature-note';
            animationsNote.textContent = '選擇動物 clip 並設定觸發機率（0–1）與閒置動畫。';
            animationsGroup.append(animationsHeader, animList, animationsNote);
            container.appendChild(animationsGroup);

            const skillsGroup = document.createElement('div');
            skillsGroup.className = 'creature-group';
            const skillsHeader = document.createElement('div');
            skillsHeader.className = 'creature-group-header';
            const skillsTitle = document.createElement('span');
            skillsTitle.className = 'creature-group-title';
            skillsTitle.textContent = '技能';
            const skillAddBtn = document.createElement('button');
            skillAddBtn.type = 'button';
            skillAddBtn.className = 'btn secondary';
            skillAddBtn.textContent = '＋新增技能';
            skillsHeader.append(skillsTitle, skillAddBtn);
            const skillList = document.createElement('div');
            skillList.className = 'creature-list';
            const skillsNote = document.createElement('div');
            skillsNote.className = 'creature-note';
            skillsNote.textContent = '記錄生物可用技能與效果說明。';
            skillsGroup.append(skillsHeader, skillList, skillsNote);
            container.appendChild(skillsGroup);

            const getAnimalsList = () => {
                const list = typeof animalsProvider === 'function' ? animalsProvider() : [];
                return Array.isArray(list) ? list : [];
            };

            function renderAnimations() {
                const animals = getAnimalsList();
                const hasClipOptions = animals.some(an => Array.isArray(an?.clips) && an.clips.some(clip => {
                    if (!clip) return false;
                    if (typeof clip === 'string') return clip.trim() !== '';
                    if (typeof clip === 'object') return String(clip.name || '').trim() !== '';
                    return false;
                }));
                animAddBtn.disabled = !hasClipOptions;
                animAddBtn.title = hasClipOptions ? '' : '請先在「動物」分頁建立動畫 clip';
                animList.innerHTML = '';
                if (value.animations.length === 0) {
                    const empty = document.createElement('div');
                    empty.className = 'creature-empty';
                    empty.textContent = hasClipOptions ? '尚未新增動畫。' : '尚無可用的動畫 clip，請先在「動物」分頁建立動畫。';
                    animList.appendChild(empty);
                }
                value.animations.forEach((anim, idx) => {
                    if (!anim.uid) anim.uid = uid();
                    const row = document.createElement('div');
                    row.className = 'creature-animation-row';

                    const animalWrap = document.createElement('div');
                    animalWrap.className = 'creature-inline';
                    const animalLabel = document.createElement('div');
                    animalLabel.className = 'creature-inline-label';
                    animalLabel.textContent = '動物';
                    const animalSelect = document.createElement('select');
                    animalWrap.append(animalLabel, animalSelect);
                    row.appendChild(animalWrap);

                    const clipWrap = document.createElement('div');
                    clipWrap.className = 'creature-inline';
                    const clipLabel = document.createElement('div');
                    clipLabel.className = 'creature-inline-label';
                    clipLabel.textContent = '動畫 clip';
                    const clipSelect = document.createElement('select');
                    clipWrap.append(clipLabel, clipSelect);
                    row.appendChild(clipWrap);

                    const chanceWrap = document.createElement('div');
                    chanceWrap.className = 'creature-inline small';
                    const chanceLabel = document.createElement('div');
                    chanceLabel.className = 'creature-inline-label';
                    chanceLabel.textContent = '觸發機率';
                    const chanceInput = document.createElement('input');
                    chanceInput.type = 'number';
                    chanceInput.min = '0';
                    chanceInput.max = '1';
                    chanceInput.step = '0.05';
                    chanceWrap.append(chanceLabel, chanceInput);
                    row.appendChild(chanceWrap);

                    const idleWrap = document.createElement('label');
                    idleWrap.className = 'creature-inline checkbox';
                    const idleCheckbox = document.createElement('input');
                    idleCheckbox.type = 'checkbox';
                    const idleText = document.createElement('span');
                    idleText.textContent = '閒置動畫';
                    idleWrap.append(idleCheckbox, idleText);
                    row.appendChild(idleWrap);

                    const removeBtn = document.createElement('button');
                    removeBtn.type = 'button';
                    removeBtn.className = 'btn danger';
                    removeBtn.textContent = '移除';
                    row.appendChild(removeBtn);

                    animList.appendChild(row);

                    const sortedAnimals = animals.slice().sort((a, b) => {
                        const an = (a?.name || a?.id || '').toString();
                        const bn = (b?.name || b?.id || '').toString();
                        return an.localeCompare(bn, 'zh-Hant');
                    });
                    const currentAnimalId = (anim.animalId ?? '').toString();
                    sortedAnimals.forEach(an => {
                        const opt = document.createElement('option');
                        const id = (an?.id ?? '').toString();
                        opt.value = id;
                        opt.textContent = (an?.name || id || '(未命名)');
                        animalSelect.appendChild(opt);
                    });
                    if (currentAnimalId && !sortedAnimals.some(an => (an?.id ?? '').toString() === currentAnimalId)) {
                        const opt = document.createElement('option');
                        opt.value = currentAnimalId;
                        opt.textContent = `${currentAnimalId}（已缺少）`;
                        animalSelect.appendChild(opt);
                    }
                    if (!currentAnimalId && sortedAnimals[0]) {
                        anim.animalId = (sortedAnimals[0]?.id ?? '').toString();
                    }
                    animalSelect.value = (anim.animalId ?? '').toString();
                    animalSelect.disabled = sortedAnimals.length === 0;

                    const refreshClipOptions = () => {
                        const animalsLatest = getAnimalsList();
                        const currentAnimal = animalsLatest.find(a => (a?.id ?? '').toString() === (anim.animalId ?? '').toString());
                        const clipNames = Array.isArray(currentAnimal?.clips) ? currentAnimal.clips.map(clip => {
                            if (!clip) return '';
                            if (typeof clip === 'string') return clip;
                            if (typeof clip === 'object') return String(clip.name || '');
                            return '';
                        }).filter(name => name.trim() !== '') : [];
                        clipSelect.innerHTML = '';
                        if (clipNames.length === 0) {
                            const opt = document.createElement('option');
                            opt.value = '';
                            opt.textContent = '（無可用 clip）';
                            clipSelect.appendChild(opt);
                            clipSelect.disabled = true;
                            if (!clipNames.includes(anim.clipName)) {
                                anim.clipName = '';
                            }
                        } else {
                            clipNames.forEach(name => {
                                const opt = document.createElement('option');
                                opt.value = name;
                                opt.textContent = name;
                                clipSelect.appendChild(opt);
                            });
                            if (anim.clipName && !clipNames.includes(anim.clipName)) {
                                const opt = document.createElement('option');
                                opt.value = anim.clipName;
                                opt.textContent = `${anim.clipName}（已缺少）`;
                                clipSelect.appendChild(opt);
                            }
                            clipSelect.disabled = false;
                        }
                        const desired = (anim.clipName ?? '').toString();
                        if (desired && Array.from(clipSelect.options).some(opt => opt.value === desired)) {
                            clipSelect.value = desired;
                        } else {
                            clipSelect.value = clipNames[0] || '';
                            anim.clipName = clipSelect.value;
                        }
                    };
                    refreshClipOptions();

                    animalSelect.addEventListener('change', () => {
                        anim.animalId = animalSelect.value;
                        refreshClipOptions();
                        emitChange();
                    });
                    clipSelect.addEventListener('change', () => {
                        anim.clipName = clipSelect.value;
                        emitChange();
                    });

                    let chanceValue = Number(anim.triggerChance);
                    if (!Number.isFinite(chanceValue)) chanceValue = 1;
                    chanceValue = Math.max(0, Math.min(1, chanceValue));
                    anim.triggerChance = chanceValue;
                    chanceInput.value = String(chanceValue);
                    chanceInput.addEventListener('input', () => {
                        anim.triggerChance = chanceInput.value;
                    });
                    chanceInput.addEventListener('change', () => {
                        let next = Number(chanceInput.value);
                        if (!Number.isFinite(next)) next = chanceValue;
                        next = Math.max(0, Math.min(1, next));
                        anim.triggerChance = next;
                        chanceInput.value = String(next);
                        emitChange();
                    });

                    idleCheckbox.checked = !!anim.isIdle;
                    idleCheckbox.addEventListener('change', () => {
                        const checked = idleCheckbox.checked;
                        if (checked) {
                            value.animations.forEach(other => {
                                if (other.uid !== anim.uid) other.isIdle = false;
                            });
                        }
                        anim.isIdle = checked;
                        renderAnimations();
                        emitChange();
                    });

                    removeBtn.addEventListener('click', () => {
                        value.animations.splice(idx, 1);
                        renderAnimations();
                        emitChange();
                    });
                });
            }

            animAddBtn.addEventListener('click', () => {
                if (animAddBtn.disabled) return;
                const animals = getAnimalsList();
                const primary = animals.find(an => Array.isArray(an?.clips) && an.clips.some(clip => {
                    if (!clip) return false;
                    if (typeof clip === 'string') return clip.trim() !== '';
                    if (typeof clip === 'object') return String(clip.name || '').trim() !== '';
                    return false;
                })) || animals[0] || null;
                const defaultAnimalId = primary ? (primary.id ?? '').toString() : '';
                let defaultClip = '';
                if (primary && Array.isArray(primary.clips)) {
                    const clip = primary.clips.find(entry => {
                        if (!entry) return false;
                        const name = typeof entry === 'string' ? entry : (entry?.name ?? '');
                        return String(name).trim() !== '';
                    });
                    if (clip) {
                        defaultClip = typeof clip === 'string' ? clip : (clip?.name ?? '');
                    }
                }
                value.animations.push({ uid: uid(), animalId: defaultAnimalId, clipName: defaultClip, triggerChance: 1, isIdle: value.animations.length === 0 });
                renderAnimations();
                emitChange();
            });

            function renderSkills() {
                skillList.innerHTML = '';
                if (value.skills.length === 0) {
                    const empty = document.createElement('div');
                    empty.className = 'creature-empty';
                    empty.textContent = '尚未新增技能。';
                    skillList.appendChild(empty);
                    return;
                }
                value.skills.forEach((skill, idx) => {
                    if (!skill.uid) skill.uid = uid();
                    const row = document.createElement('div');
                    row.className = 'creature-skill-row';

                    const nameWrap = document.createElement('div');
                    nameWrap.className = 'creature-inline';
                    const nameLabel = document.createElement('div');
                    nameLabel.className = 'creature-inline-label';
                    nameLabel.textContent = '名稱';
                    const nameInput = document.createElement('input');
                    nameInput.type = 'text';
                    nameInput.value = skill.name || '';
                    nameWrap.append(nameLabel, nameInput);

                    const descWrap = document.createElement('div');
                    descWrap.className = 'creature-inline grow';
                    const descLabel = document.createElement('div');
                    descLabel.className = 'creature-inline-label';
                    descLabel.textContent = '說明';
                    const descArea = document.createElement('textarea');
                    descArea.value = skill.description || '';
                    descWrap.append(descLabel, descArea);

                    const removeBtn = document.createElement('button');
                    removeBtn.type = 'button';
                    removeBtn.className = 'btn danger';
                    removeBtn.textContent = '移除';

                    row.append(nameWrap, descWrap, removeBtn);
                    skillList.appendChild(row);

                    nameInput.addEventListener('input', () => {
                        skill.name = nameInput.value;
                        emitChange();
                    });
                    nameInput.addEventListener('blur', () => {
                        skill.name = nameInput.value.trim();
                        nameInput.value = skill.name;
                        emitChange();
                    });

                    descArea.addEventListener('input', () => {
                        skill.description = descArea.value;
                        emitChange();
                    });
                    descArea.addEventListener('blur', () => {
                        skill.description = descArea.value.trim();
                        descArea.value = skill.description;
                        emitChange();
                    });

                    removeBtn.addEventListener('click', () => {
                        value.skills.splice(idx, 1);
                        renderSkills();
                        emitChange();
                    });
                });
            }

            skillAddBtn.addEventListener('click', () => {
                value.skills.push({ uid: uid(), name: '', description: '' });
                renderSkills();
                emitChange();
            });

            function renderAllSections() {
                const allowed = Object.keys(creatureDispositionLabels);
                if (!allowed.includes(value.disposition)) value.disposition = 'neutral';
                dispositionSelect.value = value.disposition;
                renderAnimations();
                renderSkills();
            }

            renderAllSections();

            return {
                element: container,
                getValue,
                setValue(newValue) {
                    value = toInternal(newValue);
                    renderAllSections();
                },
                refreshAnimals() {
                    renderAnimations();
                }
            };
        }

        const iDropContainer = document.getElementById('iDropEditor');
        const createItemDropEditor = iDropContainer ? createDropEditor({ initialDrops: [], sourceOptions: getDropSourceOptions() }) : null;
        if (createItemDropEditor && iDropContainer) {
            iDropContainer.appendChild(createItemDropEditor.element);
        }

        const iCreatureFields = document.getElementById('iCreatureFields');
        const iCreatureHost = document.getElementById('iCreatureEditorHost');
        const createItemCreatureEditor = iCreatureHost ? createCreatureEditor({ getAnimals: () => project.animals }) : null;
        if (createItemCreatureEditor && iCreatureHost) {
            iCreatureHost.appendChild(createItemCreatureEditor.element);
            createItemCreatureEditor.refreshAnimals();
        }

        function updateCreateCreatureVisibility() {
            if (!iCreatureFields) return;
            const isAnimal = (iCategory?.value || '') === 'animal';
            iCreatureFields.style.display = isAnimal ? '' : 'none';
        }

        if (iCategory) {
            iCategory.addEventListener('change', () => {
                updateCreateCreatureVisibility();
                if (createItemCreatureEditor) createItemCreatureEditor.refreshAnimals();
            });
            updateCreateCreatureVisibility();
        }

        addItem.onclick = async () => {
            const name = iName.value.trim();
            if (!name) return alert('請輸入名稱');
            const categoryId = iCategory.value || (project.itemCategories?.[0]?.id ?? 'decor');
            const terrains = Array.from(document.querySelectorAll('#iTerrainChecks input[type=checkbox]:checked')).map(x => x.dataset.tid);
            const notes = iNote.value.trim();

            const originalText = addItem.textContent;
            addItem.disabled = true;
            addItem.textContent = '儲存中...';

            const formData = new FormData();
            formData.append('action', 'create');
            formData.append('name', name);
            formData.append('categoryId', categoryId);
            formData.append('notes', notes);
            formData.append('terrains', JSON.stringify(terrains));
            if (createItemDropEditor) {
                formData.append('drops', JSON.stringify(createItemDropEditor.getDrops()));
            } else {
                formData.append('drops', '[]');
            }
            if (createItemCreatureEditor) {
                if (categoryId === 'animal') {
                    formData.append('creature', JSON.stringify(createItemCreatureEditor.getValue()));
                } else {
                    formData.append('creature', 'null');
                }
            }
            if (iIcon.files && iIcon.files[0]) {
                formData.append('image', iIcon.files[0]);
            }

            try {
                const res = await fetch(itemApiUrl, { method: 'POST', body: formData });

                // 先讀文字（500 可能不是 JSON）
                const raw = await res.text();

                if (!res.ok) {
                    throw new Error(`HTTP ${res.status}${raw ? ' | ' + raw : ''}`);
                }

                // 是 2xx 才 parse JSON
                let data;
                try { data = JSON.parse(raw); }
                catch { throw new Error('後端不是有效的 JSON：' + raw.slice(0, 180)); }

                if (data.status !== 'ok') {
                    throw new Error(data.message || '新增物品失敗');
                }

                pendingOpenItemId = data.item?.id || null;
                pendingOpenCategoryId = data.item?.categoryId || null;
                updateItemsState(data.items, data.categories);

                iName.value = '';
                iNote.value = '';
                iIcon.value = '';
                if (createItemDropEditor) {
                    createItemDropEditor.setDrops([]);
                }
                if (createItemCreatureEditor) {
                    createItemCreatureEditor.setValue(null);
                    createItemCreatureEditor.refreshAnimals();
                }
                updateCreateCreatureVisibility();
                populateTerrainChecklist(document.getElementById('iTerrainChecks'), []);
            } catch (err) {
                console.error('Failed to create item', err);
                alert('新增物品失敗：' + (err.message || '發生未知錯誤'));
            } finally {
                addItem.disabled = false;
                addItem.textContent = originalText;
            }

        };

        function createCategorySelect(selectedId) {
            const select = document.createElement('select');
            ensureItemCategories(project.itemCategories);
            (project.itemCategories || []).forEach(cat => {
                const opt = document.createElement('option');
                opt.value = cat.id;
                opt.textContent = cat.label;
                if (cat.id === selectedId) opt.selected = true;
                select.appendChild(opt);
            });
            return select;
        }

        function buildItemCard(item, dropOptions) {
            const terrainsLookup = new Map((project.terrains || []).map(t => [t.id, t.name]));
            const formatTerrainList = (ids) => {
                const names = (ids || []).map(id => terrainsLookup.get(id) || id).filter(Boolean);
                return names.length > 0 ? names.join(', ') : '—';
            };

            let creatureEditor = null;

            const card = document.createElement('div');
            card.className = 'item-card';
            card.dataset.itemId = item.id;

            const header = document.createElement('div');
            header.className = 'item-card-header';

            const title = document.createElement('h3');
            title.className = 'item-card-title';
            title.textContent = item.name || item.id;

            const meta = document.createElement('div');
            meta.className = 'item-card-meta';
            const idSpan = document.createElement('span');
            idSpan.textContent = `ID: ${item.id}`;
            const terrainSpan = document.createElement('span');
            terrainSpan.textContent = `地形：${formatTerrainList(item.terrains || [])}`;
            const dropMeta = document.createElement('span');
            dropMeta.className = 'item-drop-meta';
            dropMeta.textContent = `掉落：${formatDropSummary(item.drops, dropOptions)}`;
            const creatureMeta = document.createElement('span');
            creatureMeta.className = 'item-creature-meta';
            creatureMeta.style.display = 'none';
            meta.append(idSpan, terrainSpan, dropMeta, creatureMeta);
            header.append(title, meta);
            card.appendChild(header);

            const body = document.createElement('div');
            body.className = 'item-body';

            const form = document.createElement('div');
            form.className = 'item-form';

            const nameRow = document.createElement('div'); nameRow.className = 'row';
            const nameLabel = document.createElement('label'); nameLabel.textContent = '名稱';
            const nameInput = document.createElement('input'); nameInput.type = 'text'; nameInput.value = item.name;
            nameInput.addEventListener('input', () => {
                title.textContent = nameInput.value || item.id;
            });
            nameInput.addEventListener('blur', () => {
                nameInput.value = nameInput.value.trim();
                title.textContent = nameInput.value || item.id;
            });
            nameRow.appendChild(nameLabel); nameRow.appendChild(nameInput);

            const catRow = document.createElement('div'); catRow.className = 'row';
            const catLabel = document.createElement('label'); catLabel.textContent = '分類';
            const catSelect = createCategorySelect(item.categoryId);
            catRow.appendChild(catLabel); catRow.appendChild(catSelect);

            const updateCreatureMeta = () => {
                if (!creatureMeta) return;
                if (catSelect.value === 'animal') {
                    const data = creatureEditor ? creatureEditor.getValue() : item.creature;
                    creatureMeta.style.display = '';
                    creatureMeta.textContent = `生物：${formatCreatureSummary(data)}`;
                } else {
                    creatureMeta.style.display = 'none';
                }
            };

            const notesRow = document.createElement('div'); notesRow.className = 'row';
            const notesLabel = document.createElement('label'); notesLabel.textContent = '備註';
            const notesField = document.createElement('textarea'); notesField.value = item.notes || '';
            notesRow.appendChild(notesLabel); notesRow.appendChild(notesField);

            const dropRow = document.createElement('div'); dropRow.className = 'row item-drop-row';
            const dropLabel = document.createElement('label'); dropLabel.textContent = '掉落設定';
            const dropWrap = document.createElement('div'); dropWrap.className = 'drop-editor-wrap';
            const dropEditor = createDropEditor({
                initialDrops: Array.isArray(item.drops) ? item.drops : [],
                sourceOptions: dropOptions,
                noteText: '調整後記得按「儲存變更」。',
                onChange: drops => { dropMeta.textContent = `掉落：${formatDropSummary(drops, dropOptions)}`; }
            });
            dropWrap.appendChild(dropEditor.element);
            dropRow.appendChild(dropLabel);
            dropRow.appendChild(dropWrap);

            const creatureRow = document.createElement('div'); creatureRow.className = 'row creature-row';
            const creatureLabel = document.createElement('label'); creatureLabel.textContent = '生物設定';
            const creatureHost = document.createElement('div'); creatureHost.className = 'creature-editor-host';
            creatureRow.appendChild(creatureLabel); creatureRow.appendChild(creatureHost);
            creatureEditor = createCreatureEditor({
                initialValue: item.creature,
                getAnimals: () => project.animals,
                onChange: updateCreatureMeta
            });
            creatureHost.appendChild(creatureEditor.element);

            const handleCategoryToggle = () => {
                const isAnimal = catSelect.value === 'animal';
                creatureRow.style.display = isAnimal ? '' : 'none';
                if (isAnimal && creatureEditor) {
                    creatureEditor.refreshAnimals();
                }
                updateCreatureMeta();
            };
            catSelect.addEventListener('change', () => {
                selectedCategoryId = catSelect.value;
                handleCategoryToggle();
            });
            handleCategoryToggle();

            const terrainRow = document.createElement('div'); terrainRow.className = 'row';
            const terrainLabel = document.createElement('label'); terrainLabel.textContent = '適用地形';
            const terrainWrap = document.createElement('div'); terrainWrap.className = 'checklist';
            populateTerrainChecklist(terrainWrap, item.terrains || []);
            const updateTerrainMeta = () => {
                const selected = Array.from(terrainWrap.querySelectorAll('input[type=checkbox]:checked')).map(x => x.dataset.tid);
                terrainSpan.textContent = `地形：${formatTerrainList(selected)}`;
            };
            terrainWrap.addEventListener('change', updateTerrainMeta);
            updateTerrainMeta();
            terrainRow.appendChild(terrainLabel);
            terrainRow.appendChild(terrainWrap);

            const actionsRow = document.createElement('div'); actionsRow.className = 'item-actions';
            const saveBtn = document.createElement('button'); saveBtn.className = 'btn'; saveBtn.textContent = '儲存變更';
            const uploadBtn = document.createElement('button'); uploadBtn.className = 'btn secondary'; uploadBtn.textContent = '替換圖片';
            const removeImageBtn = document.createElement('button'); removeImageBtn.className = 'btn secondary'; removeImageBtn.textContent = '移除圖片';
            const deleteBtn = document.createElement('button'); deleteBtn.className = 'btn danger'; deleteBtn.textContent = '刪除此物品';
            actionsRow.append(saveBtn, uploadBtn, removeImageBtn, deleteBtn);

            form.append(nameRow, catRow, notesRow, dropRow, creatureRow, terrainRow, actionsRow);
            body.appendChild(form);

            const imageSection = document.createElement('div');
            if (item.image) {
                imageSection.className = 'item-image-preview';
                const img = document.createElement('img');
                img.src = item.image.path;
                img.alt = item.name + ' 圖片';
                imageSection.appendChild(img);

                const metaWrap = document.createElement('div'); metaWrap.className = 'item-image-meta';
                const labelInput = document.createElement('input'); labelInput.type = 'text'; labelInput.value = item.image.label || item.name;
                const renameBtn = document.createElement('button'); renameBtn.className = 'btn secondary'; renameBtn.textContent = '更新圖片名稱';
                const metaInfo = document.createElement('div');
                const uploadedAt = item.image.uploadedAt ? new Date(item.image.uploadedAt).toLocaleString() : '';
                metaInfo.textContent = `檔案：${item.image.filename}${uploadedAt ? `｜上傳：${uploadedAt}` : ''}`;
                metaWrap.append(labelInput, renameBtn, metaInfo);
                imageSection.appendChild(metaWrap);

                renameBtn.onclick = async () => {
                    const label = labelInput.value.trim();
                    if (!label) return alert('圖片名稱不可為空');
                    const original = renameBtn.textContent;
                    renameBtn.disabled = true;
                    renameBtn.textContent = '更新中...';
                    const formData = new FormData();
                    formData.append('action', 'update');
                    formData.append('id', item.id);
                    formData.append('imageLabel', label);
                    try {
                        const res = await fetch(itemApiUrl, { method: 'POST', body: formData });
                        const data = await res.json();
                        if (!res.ok || data.status !== 'ok') throw new Error(data.message || '更新失敗');
                        updateItemsState(data.items, data.categories);
                    } catch (err) {
                        console.error('Failed to rename item image', err);
                        alert('更新圖片名稱失敗：' + (err.message || '未知錯誤'));
                    } finally {
                        renameBtn.disabled = false;
                        renameBtn.textContent = original;
                    }
                };
            } else {
                imageSection.className = 'terrain-empty';
                imageSection.textContent = '尚未上傳圖片';
            }
            body.appendChild(imageSection);

            card.appendChild(body);

            saveBtn.onclick = async (e) => {
                e.preventDefault();
                const newName = nameInput.value.trim();
                if (newName === '') return alert('物品名稱不可為空');
                const terrainsSelected = Array.from(terrainWrap.querySelectorAll('input[type=checkbox]:checked')).map(x => x.dataset.tid);
                const original = saveBtn.textContent;
                saveBtn.disabled = true;
                saveBtn.textContent = '儲存中...';
                const formData = new FormData();
                formData.append('action', 'update');
                formData.append('id', item.id);
                formData.append('name', newName);
                formData.append('categoryId', catSelect.value);
                formData.append('notes', notesField.value.trim());
                formData.append('terrains', JSON.stringify(terrainsSelected));
                formData.append('drops', JSON.stringify(dropEditor.getDrops()));
                if (creatureEditor) {
                    if (catSelect.value === 'animal') {
                        formData.append('creature', JSON.stringify(creatureEditor.getValue()));
                    } else {
                        formData.append('creature', 'null');
                    }
                }
                try {
                    selectedItemId = item.id;
                    selectedCategoryId = catSelect.value;
                    const res = await fetch(itemApiUrl, { method: 'POST', body: formData });
                    const data = await res.json();
                    if (!res.ok || data.status !== 'ok') throw new Error(data.message || '儲存失敗');
                    updateItemsState(data.items, data.categories);
                } catch (err) {
                    console.error('Failed to update item', err);
                    alert('更新物品失敗：' + (err.message || '未知錯誤'));
                } finally {
                    saveBtn.disabled = false;
                    saveBtn.textContent = original;
                }
            };

            uploadBtn.onclick = () => {
                const input = document.createElement('input');
                input.type = 'file';
                input.accept = 'image/*';
                input.onchange = async () => {
                    if (!input.files || !input.files[0]) return;
                    const original = uploadBtn.textContent;
                    uploadBtn.disabled = true;
                    uploadBtn.textContent = '上傳中...';
                    const formData = new FormData();
                    formData.append('action', 'update');
                    formData.append('id', item.id);
                    formData.append('image', input.files[0]);
                    try {
                        selectedItemId = item.id;
                        const res = await fetch(itemApiUrl, { method: 'POST', body: formData });
                        const data = await res.json();
                        if (!res.ok || data.status !== 'ok') throw new Error(data.message || '上傳失敗');
                        updateItemsState(data.items, data.categories);
                    } catch (err) {
                        console.error('Failed to upload item image', err);
                        alert('上傳圖片失敗：' + (err.message || '未知錯誤'));
                    } finally {
                        uploadBtn.disabled = false;
                        uploadBtn.textContent = original;
                        input.value = '';
                    }
                };
                input.click();
            };

            removeImageBtn.disabled = !item.image;
            removeImageBtn.onclick = async (e) => {
                e.preventDefault();
                if (!item.image) return;
                if (!confirm('確定移除圖片？')) return;
                const original = removeImageBtn.textContent;
                removeImageBtn.disabled = true;
                removeImageBtn.textContent = '處理中...';
                const formData = new FormData();
                formData.append('action', 'update');
                formData.append('id', item.id);
                formData.append('removeImage', 'true');
                try {
                    selectedItemId = item.id;
                    const res = await fetch(itemApiUrl, { method: 'POST', body: formData });
                    const data = await res.json();
                    if (!res.ok || data.status !== 'ok') throw new Error(data.message || '移除失敗');
                    updateItemsState(data.items, data.categories);
                } catch (err) {
                    console.error('Failed to remove item image', err);
                    alert('移除圖片失敗：' + (err.message || '未知錯誤'));
                } finally {
                    removeImageBtn.disabled = false;
                    removeImageBtn.textContent = original;
                }
            };

            deleteBtn.onclick = async (e) => {
                e.preventDefault();
                if (!confirm('刪除此物品？相關的圖片與資料將被移除。')) return;
                const original = deleteBtn.textContent;
                deleteBtn.disabled = true;
                deleteBtn.textContent = '刪除中...';
                const formData = new FormData();
                formData.append('action', 'delete');
                formData.append('id', item.id);
                try {
                    const res = await fetch(itemApiUrl, { method: 'POST', body: formData });
                    const data = await res.json();
                    if (!res.ok || data.status !== 'ok') throw new Error(data.message || '刪除失敗');
                    updateItemsState(data.items, data.categories);
                } catch (err) {
                    console.error('Failed to delete item', err);
                    alert('刪除物品失敗：' + (err.message || '未知錯誤'));
                } finally {
                    deleteBtn.disabled = false;
                    deleteBtn.textContent = original;
                }
            };

            return card;
        }

        function renderItems() {
            if (!itemList) return;
            renderItemCategoryOptions();
            const dropOptions = getDropSourceOptions();
            if (createItemDropEditor) createItemDropEditor.setSourceOptions(dropOptions);

            if (pendingOpenItemId) selectedItemId = pendingOpenItemId;
            if (pendingOpenCategoryId) selectedCategoryId = pendingOpenCategoryId;

            ensureItemCategories(project.itemCategories);
            const categories = (project.itemCategories || []).slice();
            const itemsByCategory = new Map(categories.map(cat => [cat.id, []]));
            const uncategorized = [];
            const allItems = [];

            (project.items || []).forEach(item => {
                if (!item || !item.id) return;
                allItems.push(item);
                if (itemsByCategory.has(item.categoryId)) {
                    itemsByCategory.get(item.categoryId).push(item);
                } else {
                    uncategorized.push(item);
                }
            });

            let selectedItem = null;
            if (selectedItemId) {
                selectedItem = allItems.find(it => it.id === selectedItemId) || null;
            }
            if (!selectedItem && selectedCategoryId) {
                const candidates = itemsByCategory.get(selectedCategoryId) || [];
                if (candidates.length > 0) {
                    selectedItem = candidates.slice().sort((a, b) => (a.name || '').localeCompare(b.name || '', 'zh-Hant'))[0];
                }
            }
            if (!selectedItem && allItems.length > 0) {
                selectedItem = allItems.slice().sort((a, b) => (a.name || '').localeCompare(b.name || '', 'zh-Hant'))[0];
            }

            selectedItemId = selectedItem ? selectedItem.id : null;
            if (selectedItem) {
                selectedCategoryId = selectedItem.categoryId || 'uncategorized';
            }

            itemList.innerHTML = '';
            const layout = document.createElement('div');
            layout.className = 'item-browser';
            const nav = document.createElement('div');
            nav.className = 'item-browser-nav';
            const detail = document.createElement('div');
            detail.className = 'item-browser-detail';
            layout.append(nav, detail);
            itemList.appendChild(layout);

            const renderDetail = (item) => {
                detail.innerHTML = '';
                if (!item) {
                    const empty = document.createElement('div');
                    empty.className = 'terrain-empty';
                    empty.textContent = allItems.length === 0 ? '尚未新增物品' : '請從左側選擇物品';
                    detail.appendChild(empty);
                    return;
                }
                detail.appendChild(buildItemCard(item, dropOptions));
            };

            const updateActiveNav = () => {
                Array.from(nav.querySelectorAll('.item-nav-item')).forEach(btn => {
                    btn.classList.toggle('active', btn.dataset.itemId === selectedItemId);
                });
            };

            const handleSelect = (item) => {
                selectedItemId = item?.id || null;
                selectedCategoryId = item ? (item.categoryId || 'uncategorized') : selectedCategoryId;
                renderDetail(item || null);
                updateActiveNav();
            };

            const buildGroup = (catId, label, items) => {
                const group = document.createElement('div');
                group.className = 'item-nav-group';
                const title = document.createElement('div');
                title.className = 'item-nav-title';
                title.textContent = `${label}（${items.length}）`;
                const list = document.createElement('div');
                list.className = 'item-nav-items';
                if (items.length === 0) {
                    const empty = document.createElement('div');
                    empty.className = 'item-nav-empty';
                    empty.textContent = '尚未新增';
                    list.appendChild(empty);
                } else {
                    const sorted = items.slice().sort((a, b) => (a.name || '').localeCompare(b.name || '', 'zh-Hant'));
                    sorted.forEach(it => {
                        const btn = document.createElement('button');
                        btn.type = 'button';
                        btn.className = 'item-nav-item';
                        btn.dataset.itemId = it.id;
                        btn.textContent = it.name || it.id;
                        btn.onclick = () => handleSelect(it);
                        list.appendChild(btn);
                    });
                }
                group.append(title, list);
                nav.appendChild(group);
            };

            categories.forEach(cat => buildGroup(cat.id, cat.label, itemsByCategory.get(cat.id) || []));
            if (uncategorized.length > 0) {
                buildGroup('uncategorized', '未分類', uncategorized);
            }

            renderDetail(selectedItem || null);
            updateActiveNav();

            pendingOpenItemId = null;
            pendingOpenCategoryId = null;
        }

        // ----------------------------- Animals & Clips -----------------------------
        const aName = document.getElementById('aName');
        const aPreview = document.getElementById('aPreview');
        const clearPreview = document.getElementById('clearPreview');
        const previewThumb = document.getElementById('aPreviewThumb');
        const clipName = document.getElementById('clipName');
        const clipFps = document.getElementById('clipFps');
        const clipFrames = document.getElementById('clipFrames');
        const clipFrameAppend = document.getElementById('clipFrameAppend');
        const clipFrameList = document.getElementById('clipFrameList');
        const newClip = document.getElementById('newClip');
        const addClip = document.getElementById('addClip');
        const addAnimal = document.getElementById('addAnimal');
        const resetAnimal = document.getElementById('resetAnimal');
        const clipDraftList = document.getElementById('clipDraftList');
        const clipEditorStatus = document.getElementById('clipEditorStatus');
        const animalEditorStatus = document.getElementById('animalEditorStatus');
        const animalList = document.getElementById('animalList');
        const previewAnimal = document.getElementById('previewAnimal');
        const previewClip = document.getElementById('previewClip');
        const previewSpeed = document.getElementById('previewSpeed');

        let clipDrafts = [];
        let selectedClipFrames = [];
        let editingClipIndex = null;
        let editingAnimalId = null;
        let editingPreviewDataUrl = null;
        let pendingPreviewDataUrl = null;

        function updatePreviewThumbnail(src) {
            if (!previewThumb) return;
            if (src) {
                previewThumb.src = src;
                previewThumb.style.display = '';
                if (clearPreview) clearPreview.disabled = false;
            } else {
                previewThumb.src = '';
                previewThumb.style.display = 'none';
                if (clearPreview) clearPreview.disabled = true;
            }
        }

        function normalizeClipFrames(clip) {
            if (!clip || typeof clip !== 'object') return [];
            if (!Array.isArray(clip.frames)) clip.frames = [];
            const fps = Math.max(1, Number(clip.fps || 6));
            const fallbackDuration = 1 / fps;
            clip.frames = clip.frames.map((frame, idx) => {
                if (typeof frame === 'string') {
                    return { src: frame, duration: fallbackDuration, name: `frame-${idx + 1}` };
                }
                if (frame && typeof frame === 'object') {
                    const src = frame.src || frame.dataUrl || frame.image || '';
                    if (!src) return null;
                    const duration = Math.max(0.01, Number(frame.duration) || fallbackDuration);
                    const name = frame.name || frame.label || `frame-${idx + 1}`;
                    return { src, duration, name };
                }
                return null;
            }).filter(Boolean);
            return clip.frames;
        }

        function upgradeAnimalClips() {
            if (!Array.isArray(project.animals)) return;
            project.animals.forEach(an => {
                if (!Array.isArray(an.clips)) an.clips = [];
                an.clips.forEach(clip => {
                    if (!clip || typeof clip !== 'object') return;
                    if (!clip.id) clip.id = 'clip_' + uid();
                    normalizeClipFrames(clip);
                });
            });
        }

        function moveFrame(index, delta) {
            const newIndex = index + delta;
            if (newIndex < 0 || newIndex >= selectedClipFrames.length) return;
            const [frame] = selectedClipFrames.splice(index, 1);
            selectedClipFrames.splice(newIndex, 0, frame);
            renderClipFrameDurations();
        }

        function removeFrame(index) {
            if (index < 0 || index >= selectedClipFrames.length) return;
            selectedClipFrames.splice(index, 1);
            renderClipFrameDurations();
        }

        function renderClipFrameDurations() {
            if (!clipFrameList) return;
            clipFrameList.innerHTML = '';
            if (clipFrameAppend) {
                clipFrameAppend.disabled = selectedClipFrames.length === 0;
                if (clipFrameAppend.disabled) clipFrameAppend.checked = false;
            }
            if (selectedClipFrames.length === 0) {
                const empty = document.createElement('div');
                empty.className = 'frame-duration-empty';
                empty.textContent = '尚未選擇圖片';
                clipFrameList.appendChild(empty);
                return;
            }
            selectedClipFrames.forEach((frame, idx) => {
                const item = document.createElement('div');
                item.className = 'frame-duration-item';
                const index = document.createElement('span');
                index.className = 'frame-duration-index';
                index.textContent = `#${idx + 1}`;
                const thumb = document.createElement('img');
                thumb.className = 'frame-duration-thumb';
                thumb.src = frame.src;
                thumb.alt = frame.name || `frame-${idx + 1}`;
                const name = document.createElement('span');
                name.className = 'frame-duration-name';
                name.textContent = frame.name || `frame-${idx + 1}`;
                const input = document.createElement('input');
                input.type = 'number';
                input.step = '0.01';
                input.min = '0.01';
                input.value = String(frame.duration ?? '');
                input.oninput = () => { frame.custom = true; };
                input.onchange = () => {
                    const val = Math.max(0.01, Number(input.value || 0));
                    frame.duration = val;
                    frame.custom = true;
                    input.value = String(val);
                };
                const suffix = document.createElement('span');
                suffix.className = 'frame-duration-suffix';
                suffix.textContent = '秒';
                const actions = document.createElement('div');
                actions.className = 'frame-duration-actions';
                const upBtn = document.createElement('button');
                upBtn.type = 'button';
                upBtn.className = 'ghost-btn';
                upBtn.textContent = '上移';
                upBtn.disabled = idx === 0;
                upBtn.onclick = () => moveFrame(idx, -1);
                const downBtn = document.createElement('button');
                downBtn.type = 'button';
                downBtn.className = 'ghost-btn';
                downBtn.textContent = '下移';
                downBtn.disabled = idx === selectedClipFrames.length - 1;
                downBtn.onclick = () => moveFrame(idx, 1);
                const removeBtn = document.createElement('button');
                removeBtn.type = 'button';
                removeBtn.className = 'ghost-btn danger';
                removeBtn.textContent = '刪除';
                removeBtn.onclick = () => removeFrame(idx);
                actions.append(upBtn, downBtn, removeBtn);
                item.append(index, thumb, name, input, suffix, actions);
                clipFrameList.appendChild(item);
            });
            const hint = document.createElement('div');
            hint.className = 'frame-duration-hint';
            hint.textContent = '提示：預設依 FPS 換算，可調整秒數並調整順序。';
            clipFrameList.appendChild(hint);
        }

        function updateClipEditorStatus() {
            if (clipEditorStatus) {
                if (editingClipIndex === null) {
                    clipEditorStatus.textContent = '新增動畫草稿';
                } else {
                    const clip = clipDrafts[editingClipIndex];
                    clipEditorStatus.textContent = clip ? `編輯動畫：${clip.name || '(未命名)'}` : '編輯動畫';
                }
            }
            if (addClip) {
                addClip.textContent = editingClipIndex === null ? '儲存動畫' : '更新動畫';
            }
        }

        function renderClipDraftList() {
            if (!clipDraftList) return;
            clipDraftList.innerHTML = '';
            if (!Array.isArray(clipDrafts) || clipDrafts.length === 0) {
                const empty = document.createElement('div');
                empty.className = 'creature-empty';
                empty.textContent = '尚未加入任何動畫';
                clipDraftList.appendChild(empty);
                return;
            }
            clipDrafts.forEach((clip, idx) => {
                const item = document.createElement('div');
                item.className = 'clip-item';
                if (idx === editingClipIndex) item.classList.add('active');
                const header = document.createElement('div');
                header.className = 'clip-item-header';
                const title = document.createElement('div');
                title.textContent = clip.name || `clip-${idx + 1}`;
                const meta = document.createElement('div');
                meta.className = 'clip-item-meta';
                const frameCount = Array.isArray(clip.frames) ? clip.frames.length : 0;
                const totalSeconds = (clip.frames || []).reduce((sum, frame) => sum + Math.max(0, Number(frame.duration) || 0), 0);
                meta.textContent = `FPS ${clip.fps} ｜ 幀數 ${frameCount} ｜ ${totalSeconds.toFixed(2)} 秒`;
                header.append(title, meta);
                const actions = document.createElement('div');
                actions.className = 'clip-item-actions';
                const editBtn = document.createElement('button');
                editBtn.type = 'button';
                editBtn.className = 'ghost-btn';
                editBtn.textContent = '編輯';
                editBtn.onclick = () => loadClipToForm(idx);
                const upBtn = document.createElement('button');
                upBtn.type = 'button';
                upBtn.className = 'ghost-btn';
                upBtn.textContent = '上移';
                upBtn.disabled = idx === 0;
                upBtn.onclick = () => moveClip(idx, -1);
                const downBtn = document.createElement('button');
                downBtn.type = 'button';
                downBtn.className = 'ghost-btn';
                downBtn.textContent = '下移';
                downBtn.disabled = idx === clipDrafts.length - 1;
                downBtn.onclick = () => moveClip(idx, 1);
                const deleteBtn = document.createElement('button');
                deleteBtn.type = 'button';
                deleteBtn.className = 'ghost-btn danger';
                deleteBtn.textContent = '刪除';
                deleteBtn.onclick = () => deleteClip(idx);
                actions.append(editBtn, upBtn, downBtn, deleteBtn);
                item.append(header, actions);
                clipDraftList.appendChild(item);
            });
        }

        function startNewClipDraft() {
            editingClipIndex = null;
            if (clipName) clipName.value = '';
            if (clipFrames) clipFrames.value = '';
            if (clipFrameAppend) {
                clipFrameAppend.checked = false;
                clipFrameAppend.disabled = true;
            }
            selectedClipFrames = [];
            renderClipFrameDurations();
            updateClipEditorStatus();
            renderClipDraftList();
        }

        function loadClipToForm(index) {
            const clip = clipDrafts[index];
            if (!clip) return;
            editingClipIndex = index;
            if (clipName) clipName.value = clip.name || '';
            if (clipFps) clipFps.value = String(Math.max(1, Number(clip.fps || 6)));
            const fps = Math.max(1, Number(clip.fps || 6));
            const fallback = 1 / fps;
            selectedClipFrames = (clip.frames || []).map((frame, idx) => {
                const src = frame?.src || frame?.dataUrl || frame?.image || '';
                if (!src) return null;
                const duration = Math.max(0.01, Number(frame.duration) || fallback);
                const name = frame?.name || frame?.label || `frame-${idx + 1}`;
                const custom = Math.abs(duration - fallback) > 0.0001;
                return { id: uid(), name, src, duration, custom };
            }).filter(Boolean);
            if (clipFrames) clipFrames.value = '';
            if (clipFrameAppend) {
                clipFrameAppend.checked = false;
                clipFrameAppend.disabled = selectedClipFrames.length === 0;
            }
            renderClipFrameDurations();
            renderClipDraftList();
            updateClipEditorStatus();
        }

        function moveClip(index, delta) {
            const newIndex = index + delta;
            if (newIndex < 0 || newIndex >= clipDrafts.length) return;
            const [clip] = clipDrafts.splice(index, 1);
            clipDrafts.splice(newIndex, 0, clip);
            if (editingClipIndex === index) {
                editingClipIndex = newIndex;
            } else if (editingClipIndex === newIndex) {
                editingClipIndex = index;
            } else if (editingClipIndex > index && editingClipIndex <= newIndex) {
                editingClipIndex--;
            } else if (editingClipIndex < index && editingClipIndex >= newIndex) {
                editingClipIndex++;
            }
            renderClipDraftList();
            updateClipEditorStatus();
        }

        function deleteClip(index) {
            if (index < 0 || index >= clipDrafts.length) return;
            if (!confirm('刪除此動畫？')) return;
            clipDrafts.splice(index, 1);
            if (editingClipIndex === index) {
                startNewClipDraft();
            } else if (editingClipIndex > index) {
                editingClipIndex--;
            }
            renderClipDraftList();
            updateClipEditorStatus();
        }

        clipFrames.onchange = async () => {
            const files = Array.from(clipFrames.files || []);
            if (files.length === 0) return;
            if (clipFrameList) {
                clipFrameList.innerHTML = '';
                const loading = document.createElement('div');
                loading.className = 'frame-duration-empty';
                loading.textContent = '載入中...';
                clipFrameList.appendChild(loading);
            }
            const fps = Math.max(1, Number(clipFps.value || 6));
            const defaultDuration = 1 / fps;
            const shouldAppend = !!(clipFrameAppend && clipFrameAppend.checked && selectedClipFrames.length > 0);
            const loaded = [];
            try {
                for (const file of files) {
                    const src = await fileToDataUrl(file);
                    loaded.push({
                        id: uid(),
                        name: file.name || `frame-${selectedClipFrames.length + loaded.length + 1}`,
                        src,
                        duration: defaultDuration,
                        custom: false
                    });
                }
                if (shouldAppend) {
                    selectedClipFrames.push(...loaded);
                } else {
                    selectedClipFrames = loaded;
                }
            } catch (err) {
                console.error('Failed to load clip frames', err);
                alert('載入動畫幀失敗：' + (err.message || '未知錯誤'));
                if (!shouldAppend) selectedClipFrames = [];
            } finally {
                if (clipFrames) clipFrames.value = '';
                if (clipFrameAppend) clipFrameAppend.checked = false;
                renderClipFrameDurations();
            }
        };

        clipFps.onchange = () => {
            const fps = Math.max(1, Number(clipFps.value || 6));
            const defaultDuration = 1 / fps;
            let changed = false;
            selectedClipFrames.forEach(frame => {
                if (!frame.custom) {
                    frame.duration = defaultDuration;
                    changed = true;
                }
            });
            if (changed) renderClipFrameDurations();
        };

        if (newClip) newClip.onclick = () => {
            startNewClipDraft();
        };

        if (addClip) addClip.onclick = () => {
            const name = clipName?.value.trim();
            if (!name) return alert('請輸入動畫名稱');
            const fps = Math.max(1, Number(clipFps?.value || 6));
            if (selectedClipFrames.length === 0) return alert('請加入至少一張動畫幀圖片');
            const fallbackDuration = 1 / fps;
            const frames = selectedClipFrames.map(frame => {
                const duration = Math.max(0.01, Number(frame.duration) || fallbackDuration);
                const payload = { src: frame.src, duration };
                if (frame.name) payload.name = frame.name;
                return payload;
            }).filter(f => !!f.src);
            if (frames.length === 0) return alert('請加入至少一張有效的動畫幀');
            const totalSeconds = frames.reduce((sum, frame) => sum + frame.duration, 0);
            const clipData = {
                id: (editingClipIndex !== null && clipDrafts[editingClipIndex]?.id) || ('clip_' + uid()),
                name,
                fps,
                frames
            };
            if (editingClipIndex === null) {
                clipDrafts.push(clipData);
                editingClipIndex = clipDrafts.length - 1;
            } else {
                clipDrafts[editingClipIndex] = clipData;
            }
            renderClipDraftList();
            updateClipEditorStatus();
            alert(`已儲存動畫 ${name}（${frames.length} 幀，總時長 ${totalSeconds.toFixed(2)} 秒）`);
        };

        function updateAnimalEditorState() {
            if (animalEditorStatus) {
                if (editingAnimalId) {
                    const currentName = aName?.value.trim() || '';
                    animalEditorStatus.textContent = currentName ? `編輯中：${currentName}` : '編輯既有動物';
                } else {
                    animalEditorStatus.textContent = '目前為新增模式';
                }
            }
            if (addAnimal) {
                addAnimal.textContent = editingAnimalId ? '更新動物' : '新增動物';
            }
        }

        if (aName) aName.oninput = () => updateAnimalEditorState();

        if (clearPreview) clearPreview.onclick = () => {
            editingPreviewDataUrl = null;
            pendingPreviewDataUrl = null;
            if (aPreview) aPreview.value = '';
            updatePreviewThumbnail(null);
        };

        if (aPreview) aPreview.onchange = async () => {
            if (!aPreview.files || !aPreview.files[0]) return;
            try {
                const dataUrl = await fileToDataUrl(aPreview.files[0]);
                pendingPreviewDataUrl = dataUrl;
                updatePreviewThumbnail(dataUrl);
            } catch (err) {
                console.error('Failed to load preview image', err);
                alert('載入預覽圖失敗：' + (err.message || '未知錯誤'));
            }
        };

        if (resetAnimal) resetAnimal.onclick = () => {
            if (editingAnimalId && !confirm('取消編輯並清空表單？')) return;
            resetAnimalForm();
        };

        function resetAnimalForm() {
            editingAnimalId = null;
            editingPreviewDataUrl = null;
            pendingPreviewDataUrl = null;
            if (aName) aName.value = '';
            if (aPreview) aPreview.value = '';
            updatePreviewThumbnail(null);
            clipDrafts = [];
            selectedClipFrames = [];
            editingClipIndex = null;
            if (clipFrames) clipFrames.value = '';
            if (clipFrameAppend) {
                clipFrameAppend.checked = false;
                clipFrameAppend.disabled = true;
            }
            renderClipFrameDurations();
            renderClipDraftList();
            updateClipEditorStatus();
            editingAnimalTerrains = new Set();
            renderAnimalTerrainChecks();
            updateAnimalEditorState();
        }

        function startEditAnimal(animalId) {
            const animal = project.animals.find(a => a.id === animalId);
            if (!animal) return;
            editingAnimalId = animal.id;
            if (aName) aName.value = animal.name || '';
            editingPreviewDataUrl = animal.previewDataUrl || null;
            pendingPreviewDataUrl = null;
            if (aPreview) aPreview.value = '';
            updatePreviewThumbnail(editingPreviewDataUrl);
            clipDrafts = (Array.isArray(animal.clips) ? animal.clips : []).map(clip => {
                const fps = Math.max(1, Number(clip.fps || 6));
                const fallback = 1 / fps;
                const frames = (Array.isArray(clip.frames) ? clip.frames : []).map((frame, idx) => {
                    const src = frame?.src || frame?.dataUrl || frame?.image || '';
                    if (!src) return null;
                    const duration = Math.max(0.01, Number(frame.duration) || fallback);
                    const name = frame?.name || frame?.label || `frame-${idx + 1}`;
                    return { src, duration, name };
                }).filter(Boolean);
                return {
                    id: clip.id || ('clip_' + uid()),
                    name: clip.name || '',
                    fps,
                    frames
                };
            });
            selectedClipFrames = [];
            editingClipIndex = null;
            if (clipFrames) clipFrames.value = '';
            if (clipFrameAppend) {
                clipFrameAppend.checked = false;
                clipFrameAppend.disabled = true;
            }
            editingAnimalTerrains = new Set(Array.isArray(animal.spawnTerrains) ? animal.spawnTerrains : []);
            renderAnimalTerrainChecks();
            renderClipDraftList();
            renderClipFrameDurations();
            updateClipEditorStatus();
            updateAnimalEditorState();
            if (previewAnimal) {
                previewAnimal.value = animal.id;
                updatePreviewClips();
            }
        }

        if (addAnimal) addAnimal.onclick = async () => {
            const name = aName?.value.trim();
            if (!name) return alert('請輸入動物名稱');
            if (!Array.isArray(clipDrafts) || clipDrafts.length === 0) {
                return alert('請至少儲存一個動畫');
            }
            const duplicate = project.animals.some(an => an.name === name && an.id !== editingAnimalId);
            if (duplicate) return alert('已有同名動物，請更換名稱');
            const terrainsSelected = Array.from(document.querySelectorAll('#aTerrainChecks input[type=checkbox]'))
                .filter(el => el.checked)
                .map(el => el.dataset.tid)
                .filter(Boolean);
            editingAnimalTerrains = new Set(terrainsSelected);
            let previewDataUrl = pendingPreviewDataUrl ?? editingPreviewDataUrl ?? null;
            if (!previewDataUrl && aPreview?.files && aPreview.files[0]) {
                previewDataUrl = await fileToDataUrl(aPreview.files[0]);
            }
            const clipPayload = [];
            for (const clip of clipDrafts) {
                const fps = Math.max(1, Number(clip.fps) || 6);
                const fallback = 1 / fps;
                const frames = (clip.frames || []).map(frame => {
                    const src = frame?.src || '';
                    if (!src) return null;
                    const duration = Math.max(0.01, Number(frame.duration) || fallback);
                    const payload = { src, duration };
                    if (frame?.name) payload.name = frame.name;
                    return payload;
                }).filter(Boolean);
                if (frames.length === 0) {
                    alert(`動畫 ${clip.name || '(未命名)'} 需要至少一張幀圖片`);
                    return;
                }
                clipPayload.push({
                    id: clip.id || ('clip_' + uid()),
                    name: clip.name || '',
                    fps,
                    frames
                });
            }
            let target = editingAnimalId ? project.animals.find(a => a.id === editingAnimalId) : null;
            const isUpdate = !!target;
            if (target) {
                target.name = name;
                target.previewDataUrl = previewDataUrl || null;
                target.clips = clipPayload;
                target.spawnTerrains = terrainsSelected;
            } else {
                let baseSlug = name.toLowerCase().replace(/\s+/g, '_').replace(/[^a-z0-9_]/g, '');
                if (!baseSlug) baseSlug = 'animal';
                let newId = baseSlug + '_' + uid();
                while (project.animals.some(a => a.id === newId)) {
                    newId = baseSlug + '_' + uid();
                }
                target = {
                    id: newId,
                    name,
                    previewDataUrl: previewDataUrl || null,
                    clips: clipPayload,
                    spawnTerrains: terrainsSelected
                };
                project.animals.push(target);
                editingAnimalId = target.id;
            }
            editingPreviewDataUrl = previewDataUrl || null;
            pendingPreviewDataUrl = null;
            if (aPreview) aPreview.value = '';
            updatePreviewThumbnail(editingPreviewDataUrl);
            saveProject();
            updatePreviewSelectors();
            if (target) {
                startEditAnimal(target.id);
            }
            alert(isUpdate ? '動物已更新' : '動物已新增');
        };

        renderClipFrameDurations();
        renderClipDraftList();
        updateClipEditorStatus();
        updateAnimalEditorState();
        updatePreviewThumbnail(editingPreviewDataUrl);

        function renderAnimals() {
            if (!animalList) return;
            upgradeAnimalClips();
            animalList.innerHTML = '';
            if (!Array.isArray(project.animals) || project.animals.length === 0) {
                const empty = document.createElement('div');
                empty.className = 'creature-empty';
                empty.textContent = '尚未新增動物';
                animalList.appendChild(empty);
                if (createItemCreatureEditor) {
                    createItemCreatureEditor.refreshAnimals();
                }
                return;
            }
            project.animals.forEach(an => {
                const card = cloneCard();
                card.querySelector('img').src = an.previewDataUrl || placeholderIcon();
                card.querySelector('.title').textContent = an.name;
                const clips = Array.isArray(an.clips) ? an.clips : [];
                const clipSummary = clips.map(clip => {
                    const frames = normalizeClipFrames(clip);
                    const totalSeconds = frames.reduce((sum, frame) => sum + frame.duration, 0);
                    const fps = Math.max(1, Number(clip.fps || 6));
                    return `${clip.name || '未命名'}（${frames.length} 幀｜${fps} FPS｜${totalSeconds.toFixed(2)} 秒）`;
                }).join('，') || '-';
                const terrainsText = (an.spawnTerrains || []).map(id => {
                    return (project.terrains || []).find(t => t.id === id)?.name || id;
                }).join('、') || '-';
                card.querySelector('.kvs').innerHTML = `<div>ID</div><div>${an.id}</div><div>動畫</div><div>${clipSummary}</div><div>生成地形</div><div>${terrainsText}</div>`;
                const editBtn = card.querySelector('.edit');
                if (editBtn) {
                    editBtn.onclick = () => {
                        switchTab('animals');
                        startEditAnimal(an.id);
                    };
                }
                const delBtn = card.querySelector('.del');
                if (delBtn) {
                    delBtn.onclick = () => {
                        if (!confirm('刪除此動物？')) return;
                        project.animals = project.animals.filter(x => x.id !== an.id);
                        if (editingAnimalId === an.id) {
                            resetAnimalForm();
                        }
                        saveProject();
                        updatePreviewSelectors();
                    };
                }
                animalList.appendChild(card);
            });
            if (createItemCreatureEditor) {
                createItemCreatureEditor.refreshAnimals();
            }
        }

        function updatePreviewSelectors() {
            previewAnimal.innerHTML = '';
            project.animals.forEach(an => {
                const opt = document.createElement('option'); opt.value = an.id; opt.textContent = an.name; previewAnimal.appendChild(opt);
            });
            if (previewAnimal.options.length > 0 && !previewAnimal.value) {
                previewAnimal.value = previewAnimal.options[previewAnimal.options.length - 1].value;
            }
            updatePreviewClips();
        }

        previewAnimal.onchange = updatePreviewClips;
        function updatePreviewClips() {
            previewClip.innerHTML = '';
            const an = project.animals.find(a => a.id === previewAnimal.value);
            (an?.clips || []).forEach(c => { const o = document.createElement('option'); o.value = c.name; o.textContent = c.name; previewClip.appendChild(o); });
            if (previewClip.options.length > 0 && !previewClip.value) { previewClip.value = previewClip.options[0].value; }
            loadPreviewFrames();
        }

        // Animation preview loop
        const animCanvas = document.getElementById('animCanvas');
        const actx = animCanvas.getContext('2d');
        let animTimer = 0, animIdx = 0, loadedFrames = [], animLastTs = 0;
        function loadPreviewFrames() {
            const an = project.animals.find(a => a.id === previewAnimal.value); if (!an) { loadedFrames = []; animLastTs = 0; return; }
            const c = (an.clips || []).find(x => x.name === previewClip.value); if (!c) { loadedFrames = []; animLastTs = 0; return; }
            const frames = normalizeClipFrames(c);
            loadedFrames = frames.map(frame => {
                const img = new Image();
                img.src = frame.src;
                return { img, duration: frame.duration };
            });
            animIdx = 0; animTimer = 0; animLastTs = 0;
        }
        previewClip.onchange = loadPreviewFrames;
        previewSpeed.oninput = () => { };

        function animLoop(ts) {
            requestAnimationFrame(animLoop);
            actx.clearRect(0, 0, animCanvas.width, animCanvas.height);
            const an = project.animals.find(a => a.id === previewAnimal.value);
            const c = an?.clips.find(x => x.name === previewClip.value);
            if (!an || !c || loadedFrames.length === 0) { animLastTs = ts; return; }
            const dt = animLastTs ? Math.max(0, (ts - animLastTs) / 1000) : 0;
            animLastTs = ts;
            const sp = Math.max(0.1, Number(previewSpeed.value || 1));
            let frameData = loadedFrames[animIdx];
            if (!frameData) return;
            animTimer += dt * sp;
            let guard = 0;
            while (frameData && animTimer >= Math.max(0.01, frameData.duration) && guard < loadedFrames.length * 4) {
                animTimer -= Math.max(0.01, frameData.duration);
                animIdx = (animIdx + 1) % loadedFrames.length;
                frameData = loadedFrames[animIdx];
                guard++;
            }
            const img = frameData?.img;
            if (!img || !img.complete || !img.width || !img.height) return;
            const scale = Math.min(animCanvas.width / img.width, animCanvas.height / img.height);
            const w = img.width * scale, h = img.height * scale; const x = (animCanvas.width - w) / 2, y = (animCanvas.height - h) / 2;
            actx.imageSmoothingEnabled = false;
            actx.drawImage(img, x, y, w, h);
        }
        requestAnimationFrame(animLoop);
        setInterval(loadPreviewFrames, 500);

        // ----------------------------- Entities / Hitboxes -----------------------------
        const eSource = document.getElementById('eSource');
        const eName = document.getElementById('eName');
        const eImage = document.getElementById('eImage');
        const eImageRow = eImage?.closest('.row') || null;
        const hitCanvas = document.getElementById('hitCanvas');
        const hctx = hitCanvas.getContext('2d');
        const hitList = document.getElementById('hitList');
        const clearHitboxes = document.getElementById('clearHitboxes');
        const saveEntity = document.getElementById('saveEntity');
        const entityList = document.getElementById('entityList');

        let entityImage = null; // HTMLImageElement
        let entityImageSource = null;
        let hitboxes = []; // {id,x,y,w,h} normalized
        let drag = null; // {id, mode:'move'|'resize', ox, oy, corner}
        let entitySources = [];
        let currentEntityKey = null;
        let currentEntitySource = null;
        let pendingNewCustomKey = null;
        let needsEntityUpgradeSave = false;

        const CUSTOM_NEW_SENTINEL = '__custom_new__';
        const ENTITY_TYPE_LABELS = { item: '物品', animal: '生物', custom: '自訂', unknown: '未知' };

        function upgradeEntityRecords() {
            if (!Array.isArray(project.entities)) project.entities = [];
            project.entities.forEach(en => {
                if (!en || typeof en !== 'object') return;
                if (!en.id) { en.id = 'entity_' + uid(); needsEntityUpgradeSave = true; }
                if (!en.sourceKey) {
                    if (en.sourceType && en.sourceId) {
                        en.sourceKey = `${en.sourceType}:${en.sourceId}`;
                    } else {
                        en.sourceType = 'custom';
                        en.sourceId = en.id;
                        en.sourceKey = `custom:${en.id}`;
                    }
                    needsEntityUpgradeSave = true;
                }
                if (!en.sourceType && en.sourceKey) {
                    en.sourceType = en.sourceKey.split(':')[0] || 'custom';
                    needsEntityUpgradeSave = true;
                }
                if (!en.sourceId && en.sourceKey) {
                    const parts = en.sourceKey.split(':');
                    if (parts.length > 1) {
                        en.sourceId = parts.slice(1).join(':');
                        needsEntityUpgradeSave = true;
                    }
                }
            });
        }

        upgradeEntityRecords();

        function findEntityEntryByKey(key) {
            if (!key) return undefined;
            return (project.entities || []).find(en => en && en.sourceKey === key);
        }

        function loadEntityImage(src) {
            entityImageSource = src || null;
            if (!src) {
                entityImage = null;
                drawHitCanvas();
                return;
            }
            const img = new Image();
            entityImage = img;
            img.onload = () => drawHitCanvas();
            img.onerror = () => { entityImage = null; drawHitCanvas(); };
            img.src = src;
        }

        function updateImageInputState(type) {
            const isCustom = type === 'custom';
            if (eImageRow) eImageRow.style.display = isCustom ? '' : 'none';
            if (eImage) eImage.disabled = !isCustom;
        }

        eImage.onchange = async () => {
            if (!eImage.files || !eImage.files[0]) return;
            const dataUrl = await fileToDataUrl(eImage.files[0]);
            loadEntityImage(dataUrl);
        };

        function cloneHitboxesFromEntry(entry) {
            if (!entry || !Array.isArray(entry.hitboxes)) return [];
            return entry.hitboxes.map(b => ({ id: b.id || uid(), x: b.x, y: b.y, w: b.w, h: b.h }));
        }

        function getAnimalPreview(an) {
            if (!an) return placeholderIcon();
            if (an.previewDataUrl) return an.previewDataUrl;
            if (an.image && an.image.path) return an.image.path;
            if (Array.isArray(an.clips)) {
                for (const clip of an.clips) {
                    const frames = normalizeClipFrames(clip);
                    const first = frames.find(f => f && f.src);
                    if (first && first.src) return first.src;
                }
            }
            return placeholderIcon();
        }

        function collectEntitySources() {
            const entries = new Map();
            if (Array.isArray(project.entities)) {
                project.entities.forEach(en => {
                    if (!en || typeof en !== 'object') return;
                    if (!en.sourceKey) return;
                    entries.set(en.sourceKey, en);
                });
            }
            const used = new Set();
            const sources = [];
            const categoryMap = new Map((project.itemCategories || []).map(cat => [cat.id, cat]));

            (project.items || []).forEach(item => {
                if (!item || !item.id) return;
                const key = `item:${item.id}`;
                const entry = entries.get(key);
                const category = categoryMap.get(item.categoryId);
                const imageSrc = (item.image && item.image.path) || placeholderIcon();
                sources.push({
                    key,
                    type: 'item',
                    sourceId: item.id,
                    baseName: item.name || item.id,
                    displayName: (entry && entry.name) || item.name || item.id,
                    categoryLabel: category?.label || dropLabelFallback[item.categoryId] || item.categoryId || '',
                    imageSrc,
                    entry
                });
                used.add(key);
            });

            (project.animals || []).forEach(an => {
                if (!an || !an.id) return;
                const key = `animal:${an.id}`;
                const entry = entries.get(key);
                sources.push({
                    key,
                    type: 'animal',
                    sourceId: an.id,
                    baseName: an.name || an.id,
                    displayName: (entry && entry.name) || an.name || an.id,
                    categoryLabel: '生物',
                    imageSrc: getAnimalPreview(an),
                    entry
                });
                used.add(key);
            });

            entries.forEach((entry, key) => {
                if (used.has(key)) return;
                const type = entry.sourceType || (key.startsWith('custom:') ? 'custom' : 'unknown');
                const sourceId = entry.sourceId || key.replace(/^custom:/, '');
                const imageSrc = entry.imageDataUrl || entry.imagePath || placeholderIcon();
                sources.push({
                    key,
                    type,
                    sourceId,
                    baseName: entry.name || sourceId || key,
                    displayName: entry.name || sourceId || key,
                    categoryLabel: type === 'custom' ? '自訂' : '未知',
                    imageSrc,
                    entry,
                    orphan: type !== 'custom'
                });
            });

            const typeOrder = { item: 0, animal: 1, custom: 2, unknown: 3 };
            sources.sort((a, b) => {
                const ao = typeOrder[a.type] ?? 99;
                const bo = typeOrder[b.type] ?? 99;
                if (ao !== bo) return ao - bo;
                return (a.baseName || '').localeCompare(b.baseName || '', 'zh-Hant');
            });
            return sources;
        }

        function formatEntityOption(src) {
            const typeLabel = ENTITY_TYPE_LABELS[src.type] || '其他';
            const hitCount = src.entry && Array.isArray(src.entry.hitboxes) ? src.entry.hitboxes.length : 0;
            const hitText = hitCount > 0 ? `（${hitCount} 框）` : '（尚未設定）';
            const idText = src.sourceId ? ` [${src.sourceId}]` : '';
            return `[${typeLabel}] ${src.baseName}${idText} ${hitText}`;
        }

        function refreshEntitySourceOptions() {
            if (!eSource) return;
            const selectedValue = pendingNewCustomKey ? CUSTOM_NEW_SENTINEL : currentEntityKey;
            eSource.innerHTML = '';
            const placeholder = document.createElement('option');
            placeholder.value = '';
            placeholder.textContent = '選擇來源（物品 / 動物 或自訂）';
            eSource.appendChild(placeholder);
            const customOpt = document.createElement('option');
            customOpt.value = CUSTOM_NEW_SENTINEL;
            customOpt.textContent = '＋ 新增自訂生物底圖';
            eSource.appendChild(customOpt);
            entitySources.forEach(src => {
                const opt = document.createElement('option');
                opt.value = src.key;
                opt.textContent = formatEntityOption(src);
                eSource.appendChild(opt);
            });
            const validValues = new Set(Array.from(eSource.options).map(opt => opt.value));
            if (selectedValue && validValues.has(selectedValue)) {
                eSource.value = selectedValue;
            } else if (pendingNewCustomKey) {
                eSource.value = CUSTOM_NEW_SENTINEL;
            } else {
                eSource.value = '';
            }
        }

        function renderEntityCards() {
            entityList.innerHTML = '';
            if (entitySources.length === 0) {
                const empty = document.createElement('div');
                empty.className = 'note';
                empty.textContent = '尚未同步到任何物品或動物資料，可先新增後再設定碰撞框。';
                entityList.appendChild(empty);
                return;
            }
            entitySources.forEach(src => {
                const card = cloneCard();
                card.querySelector('img').src = src.imageSrc || placeholderIcon();
                card.querySelector('.title').textContent = src.displayName || src.baseName || src.key;
                const kvs = [];
                const typeLabel = ENTITY_TYPE_LABELS[src.type] || src.type;
                kvs.push('<div>類型</div><div>' + typeLabel + '</div>');
                if (src.sourceId) kvs.push('<div>來源ID</div><div>' + src.sourceId + '</div>');
                if (src.type === 'item' && src.categoryLabel) kvs.push('<div>分類</div><div>' + src.categoryLabel + '</div>');
                const hitCount = src.entry && Array.isArray(src.entry.hitboxes) ? src.entry.hitboxes.length : 0;
                kvs.push('<div>碰撞框</div><div>' + (hitCount > 0 ? `${hitCount} 個` : '尚未設定') + '</div>');
                if (src.orphan) kvs.push('<div>狀態</div><div>來源不存在</div>');
                card.querySelector('.kvs').innerHTML = kvs.join('');
                card.querySelector('.edit').onclick = () => {
                    switchTab('entities');
                    selectEntitySource(src.key);
                };
                const delBtn = card.querySelector('.del');
                if (src.entry) {
                    delBtn.textContent = '清除碰撞框';
                    delBtn.disabled = false;
                    delBtn.onclick = () => {
                        if (!confirm('清除此來源的所有碰撞框？')) return;
                        project.entities = project.entities.filter(en => en !== src.entry);
                        if (currentEntityKey === src.key) {
                            hitboxes = [];
                            renderHitList();
                        }
                        saveProject();
                    };
                } else {
                    delBtn.textContent = '尚未設定';
                    delBtn.disabled = true;
                    delBtn.onclick = null;
                }
                entityList.appendChild(card);
            });
        }

        function selectEntitySource(key, { resetHitboxes = true } = {}) {
            if (!key) {
                currentEntityKey = null;
                currentEntitySource = null;
                pendingNewCustomKey = null;
                updateImageInputState(null);
                hitboxes = [];
                entityImage = null;
                entityImageSource = null;
                eImage.value = '';
                drawHitCanvas();
                renderHitList();
                refreshEntitySourceOptions();
                return;
            }
            pendingNewCustomKey = null;
            currentEntityKey = key;
            const source = entitySources.find(s => s.key === key) || null;
            currentEntitySource = source;
            if (!source) {
                updateImageInputState(null);
                hitboxes = [];
                entityImage = null;
                entityImageSource = null;
                drawHitCanvas();
                renderHitList();
                refreshEntitySourceOptions();
                return;
            }
            updateImageInputState(source.type);
            const entry = findEntityEntryByKey(key);
            if (source.type === 'custom') {
                const imgSrc = entry?.imageDataUrl || entry?.imagePath || null;
                loadEntityImage(imgSrc);
            } else {
                const imgSrc = source.imageSrc || placeholderIcon();
                if (entityImageSource !== imgSrc) loadEntityImage(imgSrc);
            }
            if (resetHitboxes) {
                hitboxes = cloneHitboxesFromEntry(entry);
                renderHitList();
            }
            const fallbackName = source.displayName || source.baseName || '';
            eName.value = entry?.name || fallbackName;
            refreshEntitySourceOptions();
            drawHitCanvas();
        }

        function prepareNewCustomEntity() {
            const newKey = `custom:${uid()}`;
            pendingNewCustomKey = newKey;
            currentEntityKey = newKey;
            currentEntitySource = { key: newKey, type: 'custom', baseName: '', displayName: '', sourceId: newKey.replace('custom:', '') };
            updateImageInputState('custom');
            eName.value = '';
            eImage.value = '';
            hitboxes = [];
            entityImage = null;
            entityImageSource = null;
            drawHitCanvas();
            renderHitList();
            refreshEntitySourceOptions();
        }

        if (eSource) {
            eSource.onchange = () => {
                if (eSource.value === CUSTOM_NEW_SENTINEL) {
                    prepareNewCustomEntity();
                    return;
                }
                if (!eSource.value) {
                    selectEntitySource(null);
                    return;
                }
                selectEntitySource(eSource.value);
            };
        }

        function toCanvas(px, py) { return { x: px * hitCanvas.width, y: py * hitCanvas.height }; }
        function toNorm(cx, cy) { return { x: cx / hitCanvas.width, y: cy / hitCanvas.height }; }

        function drawHitCanvas() {
            hctx.clearRect(0, 0, hitCanvas.width, hitCanvas.height);
            if (entityImage) {
                const scale = Math.min(hitCanvas.width / entityImage.width, hitCanvas.height / entityImage.height);
                const w = entityImage.width * scale, h = entityImage.height * scale, x = (hitCanvas.width - w) / 2, y = (hitCanvas.height - h) / 2;
                hctx.imageSmoothingEnabled = false; hctx.drawImage(entityImage, x, y, w, h);
            }
            hitboxes.forEach(b => {
                const { x, y } = toCanvas(b.x, b.y); const { x: rx, y: ry } = toCanvas(b.x + b.w, b.y + b.h);
                hctx.strokeStyle = '#7cffc4'; hctx.setLineDash([6, 4]); hctx.lineWidth = 2; hctx.strokeRect(x, y, rx - x, ry - y);
                hctx.setLineDash([]);
                hctx.fillStyle = 'rgba(124,255,196,0.15)'; hctx.fillRect(x, y, rx - x, ry - y);
                drawHandle(x, y); drawHandle(rx, y); drawHandle(x, ry); drawHandle(rx, ry);
            });
        }
        function drawHandle(x, y) { hctx.fillStyle = '#7aa2ff'; hctx.fillRect(x - 5, y - 5, 10, 10); }

        function hitAt(cx, cy) {
            for (const b of [...hitboxes].slice().reverse()) {
                const { x, y } = toCanvas(b.x, b.y); const { x: rx, y: ry } = toCanvas(b.x + b.w, b.y + b.h);
                const inBox = cx >= x && cy >= y && cx <= rx && cy <= ry;
                const csize = 14;
                const corners = [{ k: 'tl', X: x, Y: y }, { k: 'tr', X: rx, Y: y }, { k: 'bl', X: x, Y: ry }, { k: 'br', X: rx, Y: ry }];
                for (const c of corners) { if (Math.abs(cx - c.X) <= csize && Math.abs(cy - c.Y) <= csize) return { box: b, corner: c.k }; }
                if (inBox) return { box: b, corner: null };
            }
            return null;
        }

        hitCanvas.oncontextmenu = e => e.preventDefault();
        hitCanvas.onpointerdown = e => {
            const rect = hitCanvas.getBoundingClientRect(); const cx = e.clientX - rect.left, cy = e.clientY - rect.top;
            const h = hitAt(cx, cy);
            if (e.button === 2 && h) {
                hitboxes = hitboxes.filter(x => x !== h.box); drawHitCanvas(); renderHitList(); return;
            }
            if (h) {
                drag = { id: h.box.id, mode: h.corner ? 'resize' : 'move', ox: cx, oy: cy, corner: h.corner };
            } else if (e.button === 0 && e.shiftKey) {
                const { x, y } = toNorm(cx, cy); const b = { id: uid(), x, y, w: 0.01, h: 0.01 }; hitboxes.push(b); drag = { id: b.id, mode: 'resize', ox: cx, oy: cy, corner: 'br' };
            }
            drawHitCanvas(); renderHitList();
        };
        hitCanvas.onpointermove = e => {
            if (!drag) return;
            const rect = hitCanvas.getBoundingClientRect(); const cx = e.clientX - rect.left, cy = e.clientY - rect.top;
            const box = hitboxes.find(b => b.id === drag.id); if (!box) return;
            if (drag.mode === 'move') {
                const dx = (cx - drag.ox) / hitCanvas.width, dy = (cy - drag.oy) / hitCanvas.height; box.x += dx; box.y += dy; drag.ox = cx; drag.oy = cy;
            } else if (drag.mode === 'resize') {
                const nx = Math.min(Math.max(cx, 0), hitCanvas.width); const ny = Math.min(Math.max(cy, 0), hitCanvas.height);
                const { x: px, y: py } = toNorm(nx, ny); let nx0 = box.x, ny0 = box.y, nw = box.w, nh = box.h;
                if (drag.corner === 'br') { nw = px - box.x; nh = py - box.y; }
                if (drag.corner === 'tr') { nw = px - box.x; ny0 = py; nh = (box.y + box.h) - py; }
                if (drag.corner === 'bl') { nx0 = px; nw = (box.x + box.w) - px; nh = py - box.y; }
                if (drag.corner === 'tl') { nx0 = px; ny0 = py; nw = (box.x + box.w) - px; nh = (box.y + box.h) - py; }
                box.x = nx0; box.y = ny0; box.w = nw; box.h = nh;
            }
            clampBox(box); drawHitCanvas(); renderHitList();
        };
        hitCanvas.onpointerup = () => drag = null;
        function clampBox(b) {
            b.w = Math.max(0.001, Math.min(1 - b.x, b.w));
            b.h = Math.max(0.001, Math.min(1 - b.y, b.h));
            b.x = Math.max(0, Math.min(1 - b.w, b.x));
            b.y = Math.max(0, Math.min(1 - b.h, b.y));
        }

        clearHitboxes.onclick = () => {
            if (!currentEntityKey && !pendingNewCustomKey) {
                alert('請先選擇要編輯的來源');
                return;
            }
            if (confirm('清空目前畫布的碰撞框？')) { hitboxes = []; drawHitCanvas(); renderHitList(); }
        };

        saveEntity.onclick = async () => {
            if (!currentEntityKey) {
                alert('請先選擇來源或新增自訂生物');
                return;
            }
            const sourceType = currentEntitySource?.type || currentEntityKey.split(':')[0] || 'custom';
            const sourceId = currentEntitySource?.sourceId || currentEntityKey.split(':').slice(1).join(':') || currentEntityKey;
            const defaultName = currentEntitySource?.displayName || currentEntitySource?.baseName || sourceId || '';
            const name = eName.value.trim() || defaultName;
            if (!name) return alert('請輸入生物名稱');
            if (!entityImage) return alert('請先載入底圖');

            let entry = findEntityEntryByKey(currentEntityKey);
            if (!entry) {
                entry = {
                    id: 'entity_' + uid(),
                    sourceKey: currentEntityKey,
                    sourceType,
                    sourceId,
                    createdAt: new Date().toISOString()
                };
                project.entities.push(entry);
            }
            entry.sourceKey = currentEntityKey;
            entry.sourceType = sourceType;
            entry.sourceId = sourceId;
            entry.name = name;
            entry.hitboxes = JSON.parse(JSON.stringify(hitboxes));
            entry.updatedAt = new Date().toISOString();
            if (sourceType === 'custom') {
                entry.imageDataUrl = entityImageSource || (entityImage?.src ?? entry.imageDataUrl ?? null);
            } else {
                delete entry.imageDataUrl;
            }
            pendingNewCustomKey = null;
            saveProject();
        };

        function renderHitList() {
            hitList.innerHTML = '';
            if (hitboxes.length === 0) {
                const empty = document.createElement('div');
                empty.className = 'small';
                empty.textContent = '尚未設定碰撞框';
                hitList.appendChild(empty);
                return;
            }
            hitboxes.forEach((b, i) => {
                const div = document.createElement('div'); div.className = 'row';
                div.innerHTML = `<label>#${i + 1}</label><div class="chips">`
                    + `<span class="chip">x:${b.x.toFixed(3)}</span>`
                    + `<span class="chip">y:${b.y.toFixed(3)}</span>`
                    + `<span class="chip">w:${b.w.toFixed(3)}</span>`
                    + `<span class="chip">h:${b.h.toFixed(3)}</span>` + `</div>`;
                hitList.appendChild(div);
            });
        }

        function renderEntities() {
            entitySources = collectEntitySources();
            if (!pendingNewCustomKey && currentEntityKey) {
                const source = entitySources.find(s => s.key === currentEntityKey) || null;
                if (!source) {
                    currentEntitySource = null;
                    currentEntityKey = null;
                    updateImageInputState(null);
                    hitboxes = [];
                    entityImage = null;
                    entityImageSource = null;
                    drawHitCanvas();
                    renderHitList();
                } else {
                    currentEntitySource = source;
                    if (source.type !== 'custom') {
                        const imgSrc = source.imageSrc || placeholderIcon();
                        if (entityImageSource !== imgSrc) loadEntityImage(imgSrc);
                    }
                }
            }
            if (pendingNewCustomKey) {
                updateImageInputState('custom');
            } else if (currentEntitySource) {
                updateImageInputState(currentEntitySource.type);
            } else {
                updateImageInputState(null);
            }
            refreshEntitySourceOptions();
            renderEntityCards();
        }

        if (needsEntityUpgradeSave) {
            needsEntityUpgradeSave = false;
            saveProject();
        }
        // ----------------------------- Import / Export / Reset -----------------------------
        document.getElementById('btnExport').onclick = () => {
            const file = new Blob([JSON.stringify(project, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(file); const a = document.createElement('a'); a.href = url; a.download = 'game-assets.json'; a.click(); URL.revokeObjectURL(url);
        };
        document.getElementById('importJson').onchange = async (e) => {
            const f = e.target.files?.[0]; if (!f) return; const txt = await f.text();
            try { project = JSON.parse(txt); saveProject(); alert('匯入完成'); updatePreviewSelectors(); }
            catch (err) { alert('匯入失敗：JSON 格式錯誤'); }
            e.target.value = '';
        };
        document.getElementById('btnReset').onclick = () => { if (confirm('清空並重置所有資料？')) { project = emptyProject(); saveProject(); updatePreviewSelectors(); } };

        // ----------------------------- Helpers & Render -----------------------------
        function cloneCard() { return document.getElementById('tpl-card').content.firstElementChild.cloneNode(true); }
        function placeholderIcon() {
            return 'data:image/svg+xml,' + encodeURIComponent(svgIcon('#7cffc4'));
        }
        function svgIcon(color) {
            return `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64"><defs><linearGradient id="g" x1="0" y1="0" x2="1" y2="1"><stop offset="0" stop-color="${color}"/><stop offset="1" stop-color="#1e2a66"/></linearGradient></defs><rect rx="12" width="64" height="64" fill="url(#g)"/><g fill="#0b1020" opacity=".6"><circle cx="48" cy="14" r="4"/><circle cx="20" cy="46" r="6"/><rect x="12" y="14" width="24" height="12" rx="3"/></g></svg>`;
        }

        function renderAll() { renderTerrains(); renderItems(); renderAnimals(); renderEntities(); }

        // ----------------------------- Init -----------------------------
        renderAll(); switchTab(currentTab); updatePreviewSelectors(); drawHitCanvas();
        syncItemsFromServer();
        syncTerrainsFromServer();
    </script>

    <!-- Drops UI add-on v2 -->
    <script src="drops-addon.js"></script>
    <script>(function () { function f() { return document.querySelector('#item-editor-right') || document.querySelector('#item-editor') || document.querySelector('#items-panel') || document.querySelector('[data-tab="items"]') || document.body } if (typeof window.openItemEditor === 'function') { const o = window.openItemEditor; window.openItemEditor = function (i) { const r = o.apply(this, arguments); try { ItemDrops.onOpen(i, f()) } catch (e) { console.warn('[drops] onOpen warn:', e) } return r } } window.addEventListener('adventurelife:openItemEditor', ev => { const i = ev.detail && ev.detail.item; if (i) ItemDrops.onOpen(i, f()) }); function w() { const form = document.querySelector('form#item-form, form[name="item-form"]') || document.querySelector('#items form'); if (!form) return; form.addEventListener('submit', function (e) { try { const fd = new FormData(this); ItemDrops.onCollect(fd); } catch (err) { console.warn('[drops] submit hook warn:', err) } }, { capture: true }); } document.addEventListener('DOMContentLoaded', w); setTimeout(w, 800); })();</script>

</body>

</html>